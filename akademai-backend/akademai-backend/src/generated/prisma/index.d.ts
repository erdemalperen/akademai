
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model admin_permission_logs
 * 
 */
export type admin_permission_logs = $Result.DefaultSelection<Prisma.$admin_permission_logsPayload>
/**
 * Model admin_permissions
 * 
 */
export type admin_permissions = $Result.DefaultSelection<Prisma.$admin_permissionsPayload>
/**
 * Model bootcamp_progress
 * 
 */
export type bootcamp_progress = $Result.DefaultSelection<Prisma.$bootcamp_progressPayload>
/**
 * Model bootcamp_trainings
 * 
 */
export type bootcamp_trainings = $Result.DefaultSelection<Prisma.$bootcamp_trainingsPayload>
/**
 * Model bootcamps
 * 
 */
export type bootcamps = $Result.DefaultSelection<Prisma.$bootcampsPayload>
/**
 * Model conference_attendees
 * 
 */
export type conference_attendees = $Result.DefaultSelection<Prisma.$conference_attendeesPayload>
/**
 * Model conference_materials
 * 
 */
export type conference_materials = $Result.DefaultSelection<Prisma.$conference_materialsPayload>
/**
 * Model conference_trainings
 * 
 */
export type conference_trainings = $Result.DefaultSelection<Prisma.$conference_trainingsPayload>
/**
 * Model enrollments
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type enrollments = $Result.DefaultSelection<Prisma.$enrollmentsPayload>
/**
 * Model questions
 * 
 */
export type questions = $Result.DefaultSelection<Prisma.$questionsPayload>
/**
 * Model quizzes
 * 
 */
export type quizzes = $Result.DefaultSelection<Prisma.$quizzesPayload>
/**
 * Model training_content
 * 
 */
export type training_content = $Result.DefaultSelection<Prisma.$training_contentPayload>
/**
 * Model trainings
 * 
 */
export type trainings = $Result.DefaultSelection<Prisma.$trainingsPayload>
/**
 * Model user_bootcamp_assignments
 * 
 */
export type user_bootcamp_assignments = $Result.DefaultSelection<Prisma.$user_bootcamp_assignmentsPayload>
/**
 * Model user_quiz_attempts
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type user_quiz_attempts = $Result.DefaultSelection<Prisma.$user_quiz_attemptsPayload>
/**
 * Model user_training_assignments
 * 
 */
export type user_training_assignments = $Result.DefaultSelection<Prisma.$user_training_assignmentsPayload>
/**
 * Model user_training_progress
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type user_training_progress = $Result.DefaultSelection<Prisma.$user_training_progressPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  EMPLOYEE: 'EMPLOYEE',
  ADMIN_JUNIOR: 'ADMIN_JUNIOR',
  ADMIN_SENIOR: 'ADMIN_SENIOR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const LoginType: {
  TELESET_CARD: 'TELESET_CARD',
  MICROSOFT: 'MICROSOFT',
  USERNAME_PASSWORD: 'USERNAME_PASSWORD'
};

export type LoginType = (typeof LoginType)[keyof typeof LoginType]


export const login_type: {
  TELESET_CARD: 'TELESET_CARD',
  MICROSOFT: 'MICROSOFT',
  USERNAME_PASSWORD: 'USERNAME_PASSWORD'
};

export type login_type = (typeof login_type)[keyof typeof login_type]


export const user_role: {
  EMPLOYEE: 'EMPLOYEE',
  ADMIN_JUNIOR: 'ADMIN_JUNIOR',
  ADMIN_SENIOR: 'ADMIN_SENIOR'
};

export type user_role = (typeof user_role)[keyof typeof user_role]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type LoginType = $Enums.LoginType

export const LoginType: typeof $Enums.LoginType

export type login_type = $Enums.login_type

export const login_type: typeof $Enums.login_type

export type user_role = $Enums.user_role

export const user_role: typeof $Enums.user_role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin_permission_logs`: Exposes CRUD operations for the **admin_permission_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_permission_logs
    * const admin_permission_logs = await prisma.admin_permission_logs.findMany()
    * ```
    */
  get admin_permission_logs(): Prisma.admin_permission_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin_permissions`: Exposes CRUD operations for the **admin_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admin_permissions
    * const admin_permissions = await prisma.admin_permissions.findMany()
    * ```
    */
  get admin_permissions(): Prisma.admin_permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bootcamp_progress`: Exposes CRUD operations for the **bootcamp_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bootcamp_progresses
    * const bootcamp_progresses = await prisma.bootcamp_progress.findMany()
    * ```
    */
  get bootcamp_progress(): Prisma.bootcamp_progressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bootcamp_trainings`: Exposes CRUD operations for the **bootcamp_trainings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bootcamp_trainings
    * const bootcamp_trainings = await prisma.bootcamp_trainings.findMany()
    * ```
    */
  get bootcamp_trainings(): Prisma.bootcamp_trainingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bootcamps`: Exposes CRUD operations for the **bootcamps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bootcamps
    * const bootcamps = await prisma.bootcamps.findMany()
    * ```
    */
  get bootcamps(): Prisma.bootcampsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conference_attendees`: Exposes CRUD operations for the **conference_attendees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conference_attendees
    * const conference_attendees = await prisma.conference_attendees.findMany()
    * ```
    */
  get conference_attendees(): Prisma.conference_attendeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conference_materials`: Exposes CRUD operations for the **conference_materials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conference_materials
    * const conference_materials = await prisma.conference_materials.findMany()
    * ```
    */
  get conference_materials(): Prisma.conference_materialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conference_trainings`: Exposes CRUD operations for the **conference_trainings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conference_trainings
    * const conference_trainings = await prisma.conference_trainings.findMany()
    * ```
    */
  get conference_trainings(): Prisma.conference_trainingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollments`: Exposes CRUD operations for the **enrollments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollments.findMany()
    * ```
    */
  get enrollments(): Prisma.enrollmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.questionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizzes`: Exposes CRUD operations for the **quizzes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quizzes.findMany()
    * ```
    */
  get quizzes(): Prisma.quizzesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.training_content`: Exposes CRUD operations for the **training_content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Training_contents
    * const training_contents = await prisma.training_content.findMany()
    * ```
    */
  get training_content(): Prisma.training_contentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trainings`: Exposes CRUD operations for the **trainings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trainings
    * const trainings = await prisma.trainings.findMany()
    * ```
    */
  get trainings(): Prisma.trainingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_bootcamp_assignments`: Exposes CRUD operations for the **user_bootcamp_assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_bootcamp_assignments
    * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.findMany()
    * ```
    */
  get user_bootcamp_assignments(): Prisma.user_bootcamp_assignmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_quiz_attempts`: Exposes CRUD operations for the **user_quiz_attempts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_quiz_attempts
    * const user_quiz_attempts = await prisma.user_quiz_attempts.findMany()
    * ```
    */
  get user_quiz_attempts(): Prisma.user_quiz_attemptsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_training_assignments`: Exposes CRUD operations for the **user_training_assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_training_assignments
    * const user_training_assignments = await prisma.user_training_assignments.findMany()
    * ```
    */
  get user_training_assignments(): Prisma.user_training_assignmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_training_progress`: Exposes CRUD operations for the **user_training_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_training_progresses
    * const user_training_progresses = await prisma.user_training_progress.findMany()
    * ```
    */
  get user_training_progress(): Prisma.user_training_progressDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Employee: 'Employee',
    Admin: 'Admin',
    Department: 'Department',
    Log: 'Log',
    admin_permission_logs: 'admin_permission_logs',
    admin_permissions: 'admin_permissions',
    bootcamp_progress: 'bootcamp_progress',
    bootcamp_trainings: 'bootcamp_trainings',
    bootcamps: 'bootcamps',
    conference_attendees: 'conference_attendees',
    conference_materials: 'conference_materials',
    conference_trainings: 'conference_trainings',
    enrollments: 'enrollments',
    questions: 'questions',
    quizzes: 'quizzes',
    training_content: 'training_content',
    trainings: 'trainings',
    user_bootcamp_assignments: 'user_bootcamp_assignments',
    user_quiz_attempts: 'user_quiz_attempts',
    user_training_assignments: 'user_training_assignments',
    user_training_progress: 'user_training_progress'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "employee" | "admin" | "department" | "log" | "admin_permission_logs" | "admin_permissions" | "bootcamp_progress" | "bootcamp_trainings" | "bootcamps" | "conference_attendees" | "conference_materials" | "conference_trainings" | "enrollments" | "questions" | "quizzes" | "training_content" | "trainings" | "user_bootcamp_assignments" | "user_quiz_attempts" | "user_training_assignments" | "user_training_progress"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      admin_permission_logs: {
        payload: Prisma.$admin_permission_logsPayload<ExtArgs>
        fields: Prisma.admin_permission_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_permission_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_permission_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>
          }
          findFirst: {
            args: Prisma.admin_permission_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_permission_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>
          }
          findMany: {
            args: Prisma.admin_permission_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>[]
          }
          create: {
            args: Prisma.admin_permission_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>
          }
          createMany: {
            args: Prisma.admin_permission_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.admin_permission_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>[]
          }
          delete: {
            args: Prisma.admin_permission_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>
          }
          update: {
            args: Prisma.admin_permission_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>
          }
          deleteMany: {
            args: Prisma.admin_permission_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_permission_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.admin_permission_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>[]
          }
          upsert: {
            args: Prisma.admin_permission_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permission_logsPayload>
          }
          aggregate: {
            args: Prisma.Admin_permission_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_permission_logs>
          }
          groupBy: {
            args: Prisma.admin_permission_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_permission_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_permission_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_permission_logsCountAggregateOutputType> | number
          }
        }
      }
      admin_permissions: {
        payload: Prisma.$admin_permissionsPayload<ExtArgs>
        fields: Prisma.admin_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.admin_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.admin_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          findFirst: {
            args: Prisma.admin_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.admin_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          findMany: {
            args: Prisma.admin_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>[]
          }
          create: {
            args: Prisma.admin_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          createMany: {
            args: Prisma.admin_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.admin_permissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>[]
          }
          delete: {
            args: Prisma.admin_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          update: {
            args: Prisma.admin_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.admin_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.admin_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.admin_permissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>[]
          }
          upsert: {
            args: Prisma.admin_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$admin_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Admin_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin_permissions>
          }
          groupBy: {
            args: Prisma.admin_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Admin_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.admin_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Admin_permissionsCountAggregateOutputType> | number
          }
        }
      }
      bootcamp_progress: {
        payload: Prisma.$bootcamp_progressPayload<ExtArgs>
        fields: Prisma.bootcamp_progressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bootcamp_progressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bootcamp_progressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>
          }
          findFirst: {
            args: Prisma.bootcamp_progressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bootcamp_progressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>
          }
          findMany: {
            args: Prisma.bootcamp_progressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>[]
          }
          create: {
            args: Prisma.bootcamp_progressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>
          }
          createMany: {
            args: Prisma.bootcamp_progressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bootcamp_progressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>[]
          }
          delete: {
            args: Prisma.bootcamp_progressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>
          }
          update: {
            args: Prisma.bootcamp_progressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>
          }
          deleteMany: {
            args: Prisma.bootcamp_progressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bootcamp_progressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bootcamp_progressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>[]
          }
          upsert: {
            args: Prisma.bootcamp_progressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_progressPayload>
          }
          aggregate: {
            args: Prisma.Bootcamp_progressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBootcamp_progress>
          }
          groupBy: {
            args: Prisma.bootcamp_progressGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bootcamp_progressGroupByOutputType>[]
          }
          count: {
            args: Prisma.bootcamp_progressCountArgs<ExtArgs>
            result: $Utils.Optional<Bootcamp_progressCountAggregateOutputType> | number
          }
        }
      }
      bootcamp_trainings: {
        payload: Prisma.$bootcamp_trainingsPayload<ExtArgs>
        fields: Prisma.bootcamp_trainingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bootcamp_trainingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bootcamp_trainingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>
          }
          findFirst: {
            args: Prisma.bootcamp_trainingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bootcamp_trainingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>
          }
          findMany: {
            args: Prisma.bootcamp_trainingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>[]
          }
          create: {
            args: Prisma.bootcamp_trainingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>
          }
          createMany: {
            args: Prisma.bootcamp_trainingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bootcamp_trainingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>[]
          }
          delete: {
            args: Prisma.bootcamp_trainingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>
          }
          update: {
            args: Prisma.bootcamp_trainingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>
          }
          deleteMany: {
            args: Prisma.bootcamp_trainingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bootcamp_trainingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bootcamp_trainingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>[]
          }
          upsert: {
            args: Prisma.bootcamp_trainingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcamp_trainingsPayload>
          }
          aggregate: {
            args: Prisma.Bootcamp_trainingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBootcamp_trainings>
          }
          groupBy: {
            args: Prisma.bootcamp_trainingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bootcamp_trainingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bootcamp_trainingsCountArgs<ExtArgs>
            result: $Utils.Optional<Bootcamp_trainingsCountAggregateOutputType> | number
          }
        }
      }
      bootcamps: {
        payload: Prisma.$bootcampsPayload<ExtArgs>
        fields: Prisma.bootcampsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bootcampsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bootcampsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>
          }
          findFirst: {
            args: Prisma.bootcampsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bootcampsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>
          }
          findMany: {
            args: Prisma.bootcampsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>[]
          }
          create: {
            args: Prisma.bootcampsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>
          }
          createMany: {
            args: Prisma.bootcampsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.bootcampsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>[]
          }
          delete: {
            args: Prisma.bootcampsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>
          }
          update: {
            args: Prisma.bootcampsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>
          }
          deleteMany: {
            args: Prisma.bootcampsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bootcampsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.bootcampsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>[]
          }
          upsert: {
            args: Prisma.bootcampsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bootcampsPayload>
          }
          aggregate: {
            args: Prisma.BootcampsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBootcamps>
          }
          groupBy: {
            args: Prisma.bootcampsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BootcampsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bootcampsCountArgs<ExtArgs>
            result: $Utils.Optional<BootcampsCountAggregateOutputType> | number
          }
        }
      }
      conference_attendees: {
        payload: Prisma.$conference_attendeesPayload<ExtArgs>
        fields: Prisma.conference_attendeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conference_attendeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conference_attendeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>
          }
          findFirst: {
            args: Prisma.conference_attendeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conference_attendeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>
          }
          findMany: {
            args: Prisma.conference_attendeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>[]
          }
          create: {
            args: Prisma.conference_attendeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>
          }
          createMany: {
            args: Prisma.conference_attendeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conference_attendeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>[]
          }
          delete: {
            args: Prisma.conference_attendeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>
          }
          update: {
            args: Prisma.conference_attendeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>
          }
          deleteMany: {
            args: Prisma.conference_attendeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conference_attendeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conference_attendeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>[]
          }
          upsert: {
            args: Prisma.conference_attendeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_attendeesPayload>
          }
          aggregate: {
            args: Prisma.Conference_attendeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConference_attendees>
          }
          groupBy: {
            args: Prisma.conference_attendeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Conference_attendeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.conference_attendeesCountArgs<ExtArgs>
            result: $Utils.Optional<Conference_attendeesCountAggregateOutputType> | number
          }
        }
      }
      conference_materials: {
        payload: Prisma.$conference_materialsPayload<ExtArgs>
        fields: Prisma.conference_materialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conference_materialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conference_materialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>
          }
          findFirst: {
            args: Prisma.conference_materialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conference_materialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>
          }
          findMany: {
            args: Prisma.conference_materialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>[]
          }
          create: {
            args: Prisma.conference_materialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>
          }
          createMany: {
            args: Prisma.conference_materialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conference_materialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>[]
          }
          delete: {
            args: Prisma.conference_materialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>
          }
          update: {
            args: Prisma.conference_materialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>
          }
          deleteMany: {
            args: Prisma.conference_materialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conference_materialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conference_materialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>[]
          }
          upsert: {
            args: Prisma.conference_materialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_materialsPayload>
          }
          aggregate: {
            args: Prisma.Conference_materialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConference_materials>
          }
          groupBy: {
            args: Prisma.conference_materialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Conference_materialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.conference_materialsCountArgs<ExtArgs>
            result: $Utils.Optional<Conference_materialsCountAggregateOutputType> | number
          }
        }
      }
      conference_trainings: {
        payload: Prisma.$conference_trainingsPayload<ExtArgs>
        fields: Prisma.conference_trainingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conference_trainingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conference_trainingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>
          }
          findFirst: {
            args: Prisma.conference_trainingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conference_trainingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>
          }
          findMany: {
            args: Prisma.conference_trainingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>[]
          }
          create: {
            args: Prisma.conference_trainingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>
          }
          createMany: {
            args: Prisma.conference_trainingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conference_trainingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>[]
          }
          delete: {
            args: Prisma.conference_trainingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>
          }
          update: {
            args: Prisma.conference_trainingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>
          }
          deleteMany: {
            args: Prisma.conference_trainingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conference_trainingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conference_trainingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>[]
          }
          upsert: {
            args: Prisma.conference_trainingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conference_trainingsPayload>
          }
          aggregate: {
            args: Prisma.Conference_trainingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConference_trainings>
          }
          groupBy: {
            args: Prisma.conference_trainingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Conference_trainingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.conference_trainingsCountArgs<ExtArgs>
            result: $Utils.Optional<Conference_trainingsCountAggregateOutputType> | number
          }
        }
      }
      enrollments: {
        payload: Prisma.$enrollmentsPayload<ExtArgs>
        fields: Prisma.enrollmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.enrollmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.enrollmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          findFirst: {
            args: Prisma.enrollmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.enrollmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          findMany: {
            args: Prisma.enrollmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          create: {
            args: Prisma.enrollmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          createMany: {
            args: Prisma.enrollmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.enrollmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          delete: {
            args: Prisma.enrollmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          update: {
            args: Prisma.enrollmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          deleteMany: {
            args: Prisma.enrollmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.enrollmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.enrollmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          upsert: {
            args: Prisma.enrollmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollments>
          }
          groupBy: {
            args: Prisma.enrollmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.enrollmentsCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentsCountAggregateOutputType> | number
          }
        }
      }
      questions: {
        payload: Prisma.$questionsPayload<ExtArgs>
        fields: Prisma.questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findFirst: {
            args: Prisma.questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findMany: {
            args: Prisma.questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          create: {
            args: Prisma.questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          createMany: {
            args: Prisma.questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.questionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          delete: {
            args: Prisma.questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          update: {
            args: Prisma.questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          deleteMany: {
            args: Prisma.questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.questionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          upsert: {
            args: Prisma.questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      quizzes: {
        payload: Prisma.$quizzesPayload<ExtArgs>
        fields: Prisma.quizzesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quizzesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quizzesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>
          }
          findFirst: {
            args: Prisma.quizzesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quizzesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>
          }
          findMany: {
            args: Prisma.quizzesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>[]
          }
          create: {
            args: Prisma.quizzesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>
          }
          createMany: {
            args: Prisma.quizzesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.quizzesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>[]
          }
          delete: {
            args: Prisma.quizzesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>
          }
          update: {
            args: Prisma.quizzesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>
          }
          deleteMany: {
            args: Prisma.quizzesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quizzesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.quizzesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>[]
          }
          upsert: {
            args: Prisma.quizzesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quizzesPayload>
          }
          aggregate: {
            args: Prisma.QuizzesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizzes>
          }
          groupBy: {
            args: Prisma.quizzesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizzesGroupByOutputType>[]
          }
          count: {
            args: Prisma.quizzesCountArgs<ExtArgs>
            result: $Utils.Optional<QuizzesCountAggregateOutputType> | number
          }
        }
      }
      training_content: {
        payload: Prisma.$training_contentPayload<ExtArgs>
        fields: Prisma.training_contentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.training_contentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.training_contentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>
          }
          findFirst: {
            args: Prisma.training_contentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.training_contentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>
          }
          findMany: {
            args: Prisma.training_contentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>[]
          }
          create: {
            args: Prisma.training_contentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>
          }
          createMany: {
            args: Prisma.training_contentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.training_contentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>[]
          }
          delete: {
            args: Prisma.training_contentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>
          }
          update: {
            args: Prisma.training_contentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>
          }
          deleteMany: {
            args: Prisma.training_contentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.training_contentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.training_contentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>[]
          }
          upsert: {
            args: Prisma.training_contentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$training_contentPayload>
          }
          aggregate: {
            args: Prisma.Training_contentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraining_content>
          }
          groupBy: {
            args: Prisma.training_contentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Training_contentGroupByOutputType>[]
          }
          count: {
            args: Prisma.training_contentCountArgs<ExtArgs>
            result: $Utils.Optional<Training_contentCountAggregateOutputType> | number
          }
        }
      }
      trainings: {
        payload: Prisma.$trainingsPayload<ExtArgs>
        fields: Prisma.trainingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.trainingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.trainingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>
          }
          findFirst: {
            args: Prisma.trainingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.trainingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>
          }
          findMany: {
            args: Prisma.trainingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>[]
          }
          create: {
            args: Prisma.trainingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>
          }
          createMany: {
            args: Prisma.trainingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.trainingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>[]
          }
          delete: {
            args: Prisma.trainingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>
          }
          update: {
            args: Prisma.trainingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>
          }
          deleteMany: {
            args: Prisma.trainingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.trainingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.trainingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>[]
          }
          upsert: {
            args: Prisma.trainingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$trainingsPayload>
          }
          aggregate: {
            args: Prisma.TrainingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainings>
          }
          groupBy: {
            args: Prisma.trainingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.trainingsCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingsCountAggregateOutputType> | number
          }
        }
      }
      user_bootcamp_assignments: {
        payload: Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>
        fields: Prisma.user_bootcamp_assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_bootcamp_assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_bootcamp_assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>
          }
          findFirst: {
            args: Prisma.user_bootcamp_assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_bootcamp_assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>
          }
          findMany: {
            args: Prisma.user_bootcamp_assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>[]
          }
          create: {
            args: Prisma.user_bootcamp_assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>
          }
          createMany: {
            args: Prisma.user_bootcamp_assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_bootcamp_assignmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>[]
          }
          delete: {
            args: Prisma.user_bootcamp_assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>
          }
          update: {
            args: Prisma.user_bootcamp_assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.user_bootcamp_assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_bootcamp_assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_bootcamp_assignmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>[]
          }
          upsert: {
            args: Prisma.user_bootcamp_assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_bootcamp_assignmentsPayload>
          }
          aggregate: {
            args: Prisma.User_bootcamp_assignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_bootcamp_assignments>
          }
          groupBy: {
            args: Prisma.user_bootcamp_assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_bootcamp_assignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_bootcamp_assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<User_bootcamp_assignmentsCountAggregateOutputType> | number
          }
        }
      }
      user_quiz_attempts: {
        payload: Prisma.$user_quiz_attemptsPayload<ExtArgs>
        fields: Prisma.user_quiz_attemptsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_quiz_attemptsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_quiz_attemptsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>
          }
          findFirst: {
            args: Prisma.user_quiz_attemptsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_quiz_attemptsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>
          }
          findMany: {
            args: Prisma.user_quiz_attemptsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>[]
          }
          create: {
            args: Prisma.user_quiz_attemptsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>
          }
          createMany: {
            args: Prisma.user_quiz_attemptsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_quiz_attemptsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>[]
          }
          delete: {
            args: Prisma.user_quiz_attemptsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>
          }
          update: {
            args: Prisma.user_quiz_attemptsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>
          }
          deleteMany: {
            args: Prisma.user_quiz_attemptsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_quiz_attemptsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_quiz_attemptsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>[]
          }
          upsert: {
            args: Prisma.user_quiz_attemptsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_quiz_attemptsPayload>
          }
          aggregate: {
            args: Prisma.User_quiz_attemptsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_quiz_attempts>
          }
          groupBy: {
            args: Prisma.user_quiz_attemptsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_quiz_attemptsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_quiz_attemptsCountArgs<ExtArgs>
            result: $Utils.Optional<User_quiz_attemptsCountAggregateOutputType> | number
          }
        }
      }
      user_training_assignments: {
        payload: Prisma.$user_training_assignmentsPayload<ExtArgs>
        fields: Prisma.user_training_assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_training_assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_training_assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>
          }
          findFirst: {
            args: Prisma.user_training_assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_training_assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>
          }
          findMany: {
            args: Prisma.user_training_assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>[]
          }
          create: {
            args: Prisma.user_training_assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>
          }
          createMany: {
            args: Prisma.user_training_assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_training_assignmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>[]
          }
          delete: {
            args: Prisma.user_training_assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>
          }
          update: {
            args: Prisma.user_training_assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.user_training_assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_training_assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_training_assignmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>[]
          }
          upsert: {
            args: Prisma.user_training_assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_assignmentsPayload>
          }
          aggregate: {
            args: Prisma.User_training_assignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_training_assignments>
          }
          groupBy: {
            args: Prisma.user_training_assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_training_assignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_training_assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<User_training_assignmentsCountAggregateOutputType> | number
          }
        }
      }
      user_training_progress: {
        payload: Prisma.$user_training_progressPayload<ExtArgs>
        fields: Prisma.user_training_progressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_training_progressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_training_progressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>
          }
          findFirst: {
            args: Prisma.user_training_progressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_training_progressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>
          }
          findMany: {
            args: Prisma.user_training_progressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>[]
          }
          create: {
            args: Prisma.user_training_progressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>
          }
          createMany: {
            args: Prisma.user_training_progressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_training_progressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>[]
          }
          delete: {
            args: Prisma.user_training_progressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>
          }
          update: {
            args: Prisma.user_training_progressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>
          }
          deleteMany: {
            args: Prisma.user_training_progressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_training_progressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_training_progressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>[]
          }
          upsert: {
            args: Prisma.user_training_progressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_training_progressPayload>
          }
          aggregate: {
            args: Prisma.User_training_progressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_training_progress>
          }
          groupBy: {
            args: Prisma.user_training_progressGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_training_progressGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_training_progressCountArgs<ExtArgs>
            result: $Utils.Optional<User_training_progressCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    employee?: EmployeeOmit
    admin?: AdminOmit
    department?: DepartmentOmit
    log?: LogOmit
    admin_permission_logs?: admin_permission_logsOmit
    admin_permissions?: admin_permissionsOmit
    bootcamp_progress?: bootcamp_progressOmit
    bootcamp_trainings?: bootcamp_trainingsOmit
    bootcamps?: bootcampsOmit
    conference_attendees?: conference_attendeesOmit
    conference_materials?: conference_materialsOmit
    conference_trainings?: conference_trainingsOmit
    enrollments?: enrollmentsOmit
    questions?: questionsOmit
    quizzes?: quizzesOmit
    training_content?: training_contentOmit
    trainings?: trainingsOmit
    user_bootcamp_assignments?: user_bootcamp_assignmentsOmit
    user_quiz_attempts?: user_quiz_attemptsOmit
    user_training_assignments?: user_training_assignmentsOmit
    user_training_progress?: user_training_progressOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    admin_permission_logs_admin_permission_logs_modified_byTousers: number
    admin_permission_logs_admin_permission_logs_user_idTousers: number
    admin_permissions_admin_permissions_granted_byTousers: number
    admin_permissions_admin_permissions_user_idTousers: number
    admin: number
    bootcamp_progress: number
    conference_attendees: number
    employee: number
    enrollments: number
    logs: number
    user_bootcamp_assignments: number
    user_training_assignments: number
    user_training_progress: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_permission_logs_admin_permission_logs_modified_byTousers?: boolean | UserCountOutputTypeCountAdmin_permission_logs_admin_permission_logs_modified_byTousersArgs
    admin_permission_logs_admin_permission_logs_user_idTousers?: boolean | UserCountOutputTypeCountAdmin_permission_logs_admin_permission_logs_user_idTousersArgs
    admin_permissions_admin_permissions_granted_byTousers?: boolean | UserCountOutputTypeCountAdmin_permissions_admin_permissions_granted_byTousersArgs
    admin_permissions_admin_permissions_user_idTousers?: boolean | UserCountOutputTypeCountAdmin_permissions_admin_permissions_user_idTousersArgs
    admin?: boolean | UserCountOutputTypeCountAdminArgs
    bootcamp_progress?: boolean | UserCountOutputTypeCountBootcamp_progressArgs
    conference_attendees?: boolean | UserCountOutputTypeCountConference_attendeesArgs
    employee?: boolean | UserCountOutputTypeCountEmployeeArgs
    enrollments?: boolean | UserCountOutputTypeCountEnrollmentsArgs
    logs?: boolean | UserCountOutputTypeCountLogsArgs
    user_bootcamp_assignments?: boolean | UserCountOutputTypeCountUser_bootcamp_assignmentsArgs
    user_training_assignments?: boolean | UserCountOutputTypeCountUser_training_assignmentsArgs
    user_training_progress?: boolean | UserCountOutputTypeCountUser_training_progressArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdmin_permission_logs_admin_permission_logs_modified_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_permission_logsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdmin_permission_logs_admin_permission_logs_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_permission_logsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdmin_permissions_admin_permissions_granted_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_permissionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdmin_permissions_admin_permissions_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_permissionsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBootcamp_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bootcamp_progressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConference_attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conference_attendeesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_bootcamp_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_bootcamp_assignmentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_training_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_training_assignmentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_training_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_training_progressWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    employees: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | DepartmentCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type BootcampsCountOutputType
   */

  export type BootcampsCountOutputType = {
    bootcamp_progress: number
    bootcamp_trainings: number
    user_bootcamp_assignments: number
    user_training_progress: number
  }

  export type BootcampsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamp_progress?: boolean | BootcampsCountOutputTypeCountBootcamp_progressArgs
    bootcamp_trainings?: boolean | BootcampsCountOutputTypeCountBootcamp_trainingsArgs
    user_bootcamp_assignments?: boolean | BootcampsCountOutputTypeCountUser_bootcamp_assignmentsArgs
    user_training_progress?: boolean | BootcampsCountOutputTypeCountUser_training_progressArgs
  }

  // Custom InputTypes
  /**
   * BootcampsCountOutputType without action
   */
  export type BootcampsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BootcampsCountOutputType
     */
    select?: BootcampsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BootcampsCountOutputType without action
   */
  export type BootcampsCountOutputTypeCountBootcamp_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bootcamp_progressWhereInput
  }

  /**
   * BootcampsCountOutputType without action
   */
  export type BootcampsCountOutputTypeCountBootcamp_trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bootcamp_trainingsWhereInput
  }

  /**
   * BootcampsCountOutputType without action
   */
  export type BootcampsCountOutputTypeCountUser_bootcamp_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_bootcamp_assignmentsWhereInput
  }

  /**
   * BootcampsCountOutputType without action
   */
  export type BootcampsCountOutputTypeCountUser_training_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_training_progressWhereInput
  }


  /**
   * Count Type Conference_trainingsCountOutputType
   */

  export type Conference_trainingsCountOutputType = {
    conference_attendees: number
    conference_materials: number
  }

  export type Conference_trainingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference_attendees?: boolean | Conference_trainingsCountOutputTypeCountConference_attendeesArgs
    conference_materials?: boolean | Conference_trainingsCountOutputTypeCountConference_materialsArgs
  }

  // Custom InputTypes
  /**
   * Conference_trainingsCountOutputType without action
   */
  export type Conference_trainingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conference_trainingsCountOutputType
     */
    select?: Conference_trainingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Conference_trainingsCountOutputType without action
   */
  export type Conference_trainingsCountOutputTypeCountConference_attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conference_attendeesWhereInput
  }

  /**
   * Conference_trainingsCountOutputType without action
   */
  export type Conference_trainingsCountOutputTypeCountConference_materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conference_materialsWhereInput
  }


  /**
   * Count Type QuizzesCountOutputType
   */

  export type QuizzesCountOutputType = {
    questions: number
  }

  export type QuizzesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizzesCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * QuizzesCountOutputType without action
   */
  export type QuizzesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesCountOutputType
     */
    select?: QuizzesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizzesCountOutputType without action
   */
  export type QuizzesCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
  }


  /**
   * Count Type TrainingsCountOutputType
   */

  export type TrainingsCountOutputType = {
    bootcamp_trainings: number
    enrollments: number
    quizzes: number
    training_content: number
    user_training_assignments: number
    user_training_progress: number
  }

  export type TrainingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamp_trainings?: boolean | TrainingsCountOutputTypeCountBootcamp_trainingsArgs
    enrollments?: boolean | TrainingsCountOutputTypeCountEnrollmentsArgs
    quizzes?: boolean | TrainingsCountOutputTypeCountQuizzesArgs
    training_content?: boolean | TrainingsCountOutputTypeCountTraining_contentArgs
    user_training_assignments?: boolean | TrainingsCountOutputTypeCountUser_training_assignmentsArgs
    user_training_progress?: boolean | TrainingsCountOutputTypeCountUser_training_progressArgs
  }

  // Custom InputTypes
  /**
   * TrainingsCountOutputType without action
   */
  export type TrainingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingsCountOutputType
     */
    select?: TrainingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingsCountOutputType without action
   */
  export type TrainingsCountOutputTypeCountBootcamp_trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bootcamp_trainingsWhereInput
  }

  /**
   * TrainingsCountOutputType without action
   */
  export type TrainingsCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
  }

  /**
   * TrainingsCountOutputType without action
   */
  export type TrainingsCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizzesWhereInput
  }

  /**
   * TrainingsCountOutputType without action
   */
  export type TrainingsCountOutputTypeCountTraining_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: training_contentWhereInput
  }

  /**
   * TrainingsCountOutputType without action
   */
  export type TrainingsCountOutputTypeCountUser_training_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_training_assignmentsWhereInput
  }

  /**
   * TrainingsCountOutputType without action
   */
  export type TrainingsCountOutputTypeCountUser_training_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_training_progressWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.user_role | null
    loginType: $Enums.login_type | null
    microsoftId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.user_role | null
    loginType: $Enums.login_type | null
    microsoftId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    username: number
    firstName: number
    lastName: number
    role: number
    loginType: number
    microsoftId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    firstName?: true
    lastName?: true
    role?: true
    loginType?: true
    microsoftId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    firstName?: true
    lastName?: true
    role?: true
    loginType?: true
    microsoftId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    username?: true
    firstName?: true
    lastName?: true
    role?: true
    loginType?: true
    microsoftId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string | null
    username: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    loginType?: boolean
    microsoftId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin_permission_logs_admin_permission_logs_modified_byTousers?: boolean | User$admin_permission_logs_admin_permission_logs_modified_byTousersArgs<ExtArgs>
    admin_permission_logs_admin_permission_logs_user_idTousers?: boolean | User$admin_permission_logs_admin_permission_logs_user_idTousersArgs<ExtArgs>
    admin_permissions_admin_permissions_granted_byTousers?: boolean | User$admin_permissions_admin_permissions_granted_byTousersArgs<ExtArgs>
    admin_permissions_admin_permissions_user_idTousers?: boolean | User$admin_permissions_admin_permissions_user_idTousersArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    bootcamp_progress?: boolean | User$bootcamp_progressArgs<ExtArgs>
    conference_attendees?: boolean | User$conference_attendeesArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    user_bootcamp_assignments?: boolean | User$user_bootcamp_assignmentsArgs<ExtArgs>
    user_training_assignments?: boolean | User$user_training_assignmentsArgs<ExtArgs>
    user_training_progress?: boolean | User$user_training_progressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    loginType?: boolean
    microsoftId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    loginType?: boolean
    microsoftId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    loginType?: boolean
    microsoftId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "username" | "firstName" | "lastName" | "role" | "loginType" | "microsoftId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin_permission_logs_admin_permission_logs_modified_byTousers?: boolean | User$admin_permission_logs_admin_permission_logs_modified_byTousersArgs<ExtArgs>
    admin_permission_logs_admin_permission_logs_user_idTousers?: boolean | User$admin_permission_logs_admin_permission_logs_user_idTousersArgs<ExtArgs>
    admin_permissions_admin_permissions_granted_byTousers?: boolean | User$admin_permissions_admin_permissions_granted_byTousersArgs<ExtArgs>
    admin_permissions_admin_permissions_user_idTousers?: boolean | User$admin_permissions_admin_permissions_user_idTousersArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    bootcamp_progress?: boolean | User$bootcamp_progressArgs<ExtArgs>
    conference_attendees?: boolean | User$conference_attendeesArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    enrollments?: boolean | User$enrollmentsArgs<ExtArgs>
    logs?: boolean | User$logsArgs<ExtArgs>
    user_bootcamp_assignments?: boolean | User$user_bootcamp_assignmentsArgs<ExtArgs>
    user_training_assignments?: boolean | User$user_training_assignmentsArgs<ExtArgs>
    user_training_progress?: boolean | User$user_training_progressArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      admin_permission_logs_admin_permission_logs_modified_byTousers: Prisma.$admin_permission_logsPayload<ExtArgs>[]
      admin_permission_logs_admin_permission_logs_user_idTousers: Prisma.$admin_permission_logsPayload<ExtArgs>[]
      admin_permissions_admin_permissions_granted_byTousers: Prisma.$admin_permissionsPayload<ExtArgs>[]
      admin_permissions_admin_permissions_user_idTousers: Prisma.$admin_permissionsPayload<ExtArgs>[]
      admin: Prisma.$AdminPayload<ExtArgs>[]
      bootcamp_progress: Prisma.$bootcamp_progressPayload<ExtArgs>[]
      conference_attendees: Prisma.$conference_attendeesPayload<ExtArgs>[]
      employee: Prisma.$EmployeePayload<ExtArgs>[]
      enrollments: Prisma.$enrollmentsPayload<ExtArgs>[]
      logs: Prisma.$LogPayload<ExtArgs>[]
      user_bootcamp_assignments: Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>[]
      user_training_assignments: Prisma.$user_training_assignmentsPayload<ExtArgs>[]
      user_training_progress: Prisma.$user_training_progressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string | null
      username: string | null
      firstName: string
      lastName: string
      role: $Enums.user_role
      loginType: $Enums.login_type
      microsoftId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin_permission_logs_admin_permission_logs_modified_byTousers<T extends User$admin_permission_logs_admin_permission_logs_modified_byTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$admin_permission_logs_admin_permission_logs_modified_byTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin_permission_logs_admin_permission_logs_user_idTousers<T extends User$admin_permission_logs_admin_permission_logs_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$admin_permission_logs_admin_permission_logs_user_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin_permissions_admin_permissions_granted_byTousers<T extends User$admin_permissions_admin_permissions_granted_byTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$admin_permissions_admin_permissions_granted_byTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin_permissions_admin_permissions_user_idTousers<T extends User$admin_permissions_admin_permissions_user_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, User$admin_permissions_admin_permissions_user_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bootcamp_progress<T extends User$bootcamp_progressArgs<ExtArgs> = {}>(args?: Subset<T, User$bootcamp_progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conference_attendees<T extends User$conference_attendeesArgs<ExtArgs> = {}>(args?: Subset<T, User$conference_attendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends User$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends User$logsArgs<ExtArgs> = {}>(args?: Subset<T, User$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_bootcamp_assignments<T extends User$user_bootcamp_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$user_bootcamp_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_training_assignments<T extends User$user_training_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$user_training_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_training_progress<T extends User$user_training_progressArgs<ExtArgs> = {}>(args?: Subset<T, User$user_training_progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'user_role'>
    readonly loginType: FieldRef<"User", 'login_type'>
    readonly microsoftId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.admin_permission_logs_admin_permission_logs_modified_byTousers
   */
  export type User$admin_permission_logs_admin_permission_logs_modified_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    where?: admin_permission_logsWhereInput
    orderBy?: admin_permission_logsOrderByWithRelationInput | admin_permission_logsOrderByWithRelationInput[]
    cursor?: admin_permission_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Admin_permission_logsScalarFieldEnum | Admin_permission_logsScalarFieldEnum[]
  }

  /**
   * User.admin_permission_logs_admin_permission_logs_user_idTousers
   */
  export type User$admin_permission_logs_admin_permission_logs_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    where?: admin_permission_logsWhereInput
    orderBy?: admin_permission_logsOrderByWithRelationInput | admin_permission_logsOrderByWithRelationInput[]
    cursor?: admin_permission_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Admin_permission_logsScalarFieldEnum | Admin_permission_logsScalarFieldEnum[]
  }

  /**
   * User.admin_permissions_admin_permissions_granted_byTousers
   */
  export type User$admin_permissions_admin_permissions_granted_byTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    where?: admin_permissionsWhereInput
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    cursor?: admin_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Admin_permissionsScalarFieldEnum | Admin_permissionsScalarFieldEnum[]
  }

  /**
   * User.admin_permissions_admin_permissions_user_idTousers
   */
  export type User$admin_permissions_admin_permissions_user_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    where?: admin_permissionsWhereInput
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    cursor?: admin_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Admin_permissionsScalarFieldEnum | Admin_permissionsScalarFieldEnum[]
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * User.bootcamp_progress
   */
  export type User$bootcamp_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    where?: bootcamp_progressWhereInput
    orderBy?: bootcamp_progressOrderByWithRelationInput | bootcamp_progressOrderByWithRelationInput[]
    cursor?: bootcamp_progressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bootcamp_progressScalarFieldEnum | Bootcamp_progressScalarFieldEnum[]
  }

  /**
   * User.conference_attendees
   */
  export type User$conference_attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    where?: conference_attendeesWhereInput
    orderBy?: conference_attendeesOrderByWithRelationInput | conference_attendeesOrderByWithRelationInput[]
    cursor?: conference_attendeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Conference_attendeesScalarFieldEnum | Conference_attendeesScalarFieldEnum[]
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * User.enrollments
   */
  export type User$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    cursor?: enrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * User.logs
   */
  export type User$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    where?: LogWhereInput
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    cursor?: LogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * User.user_bootcamp_assignments
   */
  export type User$user_bootcamp_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    where?: user_bootcamp_assignmentsWhereInput
    orderBy?: user_bootcamp_assignmentsOrderByWithRelationInput | user_bootcamp_assignmentsOrderByWithRelationInput[]
    cursor?: user_bootcamp_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_bootcamp_assignmentsScalarFieldEnum | User_bootcamp_assignmentsScalarFieldEnum[]
  }

  /**
   * User.user_training_assignments
   */
  export type User$user_training_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    where?: user_training_assignmentsWhereInput
    orderBy?: user_training_assignmentsOrderByWithRelationInput | user_training_assignmentsOrderByWithRelationInput[]
    cursor?: user_training_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_training_assignmentsScalarFieldEnum | User_training_assignmentsScalarFieldEnum[]
  }

  /**
   * User.user_training_progress
   */
  export type User$user_training_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    where?: user_training_progressWhereInput
    orderBy?: user_training_progressOrderByWithRelationInput | user_training_progressOrderByWithRelationInput[]
    cursor?: user_training_progressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_training_progressScalarFieldEnum | User_training_progressScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    departmentId: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    departmentId: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    telesetCardNo: string | null
    userId: number | null
    departmentId: number | null
    position: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    telesetCardNo: string | null
    userId: number | null
    departmentId: number | null
    position: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    telesetCardNo: number
    userId: number
    departmentId: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    userId?: true
    departmentId?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    userId?: true
    departmentId?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    telesetCardNo?: true
    userId?: true
    departmentId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    telesetCardNo?: true
    userId?: true
    departmentId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    telesetCardNo?: true
    userId?: true
    departmentId?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    telesetCardNo: string | null
    userId: number
    departmentId: number | null
    position: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telesetCardNo?: boolean
    userId?: boolean
    departmentId?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telesetCardNo?: boolean
    userId?: boolean
    departmentId?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telesetCardNo?: boolean
    userId?: boolean
    departmentId?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    telesetCardNo?: boolean
    userId?: boolean
    departmentId?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "telesetCardNo" | "userId" | "departmentId" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telesetCardNo: string | null
      userId: number
      departmentId: number | null
      position: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Employee$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly telesetCardNo: FieldRef<"Employee", 'String'>
    readonly userId: FieldRef<"Employee", 'Int'>
    readonly departmentId: FieldRef<"Employee", 'Int'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.department
   */
  export type Employee$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    adminLevel: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    adminLevel: string | null
    userId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    adminLevel: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    adminLevel?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    adminLevel?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    adminLevel?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    adminLevel: string
    userId: number
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminLevel?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminLevel?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminLevel?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    adminLevel?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminLevel" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      adminLevel: string
      userId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly adminLevel: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'Int'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | Department$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Department$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Department$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Department$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.employees
   */
  export type Department$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type LogSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type LogMinAggregateOutputType = {
    id: number | null
    action_type: string | null
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
    is_suspicious: boolean | null
  }

  export type LogMaxAggregateOutputType = {
    id: number | null
    action_type: string | null
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date | null
    is_suspicious: boolean | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    action_type: number
    user_id: number
    ip_address: number
    user_agent: number
    created_at: number
    details: number
    is_suspicious: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type LogSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type LogMinAggregateInputType = {
    id?: true
    action_type?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    is_suspicious?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    action_type?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    is_suspicious?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    action_type?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    created_at?: true
    details?: true
    is_suspicious?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    id: number
    action_type: string
    user_id: number | null
    ip_address: string | null
    user_agent: string | null
    created_at: Date
    details: JsonValue | null
    is_suspicious: boolean | null
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action_type?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    details?: boolean
    is_suspicious?: boolean
    users?: boolean | Log$usersArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action_type?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    details?: boolean
    is_suspicious?: boolean
    users?: boolean | Log$usersArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action_type?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    details?: boolean
    is_suspicious?: boolean
    users?: boolean | Log$usersArgs<ExtArgs>
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    id?: boolean
    action_type?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    created_at?: boolean
    details?: boolean
    is_suspicious?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action_type" | "user_id" | "ip_address" | "user_agent" | "created_at" | "details" | "is_suspicious", ExtArgs["result"]["log"]>
  export type LogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Log$usersArgs<ExtArgs>
  }
  export type LogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Log$usersArgs<ExtArgs>
  }
  export type LogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Log$usersArgs<ExtArgs>
  }

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {
      users: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      action_type: string
      user_id: number | null
      ip_address: string | null
      user_agent: string | null
      created_at: Date
      details: Prisma.JsonValue | null
      is_suspicious: boolean | null
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logWithIdOnly = await prisma.log.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogUpdateManyAndReturnArgs>(args: SelectSubset<T, LogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Log$usersArgs<ExtArgs> = {}>(args?: Subset<T, Log$usersArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly id: FieldRef<"Log", 'Int'>
    readonly action_type: FieldRef<"Log", 'String'>
    readonly user_id: FieldRef<"Log", 'Int'>
    readonly ip_address: FieldRef<"Log", 'String'>
    readonly user_agent: FieldRef<"Log", 'String'>
    readonly created_at: FieldRef<"Log", 'DateTime'>
    readonly details: FieldRef<"Log", 'Json'>
    readonly is_suspicious: FieldRef<"Log", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log updateManyAndReturn
   */
  export type LogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log.users
   */
  export type Log$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogInclude<ExtArgs> | null
  }


  /**
   * Model admin_permission_logs
   */

  export type AggregateAdmin_permission_logs = {
    _count: Admin_permission_logsCountAggregateOutputType | null
    _avg: Admin_permission_logsAvgAggregateOutputType | null
    _sum: Admin_permission_logsSumAggregateOutputType | null
    _min: Admin_permission_logsMinAggregateOutputType | null
    _max: Admin_permission_logsMaxAggregateOutputType | null
  }

  export type Admin_permission_logsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    modified_by: number | null
  }

  export type Admin_permission_logsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    modified_by: number | null
  }

  export type Admin_permission_logsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    modified_by: number | null
    action: string | null
    previous_role: string | null
    new_role: string | null
    action_date: Date | null
    notes: string | null
  }

  export type Admin_permission_logsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    modified_by: number | null
    action: string | null
    previous_role: string | null
    new_role: string | null
    action_date: Date | null
    notes: string | null
  }

  export type Admin_permission_logsCountAggregateOutputType = {
    id: number
    user_id: number
    modified_by: number
    action: number
    previous_role: number
    new_role: number
    action_date: number
    notes: number
    _all: number
  }


  export type Admin_permission_logsAvgAggregateInputType = {
    id?: true
    user_id?: true
    modified_by?: true
  }

  export type Admin_permission_logsSumAggregateInputType = {
    id?: true
    user_id?: true
    modified_by?: true
  }

  export type Admin_permission_logsMinAggregateInputType = {
    id?: true
    user_id?: true
    modified_by?: true
    action?: true
    previous_role?: true
    new_role?: true
    action_date?: true
    notes?: true
  }

  export type Admin_permission_logsMaxAggregateInputType = {
    id?: true
    user_id?: true
    modified_by?: true
    action?: true
    previous_role?: true
    new_role?: true
    action_date?: true
    notes?: true
  }

  export type Admin_permission_logsCountAggregateInputType = {
    id?: true
    user_id?: true
    modified_by?: true
    action?: true
    previous_role?: true
    new_role?: true
    action_date?: true
    notes?: true
    _all?: true
  }

  export type Admin_permission_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_permission_logs to aggregate.
     */
    where?: admin_permission_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permission_logs to fetch.
     */
    orderBy?: admin_permission_logsOrderByWithRelationInput | admin_permission_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_permission_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permission_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permission_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_permission_logs
    **/
    _count?: true | Admin_permission_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_permission_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_permission_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_permission_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_permission_logsMaxAggregateInputType
  }

  export type GetAdmin_permission_logsAggregateType<T extends Admin_permission_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_permission_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_permission_logs[P]>
      : GetScalarType<T[P], AggregateAdmin_permission_logs[P]>
  }




  export type admin_permission_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_permission_logsWhereInput
    orderBy?: admin_permission_logsOrderByWithAggregationInput | admin_permission_logsOrderByWithAggregationInput[]
    by: Admin_permission_logsScalarFieldEnum[] | Admin_permission_logsScalarFieldEnum
    having?: admin_permission_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_permission_logsCountAggregateInputType | true
    _avg?: Admin_permission_logsAvgAggregateInputType
    _sum?: Admin_permission_logsSumAggregateInputType
    _min?: Admin_permission_logsMinAggregateInputType
    _max?: Admin_permission_logsMaxAggregateInputType
  }

  export type Admin_permission_logsGroupByOutputType = {
    id: number
    user_id: number
    modified_by: number
    action: string
    previous_role: string | null
    new_role: string | null
    action_date: Date
    notes: string | null
    _count: Admin_permission_logsCountAggregateOutputType | null
    _avg: Admin_permission_logsAvgAggregateOutputType | null
    _sum: Admin_permission_logsSumAggregateOutputType | null
    _min: Admin_permission_logsMinAggregateOutputType | null
    _max: Admin_permission_logsMaxAggregateOutputType | null
  }

  type GetAdmin_permission_logsGroupByPayload<T extends admin_permission_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_permission_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_permission_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_permission_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_permission_logsGroupByOutputType[P]>
        }
      >
    >


  export type admin_permission_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    modified_by?: boolean
    action?: boolean
    previous_role?: boolean
    new_role?: boolean
    action_date?: boolean
    notes?: boolean
    users_admin_permission_logs_modified_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permission_logs_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_permission_logs"]>

  export type admin_permission_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    modified_by?: boolean
    action?: boolean
    previous_role?: boolean
    new_role?: boolean
    action_date?: boolean
    notes?: boolean
    users_admin_permission_logs_modified_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permission_logs_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_permission_logs"]>

  export type admin_permission_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    modified_by?: boolean
    action?: boolean
    previous_role?: boolean
    new_role?: boolean
    action_date?: boolean
    notes?: boolean
    users_admin_permission_logs_modified_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permission_logs_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_permission_logs"]>

  export type admin_permission_logsSelectScalar = {
    id?: boolean
    user_id?: boolean
    modified_by?: boolean
    action?: boolean
    previous_role?: boolean
    new_role?: boolean
    action_date?: boolean
    notes?: boolean
  }

  export type admin_permission_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "modified_by" | "action" | "previous_role" | "new_role" | "action_date" | "notes", ExtArgs["result"]["admin_permission_logs"]>
  export type admin_permission_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_admin_permission_logs_modified_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permission_logs_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type admin_permission_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_admin_permission_logs_modified_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permission_logs_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type admin_permission_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_admin_permission_logs_modified_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permission_logs_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $admin_permission_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_permission_logs"
    objects: {
      users_admin_permission_logs_modified_byTousers: Prisma.$UserPayload<ExtArgs>
      users_admin_permission_logs_user_idTousers: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      modified_by: number
      action: string
      previous_role: string | null
      new_role: string | null
      action_date: Date
      notes: string | null
    }, ExtArgs["result"]["admin_permission_logs"]>
    composites: {}
  }

  type admin_permission_logsGetPayload<S extends boolean | null | undefined | admin_permission_logsDefaultArgs> = $Result.GetResult<Prisma.$admin_permission_logsPayload, S>

  type admin_permission_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admin_permission_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Admin_permission_logsCountAggregateInputType | true
    }

  export interface admin_permission_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_permission_logs'], meta: { name: 'admin_permission_logs' } }
    /**
     * Find zero or one Admin_permission_logs that matches the filter.
     * @param {admin_permission_logsFindUniqueArgs} args - Arguments to find a Admin_permission_logs
     * @example
     * // Get one Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_permission_logsFindUniqueArgs>(args: SelectSubset<T, admin_permission_logsFindUniqueArgs<ExtArgs>>): Prisma__admin_permission_logsClient<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin_permission_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admin_permission_logsFindUniqueOrThrowArgs} args - Arguments to find a Admin_permission_logs
     * @example
     * // Get one Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_permission_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_permission_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_permission_logsClient<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_permission_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permission_logsFindFirstArgs} args - Arguments to find a Admin_permission_logs
     * @example
     * // Get one Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_permission_logsFindFirstArgs>(args?: SelectSubset<T, admin_permission_logsFindFirstArgs<ExtArgs>>): Prisma__admin_permission_logsClient<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_permission_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permission_logsFindFirstOrThrowArgs} args - Arguments to find a Admin_permission_logs
     * @example
     * // Get one Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_permission_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_permission_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_permission_logsClient<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admin_permission_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permission_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.findMany()
     * 
     * // Get first 10 Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_permission_logsWithIdOnly = await prisma.admin_permission_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_permission_logsFindManyArgs>(args?: SelectSubset<T, admin_permission_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin_permission_logs.
     * @param {admin_permission_logsCreateArgs} args - Arguments to create a Admin_permission_logs.
     * @example
     * // Create one Admin_permission_logs
     * const Admin_permission_logs = await prisma.admin_permission_logs.create({
     *   data: {
     *     // ... data to create a Admin_permission_logs
     *   }
     * })
     * 
     */
    create<T extends admin_permission_logsCreateArgs>(args: SelectSubset<T, admin_permission_logsCreateArgs<ExtArgs>>): Prisma__admin_permission_logsClient<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admin_permission_logs.
     * @param {admin_permission_logsCreateManyArgs} args - Arguments to create many Admin_permission_logs.
     * @example
     * // Create many Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_permission_logsCreateManyArgs>(args?: SelectSubset<T, admin_permission_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admin_permission_logs and returns the data saved in the database.
     * @param {admin_permission_logsCreateManyAndReturnArgs} args - Arguments to create many Admin_permission_logs.
     * @example
     * // Create many Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admin_permission_logs and only return the `id`
     * const admin_permission_logsWithIdOnly = await prisma.admin_permission_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends admin_permission_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, admin_permission_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin_permission_logs.
     * @param {admin_permission_logsDeleteArgs} args - Arguments to delete one Admin_permission_logs.
     * @example
     * // Delete one Admin_permission_logs
     * const Admin_permission_logs = await prisma.admin_permission_logs.delete({
     *   where: {
     *     // ... filter to delete one Admin_permission_logs
     *   }
     * })
     * 
     */
    delete<T extends admin_permission_logsDeleteArgs>(args: SelectSubset<T, admin_permission_logsDeleteArgs<ExtArgs>>): Prisma__admin_permission_logsClient<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin_permission_logs.
     * @param {admin_permission_logsUpdateArgs} args - Arguments to update one Admin_permission_logs.
     * @example
     * // Update one Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_permission_logsUpdateArgs>(args: SelectSubset<T, admin_permission_logsUpdateArgs<ExtArgs>>): Prisma__admin_permission_logsClient<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admin_permission_logs.
     * @param {admin_permission_logsDeleteManyArgs} args - Arguments to filter Admin_permission_logs to delete.
     * @example
     * // Delete a few Admin_permission_logs
     * const { count } = await prisma.admin_permission_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_permission_logsDeleteManyArgs>(args?: SelectSubset<T, admin_permission_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_permission_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permission_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_permission_logsUpdateManyArgs>(args: SelectSubset<T, admin_permission_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_permission_logs and returns the data updated in the database.
     * @param {admin_permission_logsUpdateManyAndReturnArgs} args - Arguments to update many Admin_permission_logs.
     * @example
     * // Update many Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admin_permission_logs and only return the `id`
     * const admin_permission_logsWithIdOnly = await prisma.admin_permission_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends admin_permission_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, admin_permission_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin_permission_logs.
     * @param {admin_permission_logsUpsertArgs} args - Arguments to update or create a Admin_permission_logs.
     * @example
     * // Update or create a Admin_permission_logs
     * const admin_permission_logs = await prisma.admin_permission_logs.upsert({
     *   create: {
     *     // ... data to create a Admin_permission_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_permission_logs we want to update
     *   }
     * })
     */
    upsert<T extends admin_permission_logsUpsertArgs>(args: SelectSubset<T, admin_permission_logsUpsertArgs<ExtArgs>>): Prisma__admin_permission_logsClient<$Result.GetResult<Prisma.$admin_permission_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admin_permission_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permission_logsCountArgs} args - Arguments to filter Admin_permission_logs to count.
     * @example
     * // Count the number of Admin_permission_logs
     * const count = await prisma.admin_permission_logs.count({
     *   where: {
     *     // ... the filter for the Admin_permission_logs we want to count
     *   }
     * })
    **/
    count<T extends admin_permission_logsCountArgs>(
      args?: Subset<T, admin_permission_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_permission_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_permission_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_permission_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_permission_logsAggregateArgs>(args: Subset<T, Admin_permission_logsAggregateArgs>): Prisma.PrismaPromise<GetAdmin_permission_logsAggregateType<T>>

    /**
     * Group by Admin_permission_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permission_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_permission_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_permission_logsGroupByArgs['orderBy'] }
        : { orderBy?: admin_permission_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_permission_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_permission_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_permission_logs model
   */
  readonly fields: admin_permission_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_permission_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_permission_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_admin_permission_logs_modified_byTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_admin_permission_logs_user_idTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_permission_logs model
   */
  interface admin_permission_logsFieldRefs {
    readonly id: FieldRef<"admin_permission_logs", 'Int'>
    readonly user_id: FieldRef<"admin_permission_logs", 'Int'>
    readonly modified_by: FieldRef<"admin_permission_logs", 'Int'>
    readonly action: FieldRef<"admin_permission_logs", 'String'>
    readonly previous_role: FieldRef<"admin_permission_logs", 'String'>
    readonly new_role: FieldRef<"admin_permission_logs", 'String'>
    readonly action_date: FieldRef<"admin_permission_logs", 'DateTime'>
    readonly notes: FieldRef<"admin_permission_logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * admin_permission_logs findUnique
   */
  export type admin_permission_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permission_logs to fetch.
     */
    where: admin_permission_logsWhereUniqueInput
  }

  /**
   * admin_permission_logs findUniqueOrThrow
   */
  export type admin_permission_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permission_logs to fetch.
     */
    where: admin_permission_logsWhereUniqueInput
  }

  /**
   * admin_permission_logs findFirst
   */
  export type admin_permission_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permission_logs to fetch.
     */
    where?: admin_permission_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permission_logs to fetch.
     */
    orderBy?: admin_permission_logsOrderByWithRelationInput | admin_permission_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_permission_logs.
     */
    cursor?: admin_permission_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permission_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permission_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_permission_logs.
     */
    distinct?: Admin_permission_logsScalarFieldEnum | Admin_permission_logsScalarFieldEnum[]
  }

  /**
   * admin_permission_logs findFirstOrThrow
   */
  export type admin_permission_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permission_logs to fetch.
     */
    where?: admin_permission_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permission_logs to fetch.
     */
    orderBy?: admin_permission_logsOrderByWithRelationInput | admin_permission_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_permission_logs.
     */
    cursor?: admin_permission_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permission_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permission_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_permission_logs.
     */
    distinct?: Admin_permission_logsScalarFieldEnum | Admin_permission_logsScalarFieldEnum[]
  }

  /**
   * admin_permission_logs findMany
   */
  export type admin_permission_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permission_logs to fetch.
     */
    where?: admin_permission_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permission_logs to fetch.
     */
    orderBy?: admin_permission_logsOrderByWithRelationInput | admin_permission_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_permission_logs.
     */
    cursor?: admin_permission_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permission_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permission_logs.
     */
    skip?: number
    distinct?: Admin_permission_logsScalarFieldEnum | Admin_permission_logsScalarFieldEnum[]
  }

  /**
   * admin_permission_logs create
   */
  export type admin_permission_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a admin_permission_logs.
     */
    data: XOR<admin_permission_logsCreateInput, admin_permission_logsUncheckedCreateInput>
  }

  /**
   * admin_permission_logs createMany
   */
  export type admin_permission_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_permission_logs.
     */
    data: admin_permission_logsCreateManyInput | admin_permission_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_permission_logs createManyAndReturn
   */
  export type admin_permission_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * The data used to create many admin_permission_logs.
     */
    data: admin_permission_logsCreateManyInput | admin_permission_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_permission_logs update
   */
  export type admin_permission_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a admin_permission_logs.
     */
    data: XOR<admin_permission_logsUpdateInput, admin_permission_logsUncheckedUpdateInput>
    /**
     * Choose, which admin_permission_logs to update.
     */
    where: admin_permission_logsWhereUniqueInput
  }

  /**
   * admin_permission_logs updateMany
   */
  export type admin_permission_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_permission_logs.
     */
    data: XOR<admin_permission_logsUpdateManyMutationInput, admin_permission_logsUncheckedUpdateManyInput>
    /**
     * Filter which admin_permission_logs to update
     */
    where?: admin_permission_logsWhereInput
    /**
     * Limit how many admin_permission_logs to update.
     */
    limit?: number
  }

  /**
   * admin_permission_logs updateManyAndReturn
   */
  export type admin_permission_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * The data used to update admin_permission_logs.
     */
    data: XOR<admin_permission_logsUpdateManyMutationInput, admin_permission_logsUncheckedUpdateManyInput>
    /**
     * Filter which admin_permission_logs to update
     */
    where?: admin_permission_logsWhereInput
    /**
     * Limit how many admin_permission_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_permission_logs upsert
   */
  export type admin_permission_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the admin_permission_logs to update in case it exists.
     */
    where: admin_permission_logsWhereUniqueInput
    /**
     * In case the admin_permission_logs found by the `where` argument doesn't exist, create a new admin_permission_logs with this data.
     */
    create: XOR<admin_permission_logsCreateInput, admin_permission_logsUncheckedCreateInput>
    /**
     * In case the admin_permission_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_permission_logsUpdateInput, admin_permission_logsUncheckedUpdateInput>
  }

  /**
   * admin_permission_logs delete
   */
  export type admin_permission_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
    /**
     * Filter which admin_permission_logs to delete.
     */
    where: admin_permission_logsWhereUniqueInput
  }

  /**
   * admin_permission_logs deleteMany
   */
  export type admin_permission_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_permission_logs to delete
     */
    where?: admin_permission_logsWhereInput
    /**
     * Limit how many admin_permission_logs to delete.
     */
    limit?: number
  }

  /**
   * admin_permission_logs without action
   */
  export type admin_permission_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permission_logs
     */
    select?: admin_permission_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permission_logs
     */
    omit?: admin_permission_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permission_logsInclude<ExtArgs> | null
  }


  /**
   * Model admin_permissions
   */

  export type AggregateAdmin_permissions = {
    _count: Admin_permissionsCountAggregateOutputType | null
    _avg: Admin_permissionsAvgAggregateOutputType | null
    _sum: Admin_permissionsSumAggregateOutputType | null
    _min: Admin_permissionsMinAggregateOutputType | null
    _max: Admin_permissionsMaxAggregateOutputType | null
  }

  export type Admin_permissionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    granted_by: number | null
  }

  export type Admin_permissionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    granted_by: number | null
  }

  export type Admin_permissionsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    granted_by: number | null
    permission_level: string | null
    granted_at: Date | null
    revoked_at: Date | null
    is_active: boolean | null
  }

  export type Admin_permissionsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    granted_by: number | null
    permission_level: string | null
    granted_at: Date | null
    revoked_at: Date | null
    is_active: boolean | null
  }

  export type Admin_permissionsCountAggregateOutputType = {
    id: number
    user_id: number
    granted_by: number
    permission_level: number
    granted_at: number
    revoked_at: number
    is_active: number
    _all: number
  }


  export type Admin_permissionsAvgAggregateInputType = {
    id?: true
    user_id?: true
    granted_by?: true
  }

  export type Admin_permissionsSumAggregateInputType = {
    id?: true
    user_id?: true
    granted_by?: true
  }

  export type Admin_permissionsMinAggregateInputType = {
    id?: true
    user_id?: true
    granted_by?: true
    permission_level?: true
    granted_at?: true
    revoked_at?: true
    is_active?: true
  }

  export type Admin_permissionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    granted_by?: true
    permission_level?: true
    granted_at?: true
    revoked_at?: true
    is_active?: true
  }

  export type Admin_permissionsCountAggregateInputType = {
    id?: true
    user_id?: true
    granted_by?: true
    permission_level?: true
    granted_at?: true
    revoked_at?: true
    is_active?: true
    _all?: true
  }

  export type Admin_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_permissions to aggregate.
     */
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     */
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned admin_permissions
    **/
    _count?: true | Admin_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Admin_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Admin_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Admin_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Admin_permissionsMaxAggregateInputType
  }

  export type GetAdmin_permissionsAggregateType<T extends Admin_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin_permissions[P]>
      : GetScalarType<T[P], AggregateAdmin_permissions[P]>
  }




  export type admin_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: admin_permissionsWhereInput
    orderBy?: admin_permissionsOrderByWithAggregationInput | admin_permissionsOrderByWithAggregationInput[]
    by: Admin_permissionsScalarFieldEnum[] | Admin_permissionsScalarFieldEnum
    having?: admin_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Admin_permissionsCountAggregateInputType | true
    _avg?: Admin_permissionsAvgAggregateInputType
    _sum?: Admin_permissionsSumAggregateInputType
    _min?: Admin_permissionsMinAggregateInputType
    _max?: Admin_permissionsMaxAggregateInputType
  }

  export type Admin_permissionsGroupByOutputType = {
    id: number
    user_id: number
    granted_by: number
    permission_level: string
    granted_at: Date
    revoked_at: Date | null
    is_active: boolean
    _count: Admin_permissionsCountAggregateOutputType | null
    _avg: Admin_permissionsAvgAggregateOutputType | null
    _sum: Admin_permissionsSumAggregateOutputType | null
    _min: Admin_permissionsMinAggregateOutputType | null
    _max: Admin_permissionsMaxAggregateOutputType | null
  }

  type GetAdmin_permissionsGroupByPayload<T extends admin_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Admin_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Admin_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Admin_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Admin_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type admin_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    granted_by?: boolean
    permission_level?: boolean
    granted_at?: boolean
    revoked_at?: boolean
    is_active?: boolean
    users_admin_permissions_granted_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permissions_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_permissions"]>

  export type admin_permissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    granted_by?: boolean
    permission_level?: boolean
    granted_at?: boolean
    revoked_at?: boolean
    is_active?: boolean
    users_admin_permissions_granted_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permissions_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_permissions"]>

  export type admin_permissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    granted_by?: boolean
    permission_level?: boolean
    granted_at?: boolean
    revoked_at?: boolean
    is_active?: boolean
    users_admin_permissions_granted_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permissions_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin_permissions"]>

  export type admin_permissionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    granted_by?: boolean
    permission_level?: boolean
    granted_at?: boolean
    revoked_at?: boolean
    is_active?: boolean
  }

  export type admin_permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "granted_by" | "permission_level" | "granted_at" | "revoked_at" | "is_active", ExtArgs["result"]["admin_permissions"]>
  export type admin_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_admin_permissions_granted_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permissions_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type admin_permissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_admin_permissions_granted_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permissions_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type admin_permissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_admin_permissions_granted_byTousers?: boolean | UserDefaultArgs<ExtArgs>
    users_admin_permissions_user_idTousers?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $admin_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "admin_permissions"
    objects: {
      users_admin_permissions_granted_byTousers: Prisma.$UserPayload<ExtArgs>
      users_admin_permissions_user_idTousers: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      granted_by: number
      permission_level: string
      granted_at: Date
      revoked_at: Date | null
      is_active: boolean
    }, ExtArgs["result"]["admin_permissions"]>
    composites: {}
  }

  type admin_permissionsGetPayload<S extends boolean | null | undefined | admin_permissionsDefaultArgs> = $Result.GetResult<Prisma.$admin_permissionsPayload, S>

  type admin_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<admin_permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Admin_permissionsCountAggregateInputType | true
    }

  export interface admin_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['admin_permissions'], meta: { name: 'admin_permissions' } }
    /**
     * Find zero or one Admin_permissions that matches the filter.
     * @param {admin_permissionsFindUniqueArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends admin_permissionsFindUniqueArgs>(args: SelectSubset<T, admin_permissionsFindUniqueArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin_permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {admin_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends admin_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, admin_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindFirstArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends admin_permissionsFindFirstArgs>(args?: SelectSubset<T, admin_permissionsFindFirstArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindFirstOrThrowArgs} args - Arguments to find a Admin_permissions
     * @example
     * // Get one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends admin_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, admin_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admin_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findMany()
     * 
     * // Get first 10 Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admin_permissionsWithIdOnly = await prisma.admin_permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends admin_permissionsFindManyArgs>(args?: SelectSubset<T, admin_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin_permissions.
     * @param {admin_permissionsCreateArgs} args - Arguments to create a Admin_permissions.
     * @example
     * // Create one Admin_permissions
     * const Admin_permissions = await prisma.admin_permissions.create({
     *   data: {
     *     // ... data to create a Admin_permissions
     *   }
     * })
     * 
     */
    create<T extends admin_permissionsCreateArgs>(args: SelectSubset<T, admin_permissionsCreateArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admin_permissions.
     * @param {admin_permissionsCreateManyArgs} args - Arguments to create many Admin_permissions.
     * @example
     * // Create many Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends admin_permissionsCreateManyArgs>(args?: SelectSubset<T, admin_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admin_permissions and returns the data saved in the database.
     * @param {admin_permissionsCreateManyAndReturnArgs} args - Arguments to create many Admin_permissions.
     * @example
     * // Create many Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admin_permissions and only return the `id`
     * const admin_permissionsWithIdOnly = await prisma.admin_permissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends admin_permissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, admin_permissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin_permissions.
     * @param {admin_permissionsDeleteArgs} args - Arguments to delete one Admin_permissions.
     * @example
     * // Delete one Admin_permissions
     * const Admin_permissions = await prisma.admin_permissions.delete({
     *   where: {
     *     // ... filter to delete one Admin_permissions
     *   }
     * })
     * 
     */
    delete<T extends admin_permissionsDeleteArgs>(args: SelectSubset<T, admin_permissionsDeleteArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin_permissions.
     * @param {admin_permissionsUpdateArgs} args - Arguments to update one Admin_permissions.
     * @example
     * // Update one Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends admin_permissionsUpdateArgs>(args: SelectSubset<T, admin_permissionsUpdateArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admin_permissions.
     * @param {admin_permissionsDeleteManyArgs} args - Arguments to filter Admin_permissions to delete.
     * @example
     * // Delete a few Admin_permissions
     * const { count } = await prisma.admin_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends admin_permissionsDeleteManyArgs>(args?: SelectSubset<T, admin_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends admin_permissionsUpdateManyArgs>(args: SelectSubset<T, admin_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admin_permissions and returns the data updated in the database.
     * @param {admin_permissionsUpdateManyAndReturnArgs} args - Arguments to update many Admin_permissions.
     * @example
     * // Update many Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admin_permissions and only return the `id`
     * const admin_permissionsWithIdOnly = await prisma.admin_permissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends admin_permissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, admin_permissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin_permissions.
     * @param {admin_permissionsUpsertArgs} args - Arguments to update or create a Admin_permissions.
     * @example
     * // Update or create a Admin_permissions
     * const admin_permissions = await prisma.admin_permissions.upsert({
     *   create: {
     *     // ... data to create a Admin_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin_permissions we want to update
     *   }
     * })
     */
    upsert<T extends admin_permissionsUpsertArgs>(args: SelectSubset<T, admin_permissionsUpsertArgs<ExtArgs>>): Prisma__admin_permissionsClient<$Result.GetResult<Prisma.$admin_permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsCountArgs} args - Arguments to filter Admin_permissions to count.
     * @example
     * // Count the number of Admin_permissions
     * const count = await prisma.admin_permissions.count({
     *   where: {
     *     // ... the filter for the Admin_permissions we want to count
     *   }
     * })
    **/
    count<T extends admin_permissionsCountArgs>(
      args?: Subset<T, admin_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Admin_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Admin_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Admin_permissionsAggregateArgs>(args: Subset<T, Admin_permissionsAggregateArgs>): Prisma.PrismaPromise<GetAdmin_permissionsAggregateType<T>>

    /**
     * Group by Admin_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {admin_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends admin_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: admin_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: admin_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, admin_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmin_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the admin_permissions model
   */
  readonly fields: admin_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for admin_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__admin_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_admin_permissions_granted_byTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users_admin_permissions_user_idTousers<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the admin_permissions model
   */
  interface admin_permissionsFieldRefs {
    readonly id: FieldRef<"admin_permissions", 'Int'>
    readonly user_id: FieldRef<"admin_permissions", 'Int'>
    readonly granted_by: FieldRef<"admin_permissions", 'Int'>
    readonly permission_level: FieldRef<"admin_permissions", 'String'>
    readonly granted_at: FieldRef<"admin_permissions", 'DateTime'>
    readonly revoked_at: FieldRef<"admin_permissions", 'DateTime'>
    readonly is_active: FieldRef<"admin_permissions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * admin_permissions findUnique
   */
  export type admin_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions findUniqueOrThrow
   */
  export type admin_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions findFirst
   */
  export type admin_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     */
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_permissions.
     */
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_permissions.
     */
    distinct?: Admin_permissionsScalarFieldEnum | Admin_permissionsScalarFieldEnum[]
  }

  /**
   * admin_permissions findFirstOrThrow
   */
  export type admin_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     */
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for admin_permissions.
     */
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of admin_permissions.
     */
    distinct?: Admin_permissionsScalarFieldEnum | Admin_permissionsScalarFieldEnum[]
  }

  /**
   * admin_permissions findMany
   */
  export type admin_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which admin_permissions to fetch.
     */
    where?: admin_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of admin_permissions to fetch.
     */
    orderBy?: admin_permissionsOrderByWithRelationInput | admin_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing admin_permissions.
     */
    cursor?: admin_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` admin_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` admin_permissions.
     */
    skip?: number
    distinct?: Admin_permissionsScalarFieldEnum | Admin_permissionsScalarFieldEnum[]
  }

  /**
   * admin_permissions create
   */
  export type admin_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a admin_permissions.
     */
    data: XOR<admin_permissionsCreateInput, admin_permissionsUncheckedCreateInput>
  }

  /**
   * admin_permissions createMany
   */
  export type admin_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many admin_permissions.
     */
    data: admin_permissionsCreateManyInput | admin_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * admin_permissions createManyAndReturn
   */
  export type admin_permissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * The data used to create many admin_permissions.
     */
    data: admin_permissionsCreateManyInput | admin_permissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_permissions update
   */
  export type admin_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a admin_permissions.
     */
    data: XOR<admin_permissionsUpdateInput, admin_permissionsUncheckedUpdateInput>
    /**
     * Choose, which admin_permissions to update.
     */
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions updateMany
   */
  export type admin_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update admin_permissions.
     */
    data: XOR<admin_permissionsUpdateManyMutationInput, admin_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_permissions to update
     */
    where?: admin_permissionsWhereInput
    /**
     * Limit how many admin_permissions to update.
     */
    limit?: number
  }

  /**
   * admin_permissions updateManyAndReturn
   */
  export type admin_permissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * The data used to update admin_permissions.
     */
    data: XOR<admin_permissionsUpdateManyMutationInput, admin_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which admin_permissions to update
     */
    where?: admin_permissionsWhereInput
    /**
     * Limit how many admin_permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * admin_permissions upsert
   */
  export type admin_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the admin_permissions to update in case it exists.
     */
    where: admin_permissionsWhereUniqueInput
    /**
     * In case the admin_permissions found by the `where` argument doesn't exist, create a new admin_permissions with this data.
     */
    create: XOR<admin_permissionsCreateInput, admin_permissionsUncheckedCreateInput>
    /**
     * In case the admin_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<admin_permissionsUpdateInput, admin_permissionsUncheckedUpdateInput>
  }

  /**
   * admin_permissions delete
   */
  export type admin_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
    /**
     * Filter which admin_permissions to delete.
     */
    where: admin_permissionsWhereUniqueInput
  }

  /**
   * admin_permissions deleteMany
   */
  export type admin_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which admin_permissions to delete
     */
    where?: admin_permissionsWhereInput
    /**
     * Limit how many admin_permissions to delete.
     */
    limit?: number
  }

  /**
   * admin_permissions without action
   */
  export type admin_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the admin_permissions
     */
    select?: admin_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the admin_permissions
     */
    omit?: admin_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: admin_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model bootcamp_progress
   */

  export type AggregateBootcamp_progress = {
    _count: Bootcamp_progressCountAggregateOutputType | null
    _avg: Bootcamp_progressAvgAggregateOutputType | null
    _sum: Bootcamp_progressSumAggregateOutputType | null
    _min: Bootcamp_progressMinAggregateOutputType | null
    _max: Bootcamp_progressMaxAggregateOutputType | null
  }

  export type Bootcamp_progressAvgAggregateOutputType = {
    user_id: number | null
    current_training_index: number | null
    progress_percentage: Decimal | null
  }

  export type Bootcamp_progressSumAggregateOutputType = {
    user_id: number | null
    current_training_index: number | null
    progress_percentage: Decimal | null
  }

  export type Bootcamp_progressMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    bootcamp_id: string | null
    current_training_index: number | null
    progress_percentage: Decimal | null
    last_activity: Date | null
  }

  export type Bootcamp_progressMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    bootcamp_id: string | null
    current_training_index: number | null
    progress_percentage: Decimal | null
    last_activity: Date | null
  }

  export type Bootcamp_progressCountAggregateOutputType = {
    id: number
    user_id: number
    bootcamp_id: number
    current_training_index: number
    progress_percentage: number
    last_activity: number
    _all: number
  }


  export type Bootcamp_progressAvgAggregateInputType = {
    user_id?: true
    current_training_index?: true
    progress_percentage?: true
  }

  export type Bootcamp_progressSumAggregateInputType = {
    user_id?: true
    current_training_index?: true
    progress_percentage?: true
  }

  export type Bootcamp_progressMinAggregateInputType = {
    id?: true
    user_id?: true
    bootcamp_id?: true
    current_training_index?: true
    progress_percentage?: true
    last_activity?: true
  }

  export type Bootcamp_progressMaxAggregateInputType = {
    id?: true
    user_id?: true
    bootcamp_id?: true
    current_training_index?: true
    progress_percentage?: true
    last_activity?: true
  }

  export type Bootcamp_progressCountAggregateInputType = {
    id?: true
    user_id?: true
    bootcamp_id?: true
    current_training_index?: true
    progress_percentage?: true
    last_activity?: true
    _all?: true
  }

  export type Bootcamp_progressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bootcamp_progress to aggregate.
     */
    where?: bootcamp_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamp_progresses to fetch.
     */
    orderBy?: bootcamp_progressOrderByWithRelationInput | bootcamp_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bootcamp_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamp_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamp_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bootcamp_progresses
    **/
    _count?: true | Bootcamp_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bootcamp_progressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bootcamp_progressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bootcamp_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bootcamp_progressMaxAggregateInputType
  }

  export type GetBootcamp_progressAggregateType<T extends Bootcamp_progressAggregateArgs> = {
        [P in keyof T & keyof AggregateBootcamp_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBootcamp_progress[P]>
      : GetScalarType<T[P], AggregateBootcamp_progress[P]>
  }




  export type bootcamp_progressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bootcamp_progressWhereInput
    orderBy?: bootcamp_progressOrderByWithAggregationInput | bootcamp_progressOrderByWithAggregationInput[]
    by: Bootcamp_progressScalarFieldEnum[] | Bootcamp_progressScalarFieldEnum
    having?: bootcamp_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bootcamp_progressCountAggregateInputType | true
    _avg?: Bootcamp_progressAvgAggregateInputType
    _sum?: Bootcamp_progressSumAggregateInputType
    _min?: Bootcamp_progressMinAggregateInputType
    _max?: Bootcamp_progressMaxAggregateInputType
  }

  export type Bootcamp_progressGroupByOutputType = {
    id: string
    user_id: number
    bootcamp_id: string
    current_training_index: number | null
    progress_percentage: Decimal | null
    last_activity: Date | null
    _count: Bootcamp_progressCountAggregateOutputType | null
    _avg: Bootcamp_progressAvgAggregateOutputType | null
    _sum: Bootcamp_progressSumAggregateOutputType | null
    _min: Bootcamp_progressMinAggregateOutputType | null
    _max: Bootcamp_progressMaxAggregateOutputType | null
  }

  type GetBootcamp_progressGroupByPayload<T extends bootcamp_progressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bootcamp_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bootcamp_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bootcamp_progressGroupByOutputType[P]>
            : GetScalarType<T[P], Bootcamp_progressGroupByOutputType[P]>
        }
      >
    >


  export type bootcamp_progressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bootcamp_id?: boolean
    current_training_index?: boolean
    progress_percentage?: boolean
    last_activity?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bootcamp_progress"]>

  export type bootcamp_progressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bootcamp_id?: boolean
    current_training_index?: boolean
    progress_percentage?: boolean
    last_activity?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bootcamp_progress"]>

  export type bootcamp_progressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bootcamp_id?: boolean
    current_training_index?: boolean
    progress_percentage?: boolean
    last_activity?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bootcamp_progress"]>

  export type bootcamp_progressSelectScalar = {
    id?: boolean
    user_id?: boolean
    bootcamp_id?: boolean
    current_training_index?: boolean
    progress_percentage?: boolean
    last_activity?: boolean
  }

  export type bootcamp_progressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "bootcamp_id" | "current_training_index" | "progress_percentage" | "last_activity", ExtArgs["result"]["bootcamp_progress"]>
  export type bootcamp_progressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type bootcamp_progressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type bootcamp_progressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $bootcamp_progressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bootcamp_progress"
    objects: {
      bootcamps: Prisma.$bootcampsPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      bootcamp_id: string
      current_training_index: number | null
      progress_percentage: Prisma.Decimal | null
      last_activity: Date | null
    }, ExtArgs["result"]["bootcamp_progress"]>
    composites: {}
  }

  type bootcamp_progressGetPayload<S extends boolean | null | undefined | bootcamp_progressDefaultArgs> = $Result.GetResult<Prisma.$bootcamp_progressPayload, S>

  type bootcamp_progressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bootcamp_progressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bootcamp_progressCountAggregateInputType | true
    }

  export interface bootcamp_progressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bootcamp_progress'], meta: { name: 'bootcamp_progress' } }
    /**
     * Find zero or one Bootcamp_progress that matches the filter.
     * @param {bootcamp_progressFindUniqueArgs} args - Arguments to find a Bootcamp_progress
     * @example
     * // Get one Bootcamp_progress
     * const bootcamp_progress = await prisma.bootcamp_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bootcamp_progressFindUniqueArgs>(args: SelectSubset<T, bootcamp_progressFindUniqueArgs<ExtArgs>>): Prisma__bootcamp_progressClient<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bootcamp_progress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bootcamp_progressFindUniqueOrThrowArgs} args - Arguments to find a Bootcamp_progress
     * @example
     * // Get one Bootcamp_progress
     * const bootcamp_progress = await prisma.bootcamp_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bootcamp_progressFindUniqueOrThrowArgs>(args: SelectSubset<T, bootcamp_progressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bootcamp_progressClient<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bootcamp_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_progressFindFirstArgs} args - Arguments to find a Bootcamp_progress
     * @example
     * // Get one Bootcamp_progress
     * const bootcamp_progress = await prisma.bootcamp_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bootcamp_progressFindFirstArgs>(args?: SelectSubset<T, bootcamp_progressFindFirstArgs<ExtArgs>>): Prisma__bootcamp_progressClient<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bootcamp_progress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_progressFindFirstOrThrowArgs} args - Arguments to find a Bootcamp_progress
     * @example
     * // Get one Bootcamp_progress
     * const bootcamp_progress = await prisma.bootcamp_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bootcamp_progressFindFirstOrThrowArgs>(args?: SelectSubset<T, bootcamp_progressFindFirstOrThrowArgs<ExtArgs>>): Prisma__bootcamp_progressClient<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bootcamp_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_progressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bootcamp_progresses
     * const bootcamp_progresses = await prisma.bootcamp_progress.findMany()
     * 
     * // Get first 10 Bootcamp_progresses
     * const bootcamp_progresses = await prisma.bootcamp_progress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bootcamp_progressWithIdOnly = await prisma.bootcamp_progress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bootcamp_progressFindManyArgs>(args?: SelectSubset<T, bootcamp_progressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bootcamp_progress.
     * @param {bootcamp_progressCreateArgs} args - Arguments to create a Bootcamp_progress.
     * @example
     * // Create one Bootcamp_progress
     * const Bootcamp_progress = await prisma.bootcamp_progress.create({
     *   data: {
     *     // ... data to create a Bootcamp_progress
     *   }
     * })
     * 
     */
    create<T extends bootcamp_progressCreateArgs>(args: SelectSubset<T, bootcamp_progressCreateArgs<ExtArgs>>): Prisma__bootcamp_progressClient<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bootcamp_progresses.
     * @param {bootcamp_progressCreateManyArgs} args - Arguments to create many Bootcamp_progresses.
     * @example
     * // Create many Bootcamp_progresses
     * const bootcamp_progress = await prisma.bootcamp_progress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bootcamp_progressCreateManyArgs>(args?: SelectSubset<T, bootcamp_progressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bootcamp_progresses and returns the data saved in the database.
     * @param {bootcamp_progressCreateManyAndReturnArgs} args - Arguments to create many Bootcamp_progresses.
     * @example
     * // Create many Bootcamp_progresses
     * const bootcamp_progress = await prisma.bootcamp_progress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bootcamp_progresses and only return the `id`
     * const bootcamp_progressWithIdOnly = await prisma.bootcamp_progress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bootcamp_progressCreateManyAndReturnArgs>(args?: SelectSubset<T, bootcamp_progressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bootcamp_progress.
     * @param {bootcamp_progressDeleteArgs} args - Arguments to delete one Bootcamp_progress.
     * @example
     * // Delete one Bootcamp_progress
     * const Bootcamp_progress = await prisma.bootcamp_progress.delete({
     *   where: {
     *     // ... filter to delete one Bootcamp_progress
     *   }
     * })
     * 
     */
    delete<T extends bootcamp_progressDeleteArgs>(args: SelectSubset<T, bootcamp_progressDeleteArgs<ExtArgs>>): Prisma__bootcamp_progressClient<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bootcamp_progress.
     * @param {bootcamp_progressUpdateArgs} args - Arguments to update one Bootcamp_progress.
     * @example
     * // Update one Bootcamp_progress
     * const bootcamp_progress = await prisma.bootcamp_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bootcamp_progressUpdateArgs>(args: SelectSubset<T, bootcamp_progressUpdateArgs<ExtArgs>>): Prisma__bootcamp_progressClient<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bootcamp_progresses.
     * @param {bootcamp_progressDeleteManyArgs} args - Arguments to filter Bootcamp_progresses to delete.
     * @example
     * // Delete a few Bootcamp_progresses
     * const { count } = await prisma.bootcamp_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bootcamp_progressDeleteManyArgs>(args?: SelectSubset<T, bootcamp_progressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bootcamp_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bootcamp_progresses
     * const bootcamp_progress = await prisma.bootcamp_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bootcamp_progressUpdateManyArgs>(args: SelectSubset<T, bootcamp_progressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bootcamp_progresses and returns the data updated in the database.
     * @param {bootcamp_progressUpdateManyAndReturnArgs} args - Arguments to update many Bootcamp_progresses.
     * @example
     * // Update many Bootcamp_progresses
     * const bootcamp_progress = await prisma.bootcamp_progress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bootcamp_progresses and only return the `id`
     * const bootcamp_progressWithIdOnly = await prisma.bootcamp_progress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bootcamp_progressUpdateManyAndReturnArgs>(args: SelectSubset<T, bootcamp_progressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bootcamp_progress.
     * @param {bootcamp_progressUpsertArgs} args - Arguments to update or create a Bootcamp_progress.
     * @example
     * // Update or create a Bootcamp_progress
     * const bootcamp_progress = await prisma.bootcamp_progress.upsert({
     *   create: {
     *     // ... data to create a Bootcamp_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bootcamp_progress we want to update
     *   }
     * })
     */
    upsert<T extends bootcamp_progressUpsertArgs>(args: SelectSubset<T, bootcamp_progressUpsertArgs<ExtArgs>>): Prisma__bootcamp_progressClient<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bootcamp_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_progressCountArgs} args - Arguments to filter Bootcamp_progresses to count.
     * @example
     * // Count the number of Bootcamp_progresses
     * const count = await prisma.bootcamp_progress.count({
     *   where: {
     *     // ... the filter for the Bootcamp_progresses we want to count
     *   }
     * })
    **/
    count<T extends bootcamp_progressCountArgs>(
      args?: Subset<T, bootcamp_progressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bootcamp_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bootcamp_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bootcamp_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bootcamp_progressAggregateArgs>(args: Subset<T, Bootcamp_progressAggregateArgs>): Prisma.PrismaPromise<GetBootcamp_progressAggregateType<T>>

    /**
     * Group by Bootcamp_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bootcamp_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bootcamp_progressGroupByArgs['orderBy'] }
        : { orderBy?: bootcamp_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bootcamp_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBootcamp_progressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bootcamp_progress model
   */
  readonly fields: bootcamp_progressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bootcamp_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bootcamp_progressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bootcamps<T extends bootcampsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bootcampsDefaultArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bootcamp_progress model
   */
  interface bootcamp_progressFieldRefs {
    readonly id: FieldRef<"bootcamp_progress", 'String'>
    readonly user_id: FieldRef<"bootcamp_progress", 'Int'>
    readonly bootcamp_id: FieldRef<"bootcamp_progress", 'String'>
    readonly current_training_index: FieldRef<"bootcamp_progress", 'Int'>
    readonly progress_percentage: FieldRef<"bootcamp_progress", 'Decimal'>
    readonly last_activity: FieldRef<"bootcamp_progress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bootcamp_progress findUnique
   */
  export type bootcamp_progressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_progress to fetch.
     */
    where: bootcamp_progressWhereUniqueInput
  }

  /**
   * bootcamp_progress findUniqueOrThrow
   */
  export type bootcamp_progressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_progress to fetch.
     */
    where: bootcamp_progressWhereUniqueInput
  }

  /**
   * bootcamp_progress findFirst
   */
  export type bootcamp_progressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_progress to fetch.
     */
    where?: bootcamp_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamp_progresses to fetch.
     */
    orderBy?: bootcamp_progressOrderByWithRelationInput | bootcamp_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bootcamp_progresses.
     */
    cursor?: bootcamp_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamp_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamp_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bootcamp_progresses.
     */
    distinct?: Bootcamp_progressScalarFieldEnum | Bootcamp_progressScalarFieldEnum[]
  }

  /**
   * bootcamp_progress findFirstOrThrow
   */
  export type bootcamp_progressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_progress to fetch.
     */
    where?: bootcamp_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamp_progresses to fetch.
     */
    orderBy?: bootcamp_progressOrderByWithRelationInput | bootcamp_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bootcamp_progresses.
     */
    cursor?: bootcamp_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamp_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamp_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bootcamp_progresses.
     */
    distinct?: Bootcamp_progressScalarFieldEnum | Bootcamp_progressScalarFieldEnum[]
  }

  /**
   * bootcamp_progress findMany
   */
  export type bootcamp_progressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_progresses to fetch.
     */
    where?: bootcamp_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamp_progresses to fetch.
     */
    orderBy?: bootcamp_progressOrderByWithRelationInput | bootcamp_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bootcamp_progresses.
     */
    cursor?: bootcamp_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamp_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamp_progresses.
     */
    skip?: number
    distinct?: Bootcamp_progressScalarFieldEnum | Bootcamp_progressScalarFieldEnum[]
  }

  /**
   * bootcamp_progress create
   */
  export type bootcamp_progressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * The data needed to create a bootcamp_progress.
     */
    data: XOR<bootcamp_progressCreateInput, bootcamp_progressUncheckedCreateInput>
  }

  /**
   * bootcamp_progress createMany
   */
  export type bootcamp_progressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bootcamp_progresses.
     */
    data: bootcamp_progressCreateManyInput | bootcamp_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bootcamp_progress createManyAndReturn
   */
  export type bootcamp_progressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * The data used to create many bootcamp_progresses.
     */
    data: bootcamp_progressCreateManyInput | bootcamp_progressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bootcamp_progress update
   */
  export type bootcamp_progressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * The data needed to update a bootcamp_progress.
     */
    data: XOR<bootcamp_progressUpdateInput, bootcamp_progressUncheckedUpdateInput>
    /**
     * Choose, which bootcamp_progress to update.
     */
    where: bootcamp_progressWhereUniqueInput
  }

  /**
   * bootcamp_progress updateMany
   */
  export type bootcamp_progressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bootcamp_progresses.
     */
    data: XOR<bootcamp_progressUpdateManyMutationInput, bootcamp_progressUncheckedUpdateManyInput>
    /**
     * Filter which bootcamp_progresses to update
     */
    where?: bootcamp_progressWhereInput
    /**
     * Limit how many bootcamp_progresses to update.
     */
    limit?: number
  }

  /**
   * bootcamp_progress updateManyAndReturn
   */
  export type bootcamp_progressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * The data used to update bootcamp_progresses.
     */
    data: XOR<bootcamp_progressUpdateManyMutationInput, bootcamp_progressUncheckedUpdateManyInput>
    /**
     * Filter which bootcamp_progresses to update
     */
    where?: bootcamp_progressWhereInput
    /**
     * Limit how many bootcamp_progresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bootcamp_progress upsert
   */
  export type bootcamp_progressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * The filter to search for the bootcamp_progress to update in case it exists.
     */
    where: bootcamp_progressWhereUniqueInput
    /**
     * In case the bootcamp_progress found by the `where` argument doesn't exist, create a new bootcamp_progress with this data.
     */
    create: XOR<bootcamp_progressCreateInput, bootcamp_progressUncheckedCreateInput>
    /**
     * In case the bootcamp_progress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bootcamp_progressUpdateInput, bootcamp_progressUncheckedUpdateInput>
  }

  /**
   * bootcamp_progress delete
   */
  export type bootcamp_progressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    /**
     * Filter which bootcamp_progress to delete.
     */
    where: bootcamp_progressWhereUniqueInput
  }

  /**
   * bootcamp_progress deleteMany
   */
  export type bootcamp_progressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bootcamp_progresses to delete
     */
    where?: bootcamp_progressWhereInput
    /**
     * Limit how many bootcamp_progresses to delete.
     */
    limit?: number
  }

  /**
   * bootcamp_progress without action
   */
  export type bootcamp_progressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
  }


  /**
   * Model bootcamp_trainings
   */

  export type AggregateBootcamp_trainings = {
    _count: Bootcamp_trainingsCountAggregateOutputType | null
    _avg: Bootcamp_trainingsAvgAggregateOutputType | null
    _sum: Bootcamp_trainingsSumAggregateOutputType | null
    _min: Bootcamp_trainingsMinAggregateOutputType | null
    _max: Bootcamp_trainingsMaxAggregateOutputType | null
  }

  export type Bootcamp_trainingsAvgAggregateOutputType = {
    order_index: number | null
  }

  export type Bootcamp_trainingsSumAggregateOutputType = {
    order_index: number | null
  }

  export type Bootcamp_trainingsMinAggregateOutputType = {
    id: string | null
    bootcamp_id: string | null
    training_id: string | null
    order_index: number | null
    required: boolean | null
    created_at: Date | null
  }

  export type Bootcamp_trainingsMaxAggregateOutputType = {
    id: string | null
    bootcamp_id: string | null
    training_id: string | null
    order_index: number | null
    required: boolean | null
    created_at: Date | null
  }

  export type Bootcamp_trainingsCountAggregateOutputType = {
    id: number
    bootcamp_id: number
    training_id: number
    order_index: number
    required: number
    created_at: number
    _all: number
  }


  export type Bootcamp_trainingsAvgAggregateInputType = {
    order_index?: true
  }

  export type Bootcamp_trainingsSumAggregateInputType = {
    order_index?: true
  }

  export type Bootcamp_trainingsMinAggregateInputType = {
    id?: true
    bootcamp_id?: true
    training_id?: true
    order_index?: true
    required?: true
    created_at?: true
  }

  export type Bootcamp_trainingsMaxAggregateInputType = {
    id?: true
    bootcamp_id?: true
    training_id?: true
    order_index?: true
    required?: true
    created_at?: true
  }

  export type Bootcamp_trainingsCountAggregateInputType = {
    id?: true
    bootcamp_id?: true
    training_id?: true
    order_index?: true
    required?: true
    created_at?: true
    _all?: true
  }

  export type Bootcamp_trainingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bootcamp_trainings to aggregate.
     */
    where?: bootcamp_trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamp_trainings to fetch.
     */
    orderBy?: bootcamp_trainingsOrderByWithRelationInput | bootcamp_trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bootcamp_trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamp_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamp_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bootcamp_trainings
    **/
    _count?: true | Bootcamp_trainingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bootcamp_trainingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bootcamp_trainingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bootcamp_trainingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bootcamp_trainingsMaxAggregateInputType
  }

  export type GetBootcamp_trainingsAggregateType<T extends Bootcamp_trainingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBootcamp_trainings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBootcamp_trainings[P]>
      : GetScalarType<T[P], AggregateBootcamp_trainings[P]>
  }




  export type bootcamp_trainingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bootcamp_trainingsWhereInput
    orderBy?: bootcamp_trainingsOrderByWithAggregationInput | bootcamp_trainingsOrderByWithAggregationInput[]
    by: Bootcamp_trainingsScalarFieldEnum[] | Bootcamp_trainingsScalarFieldEnum
    having?: bootcamp_trainingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bootcamp_trainingsCountAggregateInputType | true
    _avg?: Bootcamp_trainingsAvgAggregateInputType
    _sum?: Bootcamp_trainingsSumAggregateInputType
    _min?: Bootcamp_trainingsMinAggregateInputType
    _max?: Bootcamp_trainingsMaxAggregateInputType
  }

  export type Bootcamp_trainingsGroupByOutputType = {
    id: string
    bootcamp_id: string
    training_id: string
    order_index: number
    required: boolean | null
    created_at: Date | null
    _count: Bootcamp_trainingsCountAggregateOutputType | null
    _avg: Bootcamp_trainingsAvgAggregateOutputType | null
    _sum: Bootcamp_trainingsSumAggregateOutputType | null
    _min: Bootcamp_trainingsMinAggregateOutputType | null
    _max: Bootcamp_trainingsMaxAggregateOutputType | null
  }

  type GetBootcamp_trainingsGroupByPayload<T extends bootcamp_trainingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bootcamp_trainingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bootcamp_trainingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bootcamp_trainingsGroupByOutputType[P]>
            : GetScalarType<T[P], Bootcamp_trainingsGroupByOutputType[P]>
        }
      >
    >


  export type bootcamp_trainingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bootcamp_id?: boolean
    training_id?: boolean
    order_index?: boolean
    required?: boolean
    created_at?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bootcamp_trainings"]>

  export type bootcamp_trainingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bootcamp_id?: boolean
    training_id?: boolean
    order_index?: boolean
    required?: boolean
    created_at?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bootcamp_trainings"]>

  export type bootcamp_trainingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bootcamp_id?: boolean
    training_id?: boolean
    order_index?: boolean
    required?: boolean
    created_at?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bootcamp_trainings"]>

  export type bootcamp_trainingsSelectScalar = {
    id?: boolean
    bootcamp_id?: boolean
    training_id?: boolean
    order_index?: boolean
    required?: boolean
    created_at?: boolean
  }

  export type bootcamp_trainingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bootcamp_id" | "training_id" | "order_index" | "required" | "created_at", ExtArgs["result"]["bootcamp_trainings"]>
  export type bootcamp_trainingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }
  export type bootcamp_trainingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }
  export type bootcamp_trainingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }

  export type $bootcamp_trainingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bootcamp_trainings"
    objects: {
      bootcamps: Prisma.$bootcampsPayload<ExtArgs>
      trainings: Prisma.$trainingsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bootcamp_id: string
      training_id: string
      order_index: number
      required: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["bootcamp_trainings"]>
    composites: {}
  }

  type bootcamp_trainingsGetPayload<S extends boolean | null | undefined | bootcamp_trainingsDefaultArgs> = $Result.GetResult<Prisma.$bootcamp_trainingsPayload, S>

  type bootcamp_trainingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bootcamp_trainingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bootcamp_trainingsCountAggregateInputType | true
    }

  export interface bootcamp_trainingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bootcamp_trainings'], meta: { name: 'bootcamp_trainings' } }
    /**
     * Find zero or one Bootcamp_trainings that matches the filter.
     * @param {bootcamp_trainingsFindUniqueArgs} args - Arguments to find a Bootcamp_trainings
     * @example
     * // Get one Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bootcamp_trainingsFindUniqueArgs>(args: SelectSubset<T, bootcamp_trainingsFindUniqueArgs<ExtArgs>>): Prisma__bootcamp_trainingsClient<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bootcamp_trainings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bootcamp_trainingsFindUniqueOrThrowArgs} args - Arguments to find a Bootcamp_trainings
     * @example
     * // Get one Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bootcamp_trainingsFindUniqueOrThrowArgs>(args: SelectSubset<T, bootcamp_trainingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bootcamp_trainingsClient<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bootcamp_trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_trainingsFindFirstArgs} args - Arguments to find a Bootcamp_trainings
     * @example
     * // Get one Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bootcamp_trainingsFindFirstArgs>(args?: SelectSubset<T, bootcamp_trainingsFindFirstArgs<ExtArgs>>): Prisma__bootcamp_trainingsClient<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bootcamp_trainings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_trainingsFindFirstOrThrowArgs} args - Arguments to find a Bootcamp_trainings
     * @example
     * // Get one Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bootcamp_trainingsFindFirstOrThrowArgs>(args?: SelectSubset<T, bootcamp_trainingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bootcamp_trainingsClient<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bootcamp_trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_trainingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.findMany()
     * 
     * // Get first 10 Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bootcamp_trainingsWithIdOnly = await prisma.bootcamp_trainings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bootcamp_trainingsFindManyArgs>(args?: SelectSubset<T, bootcamp_trainingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bootcamp_trainings.
     * @param {bootcamp_trainingsCreateArgs} args - Arguments to create a Bootcamp_trainings.
     * @example
     * // Create one Bootcamp_trainings
     * const Bootcamp_trainings = await prisma.bootcamp_trainings.create({
     *   data: {
     *     // ... data to create a Bootcamp_trainings
     *   }
     * })
     * 
     */
    create<T extends bootcamp_trainingsCreateArgs>(args: SelectSubset<T, bootcamp_trainingsCreateArgs<ExtArgs>>): Prisma__bootcamp_trainingsClient<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bootcamp_trainings.
     * @param {bootcamp_trainingsCreateManyArgs} args - Arguments to create many Bootcamp_trainings.
     * @example
     * // Create many Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bootcamp_trainingsCreateManyArgs>(args?: SelectSubset<T, bootcamp_trainingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bootcamp_trainings and returns the data saved in the database.
     * @param {bootcamp_trainingsCreateManyAndReturnArgs} args - Arguments to create many Bootcamp_trainings.
     * @example
     * // Create many Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bootcamp_trainings and only return the `id`
     * const bootcamp_trainingsWithIdOnly = await prisma.bootcamp_trainings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bootcamp_trainingsCreateManyAndReturnArgs>(args?: SelectSubset<T, bootcamp_trainingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bootcamp_trainings.
     * @param {bootcamp_trainingsDeleteArgs} args - Arguments to delete one Bootcamp_trainings.
     * @example
     * // Delete one Bootcamp_trainings
     * const Bootcamp_trainings = await prisma.bootcamp_trainings.delete({
     *   where: {
     *     // ... filter to delete one Bootcamp_trainings
     *   }
     * })
     * 
     */
    delete<T extends bootcamp_trainingsDeleteArgs>(args: SelectSubset<T, bootcamp_trainingsDeleteArgs<ExtArgs>>): Prisma__bootcamp_trainingsClient<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bootcamp_trainings.
     * @param {bootcamp_trainingsUpdateArgs} args - Arguments to update one Bootcamp_trainings.
     * @example
     * // Update one Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bootcamp_trainingsUpdateArgs>(args: SelectSubset<T, bootcamp_trainingsUpdateArgs<ExtArgs>>): Prisma__bootcamp_trainingsClient<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bootcamp_trainings.
     * @param {bootcamp_trainingsDeleteManyArgs} args - Arguments to filter Bootcamp_trainings to delete.
     * @example
     * // Delete a few Bootcamp_trainings
     * const { count } = await prisma.bootcamp_trainings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bootcamp_trainingsDeleteManyArgs>(args?: SelectSubset<T, bootcamp_trainingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bootcamp_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_trainingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bootcamp_trainingsUpdateManyArgs>(args: SelectSubset<T, bootcamp_trainingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bootcamp_trainings and returns the data updated in the database.
     * @param {bootcamp_trainingsUpdateManyAndReturnArgs} args - Arguments to update many Bootcamp_trainings.
     * @example
     * // Update many Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bootcamp_trainings and only return the `id`
     * const bootcamp_trainingsWithIdOnly = await prisma.bootcamp_trainings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bootcamp_trainingsUpdateManyAndReturnArgs>(args: SelectSubset<T, bootcamp_trainingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bootcamp_trainings.
     * @param {bootcamp_trainingsUpsertArgs} args - Arguments to update or create a Bootcamp_trainings.
     * @example
     * // Update or create a Bootcamp_trainings
     * const bootcamp_trainings = await prisma.bootcamp_trainings.upsert({
     *   create: {
     *     // ... data to create a Bootcamp_trainings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bootcamp_trainings we want to update
     *   }
     * })
     */
    upsert<T extends bootcamp_trainingsUpsertArgs>(args: SelectSubset<T, bootcamp_trainingsUpsertArgs<ExtArgs>>): Prisma__bootcamp_trainingsClient<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bootcamp_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_trainingsCountArgs} args - Arguments to filter Bootcamp_trainings to count.
     * @example
     * // Count the number of Bootcamp_trainings
     * const count = await prisma.bootcamp_trainings.count({
     *   where: {
     *     // ... the filter for the Bootcamp_trainings we want to count
     *   }
     * })
    **/
    count<T extends bootcamp_trainingsCountArgs>(
      args?: Subset<T, bootcamp_trainingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bootcamp_trainingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bootcamp_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bootcamp_trainingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bootcamp_trainingsAggregateArgs>(args: Subset<T, Bootcamp_trainingsAggregateArgs>): Prisma.PrismaPromise<GetBootcamp_trainingsAggregateType<T>>

    /**
     * Group by Bootcamp_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcamp_trainingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bootcamp_trainingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bootcamp_trainingsGroupByArgs['orderBy'] }
        : { orderBy?: bootcamp_trainingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bootcamp_trainingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBootcamp_trainingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bootcamp_trainings model
   */
  readonly fields: bootcamp_trainingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bootcamp_trainings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bootcamp_trainingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bootcamps<T extends bootcampsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bootcampsDefaultArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trainings<T extends trainingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, trainingsDefaultArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bootcamp_trainings model
   */
  interface bootcamp_trainingsFieldRefs {
    readonly id: FieldRef<"bootcamp_trainings", 'String'>
    readonly bootcamp_id: FieldRef<"bootcamp_trainings", 'String'>
    readonly training_id: FieldRef<"bootcamp_trainings", 'String'>
    readonly order_index: FieldRef<"bootcamp_trainings", 'Int'>
    readonly required: FieldRef<"bootcamp_trainings", 'Boolean'>
    readonly created_at: FieldRef<"bootcamp_trainings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bootcamp_trainings findUnique
   */
  export type bootcamp_trainingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_trainings to fetch.
     */
    where: bootcamp_trainingsWhereUniqueInput
  }

  /**
   * bootcamp_trainings findUniqueOrThrow
   */
  export type bootcamp_trainingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_trainings to fetch.
     */
    where: bootcamp_trainingsWhereUniqueInput
  }

  /**
   * bootcamp_trainings findFirst
   */
  export type bootcamp_trainingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_trainings to fetch.
     */
    where?: bootcamp_trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamp_trainings to fetch.
     */
    orderBy?: bootcamp_trainingsOrderByWithRelationInput | bootcamp_trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bootcamp_trainings.
     */
    cursor?: bootcamp_trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamp_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamp_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bootcamp_trainings.
     */
    distinct?: Bootcamp_trainingsScalarFieldEnum | Bootcamp_trainingsScalarFieldEnum[]
  }

  /**
   * bootcamp_trainings findFirstOrThrow
   */
  export type bootcamp_trainingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_trainings to fetch.
     */
    where?: bootcamp_trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamp_trainings to fetch.
     */
    orderBy?: bootcamp_trainingsOrderByWithRelationInput | bootcamp_trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bootcamp_trainings.
     */
    cursor?: bootcamp_trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamp_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamp_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bootcamp_trainings.
     */
    distinct?: Bootcamp_trainingsScalarFieldEnum | Bootcamp_trainingsScalarFieldEnum[]
  }

  /**
   * bootcamp_trainings findMany
   */
  export type bootcamp_trainingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamp_trainings to fetch.
     */
    where?: bootcamp_trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamp_trainings to fetch.
     */
    orderBy?: bootcamp_trainingsOrderByWithRelationInput | bootcamp_trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bootcamp_trainings.
     */
    cursor?: bootcamp_trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamp_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamp_trainings.
     */
    skip?: number
    distinct?: Bootcamp_trainingsScalarFieldEnum | Bootcamp_trainingsScalarFieldEnum[]
  }

  /**
   * bootcamp_trainings create
   */
  export type bootcamp_trainingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * The data needed to create a bootcamp_trainings.
     */
    data: XOR<bootcamp_trainingsCreateInput, bootcamp_trainingsUncheckedCreateInput>
  }

  /**
   * bootcamp_trainings createMany
   */
  export type bootcamp_trainingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bootcamp_trainings.
     */
    data: bootcamp_trainingsCreateManyInput | bootcamp_trainingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bootcamp_trainings createManyAndReturn
   */
  export type bootcamp_trainingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * The data used to create many bootcamp_trainings.
     */
    data: bootcamp_trainingsCreateManyInput | bootcamp_trainingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * bootcamp_trainings update
   */
  export type bootcamp_trainingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * The data needed to update a bootcamp_trainings.
     */
    data: XOR<bootcamp_trainingsUpdateInput, bootcamp_trainingsUncheckedUpdateInput>
    /**
     * Choose, which bootcamp_trainings to update.
     */
    where: bootcamp_trainingsWhereUniqueInput
  }

  /**
   * bootcamp_trainings updateMany
   */
  export type bootcamp_trainingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bootcamp_trainings.
     */
    data: XOR<bootcamp_trainingsUpdateManyMutationInput, bootcamp_trainingsUncheckedUpdateManyInput>
    /**
     * Filter which bootcamp_trainings to update
     */
    where?: bootcamp_trainingsWhereInput
    /**
     * Limit how many bootcamp_trainings to update.
     */
    limit?: number
  }

  /**
   * bootcamp_trainings updateManyAndReturn
   */
  export type bootcamp_trainingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * The data used to update bootcamp_trainings.
     */
    data: XOR<bootcamp_trainingsUpdateManyMutationInput, bootcamp_trainingsUncheckedUpdateManyInput>
    /**
     * Filter which bootcamp_trainings to update
     */
    where?: bootcamp_trainingsWhereInput
    /**
     * Limit how many bootcamp_trainings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * bootcamp_trainings upsert
   */
  export type bootcamp_trainingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * The filter to search for the bootcamp_trainings to update in case it exists.
     */
    where: bootcamp_trainingsWhereUniqueInput
    /**
     * In case the bootcamp_trainings found by the `where` argument doesn't exist, create a new bootcamp_trainings with this data.
     */
    create: XOR<bootcamp_trainingsCreateInput, bootcamp_trainingsUncheckedCreateInput>
    /**
     * In case the bootcamp_trainings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bootcamp_trainingsUpdateInput, bootcamp_trainingsUncheckedUpdateInput>
  }

  /**
   * bootcamp_trainings delete
   */
  export type bootcamp_trainingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    /**
     * Filter which bootcamp_trainings to delete.
     */
    where: bootcamp_trainingsWhereUniqueInput
  }

  /**
   * bootcamp_trainings deleteMany
   */
  export type bootcamp_trainingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bootcamp_trainings to delete
     */
    where?: bootcamp_trainingsWhereInput
    /**
     * Limit how many bootcamp_trainings to delete.
     */
    limit?: number
  }

  /**
   * bootcamp_trainings without action
   */
  export type bootcamp_trainingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
  }


  /**
   * Model bootcamps
   */

  export type AggregateBootcamps = {
    _count: BootcampsCountAggregateOutputType | null
    _avg: BootcampsAvgAggregateOutputType | null
    _sum: BootcampsSumAggregateOutputType | null
    _min: BootcampsMinAggregateOutputType | null
    _max: BootcampsMaxAggregateOutputType | null
  }

  export type BootcampsAvgAggregateOutputType = {
    duration: number | null
  }

  export type BootcampsSumAggregateOutputType = {
    duration: number | null
  }

  export type BootcampsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    author: string | null
    published: boolean | null
    duration: number | null
    deadline: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BootcampsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    author: string | null
    published: boolean | null
    duration: number | null
    deadline: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BootcampsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    author: number
    published: number
    duration: number
    deadline: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BootcampsAvgAggregateInputType = {
    duration?: true
  }

  export type BootcampsSumAggregateInputType = {
    duration?: true
  }

  export type BootcampsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    author?: true
    published?: true
    duration?: true
    deadline?: true
    created_at?: true
    updated_at?: true
  }

  export type BootcampsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    author?: true
    published?: true
    duration?: true
    deadline?: true
    created_at?: true
    updated_at?: true
  }

  export type BootcampsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    author?: true
    published?: true
    duration?: true
    deadline?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BootcampsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bootcamps to aggregate.
     */
    where?: bootcampsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamps to fetch.
     */
    orderBy?: bootcampsOrderByWithRelationInput | bootcampsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bootcampsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bootcamps
    **/
    _count?: true | BootcampsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BootcampsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BootcampsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BootcampsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BootcampsMaxAggregateInputType
  }

  export type GetBootcampsAggregateType<T extends BootcampsAggregateArgs> = {
        [P in keyof T & keyof AggregateBootcamps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBootcamps[P]>
      : GetScalarType<T[P], AggregateBootcamps[P]>
  }




  export type bootcampsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bootcampsWhereInput
    orderBy?: bootcampsOrderByWithAggregationInput | bootcampsOrderByWithAggregationInput[]
    by: BootcampsScalarFieldEnum[] | BootcampsScalarFieldEnum
    having?: bootcampsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BootcampsCountAggregateInputType | true
    _avg?: BootcampsAvgAggregateInputType
    _sum?: BootcampsSumAggregateInputType
    _min?: BootcampsMinAggregateInputType
    _max?: BootcampsMaxAggregateInputType
  }

  export type BootcampsGroupByOutputType = {
    id: string
    title: string
    description: string | null
    category: string | null
    author: string | null
    published: boolean | null
    duration: number | null
    deadline: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: BootcampsCountAggregateOutputType | null
    _avg: BootcampsAvgAggregateOutputType | null
    _sum: BootcampsSumAggregateOutputType | null
    _min: BootcampsMinAggregateOutputType | null
    _max: BootcampsMaxAggregateOutputType | null
  }

  type GetBootcampsGroupByPayload<T extends bootcampsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BootcampsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BootcampsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BootcampsGroupByOutputType[P]>
            : GetScalarType<T[P], BootcampsGroupByOutputType[P]>
        }
      >
    >


  export type bootcampsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    author?: boolean
    published?: boolean
    duration?: boolean
    deadline?: boolean
    created_at?: boolean
    updated_at?: boolean
    bootcamp_progress?: boolean | bootcamps$bootcamp_progressArgs<ExtArgs>
    bootcamp_trainings?: boolean | bootcamps$bootcamp_trainingsArgs<ExtArgs>
    user_bootcamp_assignments?: boolean | bootcamps$user_bootcamp_assignmentsArgs<ExtArgs>
    user_training_progress?: boolean | bootcamps$user_training_progressArgs<ExtArgs>
    _count?: boolean | BootcampsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bootcamps"]>

  export type bootcampsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    author?: boolean
    published?: boolean
    duration?: boolean
    deadline?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bootcamps"]>

  export type bootcampsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    author?: boolean
    published?: boolean
    duration?: boolean
    deadline?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bootcamps"]>

  export type bootcampsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    author?: boolean
    published?: boolean
    duration?: boolean
    deadline?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type bootcampsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "author" | "published" | "duration" | "deadline" | "created_at" | "updated_at", ExtArgs["result"]["bootcamps"]>
  export type bootcampsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamp_progress?: boolean | bootcamps$bootcamp_progressArgs<ExtArgs>
    bootcamp_trainings?: boolean | bootcamps$bootcamp_trainingsArgs<ExtArgs>
    user_bootcamp_assignments?: boolean | bootcamps$user_bootcamp_assignmentsArgs<ExtArgs>
    user_training_progress?: boolean | bootcamps$user_training_progressArgs<ExtArgs>
    _count?: boolean | BootcampsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type bootcampsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type bootcampsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $bootcampsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bootcamps"
    objects: {
      bootcamp_progress: Prisma.$bootcamp_progressPayload<ExtArgs>[]
      bootcamp_trainings: Prisma.$bootcamp_trainingsPayload<ExtArgs>[]
      user_bootcamp_assignments: Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>[]
      user_training_progress: Prisma.$user_training_progressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      category: string | null
      author: string | null
      published: boolean | null
      duration: number | null
      deadline: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["bootcamps"]>
    composites: {}
  }

  type bootcampsGetPayload<S extends boolean | null | undefined | bootcampsDefaultArgs> = $Result.GetResult<Prisma.$bootcampsPayload, S>

  type bootcampsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bootcampsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BootcampsCountAggregateInputType | true
    }

  export interface bootcampsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bootcamps'], meta: { name: 'bootcamps' } }
    /**
     * Find zero or one Bootcamps that matches the filter.
     * @param {bootcampsFindUniqueArgs} args - Arguments to find a Bootcamps
     * @example
     * // Get one Bootcamps
     * const bootcamps = await prisma.bootcamps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bootcampsFindUniqueArgs>(args: SelectSubset<T, bootcampsFindUniqueArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bootcamps that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bootcampsFindUniqueOrThrowArgs} args - Arguments to find a Bootcamps
     * @example
     * // Get one Bootcamps
     * const bootcamps = await prisma.bootcamps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bootcampsFindUniqueOrThrowArgs>(args: SelectSubset<T, bootcampsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bootcamps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcampsFindFirstArgs} args - Arguments to find a Bootcamps
     * @example
     * // Get one Bootcamps
     * const bootcamps = await prisma.bootcamps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bootcampsFindFirstArgs>(args?: SelectSubset<T, bootcampsFindFirstArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bootcamps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcampsFindFirstOrThrowArgs} args - Arguments to find a Bootcamps
     * @example
     * // Get one Bootcamps
     * const bootcamps = await prisma.bootcamps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bootcampsFindFirstOrThrowArgs>(args?: SelectSubset<T, bootcampsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bootcamps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcampsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bootcamps
     * const bootcamps = await prisma.bootcamps.findMany()
     * 
     * // Get first 10 Bootcamps
     * const bootcamps = await prisma.bootcamps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bootcampsWithIdOnly = await prisma.bootcamps.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bootcampsFindManyArgs>(args?: SelectSubset<T, bootcampsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bootcamps.
     * @param {bootcampsCreateArgs} args - Arguments to create a Bootcamps.
     * @example
     * // Create one Bootcamps
     * const Bootcamps = await prisma.bootcamps.create({
     *   data: {
     *     // ... data to create a Bootcamps
     *   }
     * })
     * 
     */
    create<T extends bootcampsCreateArgs>(args: SelectSubset<T, bootcampsCreateArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bootcamps.
     * @param {bootcampsCreateManyArgs} args - Arguments to create many Bootcamps.
     * @example
     * // Create many Bootcamps
     * const bootcamps = await prisma.bootcamps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bootcampsCreateManyArgs>(args?: SelectSubset<T, bootcampsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bootcamps and returns the data saved in the database.
     * @param {bootcampsCreateManyAndReturnArgs} args - Arguments to create many Bootcamps.
     * @example
     * // Create many Bootcamps
     * const bootcamps = await prisma.bootcamps.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bootcamps and only return the `id`
     * const bootcampsWithIdOnly = await prisma.bootcamps.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends bootcampsCreateManyAndReturnArgs>(args?: SelectSubset<T, bootcampsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bootcamps.
     * @param {bootcampsDeleteArgs} args - Arguments to delete one Bootcamps.
     * @example
     * // Delete one Bootcamps
     * const Bootcamps = await prisma.bootcamps.delete({
     *   where: {
     *     // ... filter to delete one Bootcamps
     *   }
     * })
     * 
     */
    delete<T extends bootcampsDeleteArgs>(args: SelectSubset<T, bootcampsDeleteArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bootcamps.
     * @param {bootcampsUpdateArgs} args - Arguments to update one Bootcamps.
     * @example
     * // Update one Bootcamps
     * const bootcamps = await prisma.bootcamps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bootcampsUpdateArgs>(args: SelectSubset<T, bootcampsUpdateArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bootcamps.
     * @param {bootcampsDeleteManyArgs} args - Arguments to filter Bootcamps to delete.
     * @example
     * // Delete a few Bootcamps
     * const { count } = await prisma.bootcamps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bootcampsDeleteManyArgs>(args?: SelectSubset<T, bootcampsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bootcamps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcampsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bootcamps
     * const bootcamps = await prisma.bootcamps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bootcampsUpdateManyArgs>(args: SelectSubset<T, bootcampsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bootcamps and returns the data updated in the database.
     * @param {bootcampsUpdateManyAndReturnArgs} args - Arguments to update many Bootcamps.
     * @example
     * // Update many Bootcamps
     * const bootcamps = await prisma.bootcamps.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bootcamps and only return the `id`
     * const bootcampsWithIdOnly = await prisma.bootcamps.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends bootcampsUpdateManyAndReturnArgs>(args: SelectSubset<T, bootcampsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bootcamps.
     * @param {bootcampsUpsertArgs} args - Arguments to update or create a Bootcamps.
     * @example
     * // Update or create a Bootcamps
     * const bootcamps = await prisma.bootcamps.upsert({
     *   create: {
     *     // ... data to create a Bootcamps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bootcamps we want to update
     *   }
     * })
     */
    upsert<T extends bootcampsUpsertArgs>(args: SelectSubset<T, bootcampsUpsertArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bootcamps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcampsCountArgs} args - Arguments to filter Bootcamps to count.
     * @example
     * // Count the number of Bootcamps
     * const count = await prisma.bootcamps.count({
     *   where: {
     *     // ... the filter for the Bootcamps we want to count
     *   }
     * })
    **/
    count<T extends bootcampsCountArgs>(
      args?: Subset<T, bootcampsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BootcampsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bootcamps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BootcampsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BootcampsAggregateArgs>(args: Subset<T, BootcampsAggregateArgs>): Prisma.PrismaPromise<GetBootcampsAggregateType<T>>

    /**
     * Group by Bootcamps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bootcampsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bootcampsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bootcampsGroupByArgs['orderBy'] }
        : { orderBy?: bootcampsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bootcampsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBootcampsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bootcamps model
   */
  readonly fields: bootcampsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bootcamps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bootcampsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bootcamp_progress<T extends bootcamps$bootcamp_progressArgs<ExtArgs> = {}>(args?: Subset<T, bootcamps$bootcamp_progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_progressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bootcamp_trainings<T extends bootcamps$bootcamp_trainingsArgs<ExtArgs> = {}>(args?: Subset<T, bootcamps$bootcamp_trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_bootcamp_assignments<T extends bootcamps$user_bootcamp_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, bootcamps$user_bootcamp_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_training_progress<T extends bootcamps$user_training_progressArgs<ExtArgs> = {}>(args?: Subset<T, bootcamps$user_training_progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bootcamps model
   */
  interface bootcampsFieldRefs {
    readonly id: FieldRef<"bootcamps", 'String'>
    readonly title: FieldRef<"bootcamps", 'String'>
    readonly description: FieldRef<"bootcamps", 'String'>
    readonly category: FieldRef<"bootcamps", 'String'>
    readonly author: FieldRef<"bootcamps", 'String'>
    readonly published: FieldRef<"bootcamps", 'Boolean'>
    readonly duration: FieldRef<"bootcamps", 'Int'>
    readonly deadline: FieldRef<"bootcamps", 'DateTime'>
    readonly created_at: FieldRef<"bootcamps", 'DateTime'>
    readonly updated_at: FieldRef<"bootcamps", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bootcamps findUnique
   */
  export type bootcampsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamps to fetch.
     */
    where: bootcampsWhereUniqueInput
  }

  /**
   * bootcamps findUniqueOrThrow
   */
  export type bootcampsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamps to fetch.
     */
    where: bootcampsWhereUniqueInput
  }

  /**
   * bootcamps findFirst
   */
  export type bootcampsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamps to fetch.
     */
    where?: bootcampsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamps to fetch.
     */
    orderBy?: bootcampsOrderByWithRelationInput | bootcampsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bootcamps.
     */
    cursor?: bootcampsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bootcamps.
     */
    distinct?: BootcampsScalarFieldEnum | BootcampsScalarFieldEnum[]
  }

  /**
   * bootcamps findFirstOrThrow
   */
  export type bootcampsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamps to fetch.
     */
    where?: bootcampsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamps to fetch.
     */
    orderBy?: bootcampsOrderByWithRelationInput | bootcampsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bootcamps.
     */
    cursor?: bootcampsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bootcamps.
     */
    distinct?: BootcampsScalarFieldEnum | BootcampsScalarFieldEnum[]
  }

  /**
   * bootcamps findMany
   */
  export type bootcampsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * Filter, which bootcamps to fetch.
     */
    where?: bootcampsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bootcamps to fetch.
     */
    orderBy?: bootcampsOrderByWithRelationInput | bootcampsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bootcamps.
     */
    cursor?: bootcampsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bootcamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bootcamps.
     */
    skip?: number
    distinct?: BootcampsScalarFieldEnum | BootcampsScalarFieldEnum[]
  }

  /**
   * bootcamps create
   */
  export type bootcampsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * The data needed to create a bootcamps.
     */
    data: XOR<bootcampsCreateInput, bootcampsUncheckedCreateInput>
  }

  /**
   * bootcamps createMany
   */
  export type bootcampsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bootcamps.
     */
    data: bootcampsCreateManyInput | bootcampsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bootcamps createManyAndReturn
   */
  export type bootcampsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * The data used to create many bootcamps.
     */
    data: bootcampsCreateManyInput | bootcampsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bootcamps update
   */
  export type bootcampsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * The data needed to update a bootcamps.
     */
    data: XOR<bootcampsUpdateInput, bootcampsUncheckedUpdateInput>
    /**
     * Choose, which bootcamps to update.
     */
    where: bootcampsWhereUniqueInput
  }

  /**
   * bootcamps updateMany
   */
  export type bootcampsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bootcamps.
     */
    data: XOR<bootcampsUpdateManyMutationInput, bootcampsUncheckedUpdateManyInput>
    /**
     * Filter which bootcamps to update
     */
    where?: bootcampsWhereInput
    /**
     * Limit how many bootcamps to update.
     */
    limit?: number
  }

  /**
   * bootcamps updateManyAndReturn
   */
  export type bootcampsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * The data used to update bootcamps.
     */
    data: XOR<bootcampsUpdateManyMutationInput, bootcampsUncheckedUpdateManyInput>
    /**
     * Filter which bootcamps to update
     */
    where?: bootcampsWhereInput
    /**
     * Limit how many bootcamps to update.
     */
    limit?: number
  }

  /**
   * bootcamps upsert
   */
  export type bootcampsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * The filter to search for the bootcamps to update in case it exists.
     */
    where: bootcampsWhereUniqueInput
    /**
     * In case the bootcamps found by the `where` argument doesn't exist, create a new bootcamps with this data.
     */
    create: XOR<bootcampsCreateInput, bootcampsUncheckedCreateInput>
    /**
     * In case the bootcamps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bootcampsUpdateInput, bootcampsUncheckedUpdateInput>
  }

  /**
   * bootcamps delete
   */
  export type bootcampsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    /**
     * Filter which bootcamps to delete.
     */
    where: bootcampsWhereUniqueInput
  }

  /**
   * bootcamps deleteMany
   */
  export type bootcampsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bootcamps to delete
     */
    where?: bootcampsWhereInput
    /**
     * Limit how many bootcamps to delete.
     */
    limit?: number
  }

  /**
   * bootcamps.bootcamp_progress
   */
  export type bootcamps$bootcamp_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_progress
     */
    select?: bootcamp_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_progress
     */
    omit?: bootcamp_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_progressInclude<ExtArgs> | null
    where?: bootcamp_progressWhereInput
    orderBy?: bootcamp_progressOrderByWithRelationInput | bootcamp_progressOrderByWithRelationInput[]
    cursor?: bootcamp_progressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bootcamp_progressScalarFieldEnum | Bootcamp_progressScalarFieldEnum[]
  }

  /**
   * bootcamps.bootcamp_trainings
   */
  export type bootcamps$bootcamp_trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    where?: bootcamp_trainingsWhereInput
    orderBy?: bootcamp_trainingsOrderByWithRelationInput | bootcamp_trainingsOrderByWithRelationInput[]
    cursor?: bootcamp_trainingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bootcamp_trainingsScalarFieldEnum | Bootcamp_trainingsScalarFieldEnum[]
  }

  /**
   * bootcamps.user_bootcamp_assignments
   */
  export type bootcamps$user_bootcamp_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    where?: user_bootcamp_assignmentsWhereInput
    orderBy?: user_bootcamp_assignmentsOrderByWithRelationInput | user_bootcamp_assignmentsOrderByWithRelationInput[]
    cursor?: user_bootcamp_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_bootcamp_assignmentsScalarFieldEnum | User_bootcamp_assignmentsScalarFieldEnum[]
  }

  /**
   * bootcamps.user_training_progress
   */
  export type bootcamps$user_training_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    where?: user_training_progressWhereInput
    orderBy?: user_training_progressOrderByWithRelationInput | user_training_progressOrderByWithRelationInput[]
    cursor?: user_training_progressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_training_progressScalarFieldEnum | User_training_progressScalarFieldEnum[]
  }

  /**
   * bootcamps without action
   */
  export type bootcampsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
  }


  /**
   * Model conference_attendees
   */

  export type AggregateConference_attendees = {
    _count: Conference_attendeesCountAggregateOutputType | null
    _avg: Conference_attendeesAvgAggregateOutputType | null
    _sum: Conference_attendeesSumAggregateOutputType | null
    _min: Conference_attendeesMinAggregateOutputType | null
    _max: Conference_attendeesMaxAggregateOutputType | null
  }

  export type Conference_attendeesAvgAggregateOutputType = {
    user_id: number | null
  }

  export type Conference_attendeesSumAggregateOutputType = {
    user_id: number | null
  }

  export type Conference_attendeesMinAggregateOutputType = {
    id: string | null
    conference_id: string | null
    user_id: number | null
    registered_at: Date | null
    attended: boolean | null
    attendance_time: Date | null
    notes: string | null
  }

  export type Conference_attendeesMaxAggregateOutputType = {
    id: string | null
    conference_id: string | null
    user_id: number | null
    registered_at: Date | null
    attended: boolean | null
    attendance_time: Date | null
    notes: string | null
  }

  export type Conference_attendeesCountAggregateOutputType = {
    id: number
    conference_id: number
    user_id: number
    registered_at: number
    attended: number
    attendance_time: number
    notes: number
    _all: number
  }


  export type Conference_attendeesAvgAggregateInputType = {
    user_id?: true
  }

  export type Conference_attendeesSumAggregateInputType = {
    user_id?: true
  }

  export type Conference_attendeesMinAggregateInputType = {
    id?: true
    conference_id?: true
    user_id?: true
    registered_at?: true
    attended?: true
    attendance_time?: true
    notes?: true
  }

  export type Conference_attendeesMaxAggregateInputType = {
    id?: true
    conference_id?: true
    user_id?: true
    registered_at?: true
    attended?: true
    attendance_time?: true
    notes?: true
  }

  export type Conference_attendeesCountAggregateInputType = {
    id?: true
    conference_id?: true
    user_id?: true
    registered_at?: true
    attended?: true
    attendance_time?: true
    notes?: true
    _all?: true
  }

  export type Conference_attendeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conference_attendees to aggregate.
     */
    where?: conference_attendeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_attendees to fetch.
     */
    orderBy?: conference_attendeesOrderByWithRelationInput | conference_attendeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conference_attendeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conference_attendees
    **/
    _count?: true | Conference_attendeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Conference_attendeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Conference_attendeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Conference_attendeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Conference_attendeesMaxAggregateInputType
  }

  export type GetConference_attendeesAggregateType<T extends Conference_attendeesAggregateArgs> = {
        [P in keyof T & keyof AggregateConference_attendees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConference_attendees[P]>
      : GetScalarType<T[P], AggregateConference_attendees[P]>
  }




  export type conference_attendeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conference_attendeesWhereInput
    orderBy?: conference_attendeesOrderByWithAggregationInput | conference_attendeesOrderByWithAggregationInput[]
    by: Conference_attendeesScalarFieldEnum[] | Conference_attendeesScalarFieldEnum
    having?: conference_attendeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Conference_attendeesCountAggregateInputType | true
    _avg?: Conference_attendeesAvgAggregateInputType
    _sum?: Conference_attendeesSumAggregateInputType
    _min?: Conference_attendeesMinAggregateInputType
    _max?: Conference_attendeesMaxAggregateInputType
  }

  export type Conference_attendeesGroupByOutputType = {
    id: string
    conference_id: string
    user_id: number
    registered_at: Date | null
    attended: boolean | null
    attendance_time: Date | null
    notes: string | null
    _count: Conference_attendeesCountAggregateOutputType | null
    _avg: Conference_attendeesAvgAggregateOutputType | null
    _sum: Conference_attendeesSumAggregateOutputType | null
    _min: Conference_attendeesMinAggregateOutputType | null
    _max: Conference_attendeesMaxAggregateOutputType | null
  }

  type GetConference_attendeesGroupByPayload<T extends conference_attendeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Conference_attendeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Conference_attendeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Conference_attendeesGroupByOutputType[P]>
            : GetScalarType<T[P], Conference_attendeesGroupByOutputType[P]>
        }
      >
    >


  export type conference_attendeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conference_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    attended?: boolean
    attendance_time?: boolean
    notes?: boolean
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference_attendees"]>

  export type conference_attendeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conference_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    attended?: boolean
    attendance_time?: boolean
    notes?: boolean
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference_attendees"]>

  export type conference_attendeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conference_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    attended?: boolean
    attendance_time?: boolean
    notes?: boolean
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference_attendees"]>

  export type conference_attendeesSelectScalar = {
    id?: boolean
    conference_id?: boolean
    user_id?: boolean
    registered_at?: boolean
    attended?: boolean
    attendance_time?: boolean
    notes?: boolean
  }

  export type conference_attendeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conference_id" | "user_id" | "registered_at" | "attended" | "attendance_time" | "notes", ExtArgs["result"]["conference_attendees"]>
  export type conference_attendeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type conference_attendeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type conference_attendeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $conference_attendeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conference_attendees"
    objects: {
      conference_trainings: Prisma.$conference_trainingsPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conference_id: string
      user_id: number
      registered_at: Date | null
      attended: boolean | null
      attendance_time: Date | null
      notes: string | null
    }, ExtArgs["result"]["conference_attendees"]>
    composites: {}
  }

  type conference_attendeesGetPayload<S extends boolean | null | undefined | conference_attendeesDefaultArgs> = $Result.GetResult<Prisma.$conference_attendeesPayload, S>

  type conference_attendeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conference_attendeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Conference_attendeesCountAggregateInputType | true
    }

  export interface conference_attendeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conference_attendees'], meta: { name: 'conference_attendees' } }
    /**
     * Find zero or one Conference_attendees that matches the filter.
     * @param {conference_attendeesFindUniqueArgs} args - Arguments to find a Conference_attendees
     * @example
     * // Get one Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conference_attendeesFindUniqueArgs>(args: SelectSubset<T, conference_attendeesFindUniqueArgs<ExtArgs>>): Prisma__conference_attendeesClient<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conference_attendees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conference_attendeesFindUniqueOrThrowArgs} args - Arguments to find a Conference_attendees
     * @example
     * // Get one Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conference_attendeesFindUniqueOrThrowArgs>(args: SelectSubset<T, conference_attendeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conference_attendeesClient<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conference_attendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_attendeesFindFirstArgs} args - Arguments to find a Conference_attendees
     * @example
     * // Get one Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conference_attendeesFindFirstArgs>(args?: SelectSubset<T, conference_attendeesFindFirstArgs<ExtArgs>>): Prisma__conference_attendeesClient<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conference_attendees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_attendeesFindFirstOrThrowArgs} args - Arguments to find a Conference_attendees
     * @example
     * // Get one Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conference_attendeesFindFirstOrThrowArgs>(args?: SelectSubset<T, conference_attendeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__conference_attendeesClient<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conference_attendees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_attendeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.findMany()
     * 
     * // Get first 10 Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conference_attendeesWithIdOnly = await prisma.conference_attendees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conference_attendeesFindManyArgs>(args?: SelectSubset<T, conference_attendeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conference_attendees.
     * @param {conference_attendeesCreateArgs} args - Arguments to create a Conference_attendees.
     * @example
     * // Create one Conference_attendees
     * const Conference_attendees = await prisma.conference_attendees.create({
     *   data: {
     *     // ... data to create a Conference_attendees
     *   }
     * })
     * 
     */
    create<T extends conference_attendeesCreateArgs>(args: SelectSubset<T, conference_attendeesCreateArgs<ExtArgs>>): Prisma__conference_attendeesClient<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conference_attendees.
     * @param {conference_attendeesCreateManyArgs} args - Arguments to create many Conference_attendees.
     * @example
     * // Create many Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conference_attendeesCreateManyArgs>(args?: SelectSubset<T, conference_attendeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conference_attendees and returns the data saved in the database.
     * @param {conference_attendeesCreateManyAndReturnArgs} args - Arguments to create many Conference_attendees.
     * @example
     * // Create many Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conference_attendees and only return the `id`
     * const conference_attendeesWithIdOnly = await prisma.conference_attendees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conference_attendeesCreateManyAndReturnArgs>(args?: SelectSubset<T, conference_attendeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conference_attendees.
     * @param {conference_attendeesDeleteArgs} args - Arguments to delete one Conference_attendees.
     * @example
     * // Delete one Conference_attendees
     * const Conference_attendees = await prisma.conference_attendees.delete({
     *   where: {
     *     // ... filter to delete one Conference_attendees
     *   }
     * })
     * 
     */
    delete<T extends conference_attendeesDeleteArgs>(args: SelectSubset<T, conference_attendeesDeleteArgs<ExtArgs>>): Prisma__conference_attendeesClient<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conference_attendees.
     * @param {conference_attendeesUpdateArgs} args - Arguments to update one Conference_attendees.
     * @example
     * // Update one Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conference_attendeesUpdateArgs>(args: SelectSubset<T, conference_attendeesUpdateArgs<ExtArgs>>): Prisma__conference_attendeesClient<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conference_attendees.
     * @param {conference_attendeesDeleteManyArgs} args - Arguments to filter Conference_attendees to delete.
     * @example
     * // Delete a few Conference_attendees
     * const { count } = await prisma.conference_attendees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conference_attendeesDeleteManyArgs>(args?: SelectSubset<T, conference_attendeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conference_attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_attendeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conference_attendeesUpdateManyArgs>(args: SelectSubset<T, conference_attendeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conference_attendees and returns the data updated in the database.
     * @param {conference_attendeesUpdateManyAndReturnArgs} args - Arguments to update many Conference_attendees.
     * @example
     * // Update many Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conference_attendees and only return the `id`
     * const conference_attendeesWithIdOnly = await prisma.conference_attendees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conference_attendeesUpdateManyAndReturnArgs>(args: SelectSubset<T, conference_attendeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conference_attendees.
     * @param {conference_attendeesUpsertArgs} args - Arguments to update or create a Conference_attendees.
     * @example
     * // Update or create a Conference_attendees
     * const conference_attendees = await prisma.conference_attendees.upsert({
     *   create: {
     *     // ... data to create a Conference_attendees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conference_attendees we want to update
     *   }
     * })
     */
    upsert<T extends conference_attendeesUpsertArgs>(args: SelectSubset<T, conference_attendeesUpsertArgs<ExtArgs>>): Prisma__conference_attendeesClient<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conference_attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_attendeesCountArgs} args - Arguments to filter Conference_attendees to count.
     * @example
     * // Count the number of Conference_attendees
     * const count = await prisma.conference_attendees.count({
     *   where: {
     *     // ... the filter for the Conference_attendees we want to count
     *   }
     * })
    **/
    count<T extends conference_attendeesCountArgs>(
      args?: Subset<T, conference_attendeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Conference_attendeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conference_attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Conference_attendeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Conference_attendeesAggregateArgs>(args: Subset<T, Conference_attendeesAggregateArgs>): Prisma.PrismaPromise<GetConference_attendeesAggregateType<T>>

    /**
     * Group by Conference_attendees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_attendeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conference_attendeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conference_attendeesGroupByArgs['orderBy'] }
        : { orderBy?: conference_attendeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conference_attendeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConference_attendeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conference_attendees model
   */
  readonly fields: conference_attendeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conference_attendees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conference_attendeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference_trainings<T extends conference_trainingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, conference_trainingsDefaultArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conference_attendees model
   */
  interface conference_attendeesFieldRefs {
    readonly id: FieldRef<"conference_attendees", 'String'>
    readonly conference_id: FieldRef<"conference_attendees", 'String'>
    readonly user_id: FieldRef<"conference_attendees", 'Int'>
    readonly registered_at: FieldRef<"conference_attendees", 'DateTime'>
    readonly attended: FieldRef<"conference_attendees", 'Boolean'>
    readonly attendance_time: FieldRef<"conference_attendees", 'DateTime'>
    readonly notes: FieldRef<"conference_attendees", 'String'>
  }
    

  // Custom InputTypes
  /**
   * conference_attendees findUnique
   */
  export type conference_attendeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * Filter, which conference_attendees to fetch.
     */
    where: conference_attendeesWhereUniqueInput
  }

  /**
   * conference_attendees findUniqueOrThrow
   */
  export type conference_attendeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * Filter, which conference_attendees to fetch.
     */
    where: conference_attendeesWhereUniqueInput
  }

  /**
   * conference_attendees findFirst
   */
  export type conference_attendeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * Filter, which conference_attendees to fetch.
     */
    where?: conference_attendeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_attendees to fetch.
     */
    orderBy?: conference_attendeesOrderByWithRelationInput | conference_attendeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conference_attendees.
     */
    cursor?: conference_attendeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conference_attendees.
     */
    distinct?: Conference_attendeesScalarFieldEnum | Conference_attendeesScalarFieldEnum[]
  }

  /**
   * conference_attendees findFirstOrThrow
   */
  export type conference_attendeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * Filter, which conference_attendees to fetch.
     */
    where?: conference_attendeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_attendees to fetch.
     */
    orderBy?: conference_attendeesOrderByWithRelationInput | conference_attendeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conference_attendees.
     */
    cursor?: conference_attendeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_attendees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conference_attendees.
     */
    distinct?: Conference_attendeesScalarFieldEnum | Conference_attendeesScalarFieldEnum[]
  }

  /**
   * conference_attendees findMany
   */
  export type conference_attendeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * Filter, which conference_attendees to fetch.
     */
    where?: conference_attendeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_attendees to fetch.
     */
    orderBy?: conference_attendeesOrderByWithRelationInput | conference_attendeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conference_attendees.
     */
    cursor?: conference_attendeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_attendees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_attendees.
     */
    skip?: number
    distinct?: Conference_attendeesScalarFieldEnum | Conference_attendeesScalarFieldEnum[]
  }

  /**
   * conference_attendees create
   */
  export type conference_attendeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * The data needed to create a conference_attendees.
     */
    data: XOR<conference_attendeesCreateInput, conference_attendeesUncheckedCreateInput>
  }

  /**
   * conference_attendees createMany
   */
  export type conference_attendeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conference_attendees.
     */
    data: conference_attendeesCreateManyInput | conference_attendeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conference_attendees createManyAndReturn
   */
  export type conference_attendeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * The data used to create many conference_attendees.
     */
    data: conference_attendeesCreateManyInput | conference_attendeesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * conference_attendees update
   */
  export type conference_attendeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * The data needed to update a conference_attendees.
     */
    data: XOR<conference_attendeesUpdateInput, conference_attendeesUncheckedUpdateInput>
    /**
     * Choose, which conference_attendees to update.
     */
    where: conference_attendeesWhereUniqueInput
  }

  /**
   * conference_attendees updateMany
   */
  export type conference_attendeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conference_attendees.
     */
    data: XOR<conference_attendeesUpdateManyMutationInput, conference_attendeesUncheckedUpdateManyInput>
    /**
     * Filter which conference_attendees to update
     */
    where?: conference_attendeesWhereInput
    /**
     * Limit how many conference_attendees to update.
     */
    limit?: number
  }

  /**
   * conference_attendees updateManyAndReturn
   */
  export type conference_attendeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * The data used to update conference_attendees.
     */
    data: XOR<conference_attendeesUpdateManyMutationInput, conference_attendeesUncheckedUpdateManyInput>
    /**
     * Filter which conference_attendees to update
     */
    where?: conference_attendeesWhereInput
    /**
     * Limit how many conference_attendees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * conference_attendees upsert
   */
  export type conference_attendeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * The filter to search for the conference_attendees to update in case it exists.
     */
    where: conference_attendeesWhereUniqueInput
    /**
     * In case the conference_attendees found by the `where` argument doesn't exist, create a new conference_attendees with this data.
     */
    create: XOR<conference_attendeesCreateInput, conference_attendeesUncheckedCreateInput>
    /**
     * In case the conference_attendees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conference_attendeesUpdateInput, conference_attendeesUncheckedUpdateInput>
  }

  /**
   * conference_attendees delete
   */
  export type conference_attendeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    /**
     * Filter which conference_attendees to delete.
     */
    where: conference_attendeesWhereUniqueInput
  }

  /**
   * conference_attendees deleteMany
   */
  export type conference_attendeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conference_attendees to delete
     */
    where?: conference_attendeesWhereInput
    /**
     * Limit how many conference_attendees to delete.
     */
    limit?: number
  }

  /**
   * conference_attendees without action
   */
  export type conference_attendeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
  }


  /**
   * Model conference_materials
   */

  export type AggregateConference_materials = {
    _count: Conference_materialsCountAggregateOutputType | null
    _min: Conference_materialsMinAggregateOutputType | null
    _max: Conference_materialsMaxAggregateOutputType | null
  }

  export type Conference_materialsMinAggregateOutputType = {
    id: string | null
    conference_id: string | null
    title: string | null
    description: string | null
    file_path: string | null
    link: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Conference_materialsMaxAggregateOutputType = {
    id: string | null
    conference_id: string | null
    title: string | null
    description: string | null
    file_path: string | null
    link: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Conference_materialsCountAggregateOutputType = {
    id: number
    conference_id: number
    title: number
    description: number
    file_path: number
    link: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Conference_materialsMinAggregateInputType = {
    id?: true
    conference_id?: true
    title?: true
    description?: true
    file_path?: true
    link?: true
    created_at?: true
    updated_at?: true
  }

  export type Conference_materialsMaxAggregateInputType = {
    id?: true
    conference_id?: true
    title?: true
    description?: true
    file_path?: true
    link?: true
    created_at?: true
    updated_at?: true
  }

  export type Conference_materialsCountAggregateInputType = {
    id?: true
    conference_id?: true
    title?: true
    description?: true
    file_path?: true
    link?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Conference_materialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conference_materials to aggregate.
     */
    where?: conference_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_materials to fetch.
     */
    orderBy?: conference_materialsOrderByWithRelationInput | conference_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conference_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conference_materials
    **/
    _count?: true | Conference_materialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Conference_materialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Conference_materialsMaxAggregateInputType
  }

  export type GetConference_materialsAggregateType<T extends Conference_materialsAggregateArgs> = {
        [P in keyof T & keyof AggregateConference_materials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConference_materials[P]>
      : GetScalarType<T[P], AggregateConference_materials[P]>
  }




  export type conference_materialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conference_materialsWhereInput
    orderBy?: conference_materialsOrderByWithAggregationInput | conference_materialsOrderByWithAggregationInput[]
    by: Conference_materialsScalarFieldEnum[] | Conference_materialsScalarFieldEnum
    having?: conference_materialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Conference_materialsCountAggregateInputType | true
    _min?: Conference_materialsMinAggregateInputType
    _max?: Conference_materialsMaxAggregateInputType
  }

  export type Conference_materialsGroupByOutputType = {
    id: string
    conference_id: string
    title: string
    description: string | null
    file_path: string | null
    link: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Conference_materialsCountAggregateOutputType | null
    _min: Conference_materialsMinAggregateOutputType | null
    _max: Conference_materialsMaxAggregateOutputType | null
  }

  type GetConference_materialsGroupByPayload<T extends conference_materialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Conference_materialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Conference_materialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Conference_materialsGroupByOutputType[P]>
            : GetScalarType<T[P], Conference_materialsGroupByOutputType[P]>
        }
      >
    >


  export type conference_materialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conference_id?: boolean
    title?: boolean
    description?: boolean
    file_path?: boolean
    link?: boolean
    created_at?: boolean
    updated_at?: boolean
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference_materials"]>

  export type conference_materialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conference_id?: boolean
    title?: boolean
    description?: boolean
    file_path?: boolean
    link?: boolean
    created_at?: boolean
    updated_at?: boolean
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference_materials"]>

  export type conference_materialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conference_id?: boolean
    title?: boolean
    description?: boolean
    file_path?: boolean
    link?: boolean
    created_at?: boolean
    updated_at?: boolean
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference_materials"]>

  export type conference_materialsSelectScalar = {
    id?: boolean
    conference_id?: boolean
    title?: boolean
    description?: boolean
    file_path?: boolean
    link?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type conference_materialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conference_id" | "title" | "description" | "file_path" | "link" | "created_at" | "updated_at", ExtArgs["result"]["conference_materials"]>
  export type conference_materialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
  }
  export type conference_materialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
  }
  export type conference_materialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference_trainings?: boolean | conference_trainingsDefaultArgs<ExtArgs>
  }

  export type $conference_materialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conference_materials"
    objects: {
      conference_trainings: Prisma.$conference_trainingsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conference_id: string
      title: string
      description: string | null
      file_path: string | null
      link: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["conference_materials"]>
    composites: {}
  }

  type conference_materialsGetPayload<S extends boolean | null | undefined | conference_materialsDefaultArgs> = $Result.GetResult<Prisma.$conference_materialsPayload, S>

  type conference_materialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conference_materialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Conference_materialsCountAggregateInputType | true
    }

  export interface conference_materialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conference_materials'], meta: { name: 'conference_materials' } }
    /**
     * Find zero or one Conference_materials that matches the filter.
     * @param {conference_materialsFindUniqueArgs} args - Arguments to find a Conference_materials
     * @example
     * // Get one Conference_materials
     * const conference_materials = await prisma.conference_materials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conference_materialsFindUniqueArgs>(args: SelectSubset<T, conference_materialsFindUniqueArgs<ExtArgs>>): Prisma__conference_materialsClient<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conference_materials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conference_materialsFindUniqueOrThrowArgs} args - Arguments to find a Conference_materials
     * @example
     * // Get one Conference_materials
     * const conference_materials = await prisma.conference_materials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conference_materialsFindUniqueOrThrowArgs>(args: SelectSubset<T, conference_materialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conference_materialsClient<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conference_materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_materialsFindFirstArgs} args - Arguments to find a Conference_materials
     * @example
     * // Get one Conference_materials
     * const conference_materials = await prisma.conference_materials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conference_materialsFindFirstArgs>(args?: SelectSubset<T, conference_materialsFindFirstArgs<ExtArgs>>): Prisma__conference_materialsClient<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conference_materials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_materialsFindFirstOrThrowArgs} args - Arguments to find a Conference_materials
     * @example
     * // Get one Conference_materials
     * const conference_materials = await prisma.conference_materials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conference_materialsFindFirstOrThrowArgs>(args?: SelectSubset<T, conference_materialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__conference_materialsClient<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conference_materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_materialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conference_materials
     * const conference_materials = await prisma.conference_materials.findMany()
     * 
     * // Get first 10 Conference_materials
     * const conference_materials = await prisma.conference_materials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conference_materialsWithIdOnly = await prisma.conference_materials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conference_materialsFindManyArgs>(args?: SelectSubset<T, conference_materialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conference_materials.
     * @param {conference_materialsCreateArgs} args - Arguments to create a Conference_materials.
     * @example
     * // Create one Conference_materials
     * const Conference_materials = await prisma.conference_materials.create({
     *   data: {
     *     // ... data to create a Conference_materials
     *   }
     * })
     * 
     */
    create<T extends conference_materialsCreateArgs>(args: SelectSubset<T, conference_materialsCreateArgs<ExtArgs>>): Prisma__conference_materialsClient<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conference_materials.
     * @param {conference_materialsCreateManyArgs} args - Arguments to create many Conference_materials.
     * @example
     * // Create many Conference_materials
     * const conference_materials = await prisma.conference_materials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conference_materialsCreateManyArgs>(args?: SelectSubset<T, conference_materialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conference_materials and returns the data saved in the database.
     * @param {conference_materialsCreateManyAndReturnArgs} args - Arguments to create many Conference_materials.
     * @example
     * // Create many Conference_materials
     * const conference_materials = await prisma.conference_materials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conference_materials and only return the `id`
     * const conference_materialsWithIdOnly = await prisma.conference_materials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conference_materialsCreateManyAndReturnArgs>(args?: SelectSubset<T, conference_materialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conference_materials.
     * @param {conference_materialsDeleteArgs} args - Arguments to delete one Conference_materials.
     * @example
     * // Delete one Conference_materials
     * const Conference_materials = await prisma.conference_materials.delete({
     *   where: {
     *     // ... filter to delete one Conference_materials
     *   }
     * })
     * 
     */
    delete<T extends conference_materialsDeleteArgs>(args: SelectSubset<T, conference_materialsDeleteArgs<ExtArgs>>): Prisma__conference_materialsClient<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conference_materials.
     * @param {conference_materialsUpdateArgs} args - Arguments to update one Conference_materials.
     * @example
     * // Update one Conference_materials
     * const conference_materials = await prisma.conference_materials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conference_materialsUpdateArgs>(args: SelectSubset<T, conference_materialsUpdateArgs<ExtArgs>>): Prisma__conference_materialsClient<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conference_materials.
     * @param {conference_materialsDeleteManyArgs} args - Arguments to filter Conference_materials to delete.
     * @example
     * // Delete a few Conference_materials
     * const { count } = await prisma.conference_materials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conference_materialsDeleteManyArgs>(args?: SelectSubset<T, conference_materialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conference_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_materialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conference_materials
     * const conference_materials = await prisma.conference_materials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conference_materialsUpdateManyArgs>(args: SelectSubset<T, conference_materialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conference_materials and returns the data updated in the database.
     * @param {conference_materialsUpdateManyAndReturnArgs} args - Arguments to update many Conference_materials.
     * @example
     * // Update many Conference_materials
     * const conference_materials = await prisma.conference_materials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conference_materials and only return the `id`
     * const conference_materialsWithIdOnly = await prisma.conference_materials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conference_materialsUpdateManyAndReturnArgs>(args: SelectSubset<T, conference_materialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conference_materials.
     * @param {conference_materialsUpsertArgs} args - Arguments to update or create a Conference_materials.
     * @example
     * // Update or create a Conference_materials
     * const conference_materials = await prisma.conference_materials.upsert({
     *   create: {
     *     // ... data to create a Conference_materials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conference_materials we want to update
     *   }
     * })
     */
    upsert<T extends conference_materialsUpsertArgs>(args: SelectSubset<T, conference_materialsUpsertArgs<ExtArgs>>): Prisma__conference_materialsClient<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conference_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_materialsCountArgs} args - Arguments to filter Conference_materials to count.
     * @example
     * // Count the number of Conference_materials
     * const count = await prisma.conference_materials.count({
     *   where: {
     *     // ... the filter for the Conference_materials we want to count
     *   }
     * })
    **/
    count<T extends conference_materialsCountArgs>(
      args?: Subset<T, conference_materialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Conference_materialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conference_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Conference_materialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Conference_materialsAggregateArgs>(args: Subset<T, Conference_materialsAggregateArgs>): Prisma.PrismaPromise<GetConference_materialsAggregateType<T>>

    /**
     * Group by Conference_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_materialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conference_materialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conference_materialsGroupByArgs['orderBy'] }
        : { orderBy?: conference_materialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conference_materialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConference_materialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conference_materials model
   */
  readonly fields: conference_materialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conference_materials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conference_materialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference_trainings<T extends conference_trainingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, conference_trainingsDefaultArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conference_materials model
   */
  interface conference_materialsFieldRefs {
    readonly id: FieldRef<"conference_materials", 'String'>
    readonly conference_id: FieldRef<"conference_materials", 'String'>
    readonly title: FieldRef<"conference_materials", 'String'>
    readonly description: FieldRef<"conference_materials", 'String'>
    readonly file_path: FieldRef<"conference_materials", 'String'>
    readonly link: FieldRef<"conference_materials", 'String'>
    readonly created_at: FieldRef<"conference_materials", 'DateTime'>
    readonly updated_at: FieldRef<"conference_materials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conference_materials findUnique
   */
  export type conference_materialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * Filter, which conference_materials to fetch.
     */
    where: conference_materialsWhereUniqueInput
  }

  /**
   * conference_materials findUniqueOrThrow
   */
  export type conference_materialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * Filter, which conference_materials to fetch.
     */
    where: conference_materialsWhereUniqueInput
  }

  /**
   * conference_materials findFirst
   */
  export type conference_materialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * Filter, which conference_materials to fetch.
     */
    where?: conference_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_materials to fetch.
     */
    orderBy?: conference_materialsOrderByWithRelationInput | conference_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conference_materials.
     */
    cursor?: conference_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conference_materials.
     */
    distinct?: Conference_materialsScalarFieldEnum | Conference_materialsScalarFieldEnum[]
  }

  /**
   * conference_materials findFirstOrThrow
   */
  export type conference_materialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * Filter, which conference_materials to fetch.
     */
    where?: conference_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_materials to fetch.
     */
    orderBy?: conference_materialsOrderByWithRelationInput | conference_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conference_materials.
     */
    cursor?: conference_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conference_materials.
     */
    distinct?: Conference_materialsScalarFieldEnum | Conference_materialsScalarFieldEnum[]
  }

  /**
   * conference_materials findMany
   */
  export type conference_materialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * Filter, which conference_materials to fetch.
     */
    where?: conference_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_materials to fetch.
     */
    orderBy?: conference_materialsOrderByWithRelationInput | conference_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conference_materials.
     */
    cursor?: conference_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_materials.
     */
    skip?: number
    distinct?: Conference_materialsScalarFieldEnum | Conference_materialsScalarFieldEnum[]
  }

  /**
   * conference_materials create
   */
  export type conference_materialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * The data needed to create a conference_materials.
     */
    data: XOR<conference_materialsCreateInput, conference_materialsUncheckedCreateInput>
  }

  /**
   * conference_materials createMany
   */
  export type conference_materialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conference_materials.
     */
    data: conference_materialsCreateManyInput | conference_materialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conference_materials createManyAndReturn
   */
  export type conference_materialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * The data used to create many conference_materials.
     */
    data: conference_materialsCreateManyInput | conference_materialsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * conference_materials update
   */
  export type conference_materialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * The data needed to update a conference_materials.
     */
    data: XOR<conference_materialsUpdateInput, conference_materialsUncheckedUpdateInput>
    /**
     * Choose, which conference_materials to update.
     */
    where: conference_materialsWhereUniqueInput
  }

  /**
   * conference_materials updateMany
   */
  export type conference_materialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conference_materials.
     */
    data: XOR<conference_materialsUpdateManyMutationInput, conference_materialsUncheckedUpdateManyInput>
    /**
     * Filter which conference_materials to update
     */
    where?: conference_materialsWhereInput
    /**
     * Limit how many conference_materials to update.
     */
    limit?: number
  }

  /**
   * conference_materials updateManyAndReturn
   */
  export type conference_materialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * The data used to update conference_materials.
     */
    data: XOR<conference_materialsUpdateManyMutationInput, conference_materialsUncheckedUpdateManyInput>
    /**
     * Filter which conference_materials to update
     */
    where?: conference_materialsWhereInput
    /**
     * Limit how many conference_materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * conference_materials upsert
   */
  export type conference_materialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * The filter to search for the conference_materials to update in case it exists.
     */
    where: conference_materialsWhereUniqueInput
    /**
     * In case the conference_materials found by the `where` argument doesn't exist, create a new conference_materials with this data.
     */
    create: XOR<conference_materialsCreateInput, conference_materialsUncheckedCreateInput>
    /**
     * In case the conference_materials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conference_materialsUpdateInput, conference_materialsUncheckedUpdateInput>
  }

  /**
   * conference_materials delete
   */
  export type conference_materialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    /**
     * Filter which conference_materials to delete.
     */
    where: conference_materialsWhereUniqueInput
  }

  /**
   * conference_materials deleteMany
   */
  export type conference_materialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conference_materials to delete
     */
    where?: conference_materialsWhereInput
    /**
     * Limit how many conference_materials to delete.
     */
    limit?: number
  }

  /**
   * conference_materials without action
   */
  export type conference_materialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
  }


  /**
   * Model conference_trainings
   */

  export type AggregateConference_trainings = {
    _count: Conference_trainingsCountAggregateOutputType | null
    _avg: Conference_trainingsAvgAggregateOutputType | null
    _sum: Conference_trainingsSumAggregateOutputType | null
    _min: Conference_trainingsMinAggregateOutputType | null
    _max: Conference_trainingsMaxAggregateOutputType | null
  }

  export type Conference_trainingsAvgAggregateOutputType = {
    capacity: number | null
  }

  export type Conference_trainingsSumAggregateOutputType = {
    capacity: number | null
  }

  export type Conference_trainingsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    location: string | null
    start_date: Date | null
    end_date: Date | null
    capacity: number | null
    author: string | null
    published: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Conference_trainingsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    location: string | null
    start_date: Date | null
    end_date: Date | null
    capacity: number | null
    author: string | null
    published: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Conference_trainingsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    location: number
    start_date: number
    end_date: number
    capacity: number
    author: number
    published: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Conference_trainingsAvgAggregateInputType = {
    capacity?: true
  }

  export type Conference_trainingsSumAggregateInputType = {
    capacity?: true
  }

  export type Conference_trainingsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    location?: true
    start_date?: true
    end_date?: true
    capacity?: true
    author?: true
    published?: true
    created_at?: true
    updated_at?: true
  }

  export type Conference_trainingsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    location?: true
    start_date?: true
    end_date?: true
    capacity?: true
    author?: true
    published?: true
    created_at?: true
    updated_at?: true
  }

  export type Conference_trainingsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    location?: true
    start_date?: true
    end_date?: true
    capacity?: true
    author?: true
    published?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Conference_trainingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conference_trainings to aggregate.
     */
    where?: conference_trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_trainings to fetch.
     */
    orderBy?: conference_trainingsOrderByWithRelationInput | conference_trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conference_trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conference_trainings
    **/
    _count?: true | Conference_trainingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Conference_trainingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Conference_trainingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Conference_trainingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Conference_trainingsMaxAggregateInputType
  }

  export type GetConference_trainingsAggregateType<T extends Conference_trainingsAggregateArgs> = {
        [P in keyof T & keyof AggregateConference_trainings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConference_trainings[P]>
      : GetScalarType<T[P], AggregateConference_trainings[P]>
  }




  export type conference_trainingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conference_trainingsWhereInput
    orderBy?: conference_trainingsOrderByWithAggregationInput | conference_trainingsOrderByWithAggregationInput[]
    by: Conference_trainingsScalarFieldEnum[] | Conference_trainingsScalarFieldEnum
    having?: conference_trainingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Conference_trainingsCountAggregateInputType | true
    _avg?: Conference_trainingsAvgAggregateInputType
    _sum?: Conference_trainingsSumAggregateInputType
    _min?: Conference_trainingsMinAggregateInputType
    _max?: Conference_trainingsMaxAggregateInputType
  }

  export type Conference_trainingsGroupByOutputType = {
    id: string
    title: string
    description: string | null
    category: string | null
    location: string
    start_date: Date
    end_date: Date
    capacity: number | null
    author: string | null
    published: boolean | null
    created_at: Date | null
    updated_at: Date | null
    _count: Conference_trainingsCountAggregateOutputType | null
    _avg: Conference_trainingsAvgAggregateOutputType | null
    _sum: Conference_trainingsSumAggregateOutputType | null
    _min: Conference_trainingsMinAggregateOutputType | null
    _max: Conference_trainingsMaxAggregateOutputType | null
  }

  type GetConference_trainingsGroupByPayload<T extends conference_trainingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Conference_trainingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Conference_trainingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Conference_trainingsGroupByOutputType[P]>
            : GetScalarType<T[P], Conference_trainingsGroupByOutputType[P]>
        }
      >
    >


  export type conference_trainingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    capacity?: boolean
    author?: boolean
    published?: boolean
    created_at?: boolean
    updated_at?: boolean
    conference_attendees?: boolean | conference_trainings$conference_attendeesArgs<ExtArgs>
    conference_materials?: boolean | conference_trainings$conference_materialsArgs<ExtArgs>
    _count?: boolean | Conference_trainingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conference_trainings"]>

  export type conference_trainingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    capacity?: boolean
    author?: boolean
    published?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["conference_trainings"]>

  export type conference_trainingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    capacity?: boolean
    author?: boolean
    published?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["conference_trainings"]>

  export type conference_trainingsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    location?: boolean
    start_date?: boolean
    end_date?: boolean
    capacity?: boolean
    author?: boolean
    published?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type conference_trainingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "location" | "start_date" | "end_date" | "capacity" | "author" | "published" | "created_at" | "updated_at", ExtArgs["result"]["conference_trainings"]>
  export type conference_trainingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conference_attendees?: boolean | conference_trainings$conference_attendeesArgs<ExtArgs>
    conference_materials?: boolean | conference_trainings$conference_materialsArgs<ExtArgs>
    _count?: boolean | Conference_trainingsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type conference_trainingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type conference_trainingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $conference_trainingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conference_trainings"
    objects: {
      conference_attendees: Prisma.$conference_attendeesPayload<ExtArgs>[]
      conference_materials: Prisma.$conference_materialsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      category: string | null
      location: string
      start_date: Date
      end_date: Date
      capacity: number | null
      author: string | null
      published: boolean | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["conference_trainings"]>
    composites: {}
  }

  type conference_trainingsGetPayload<S extends boolean | null | undefined | conference_trainingsDefaultArgs> = $Result.GetResult<Prisma.$conference_trainingsPayload, S>

  type conference_trainingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conference_trainingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Conference_trainingsCountAggregateInputType | true
    }

  export interface conference_trainingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conference_trainings'], meta: { name: 'conference_trainings' } }
    /**
     * Find zero or one Conference_trainings that matches the filter.
     * @param {conference_trainingsFindUniqueArgs} args - Arguments to find a Conference_trainings
     * @example
     * // Get one Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conference_trainingsFindUniqueArgs>(args: SelectSubset<T, conference_trainingsFindUniqueArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conference_trainings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conference_trainingsFindUniqueOrThrowArgs} args - Arguments to find a Conference_trainings
     * @example
     * // Get one Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conference_trainingsFindUniqueOrThrowArgs>(args: SelectSubset<T, conference_trainingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conference_trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_trainingsFindFirstArgs} args - Arguments to find a Conference_trainings
     * @example
     * // Get one Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conference_trainingsFindFirstArgs>(args?: SelectSubset<T, conference_trainingsFindFirstArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conference_trainings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_trainingsFindFirstOrThrowArgs} args - Arguments to find a Conference_trainings
     * @example
     * // Get one Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conference_trainingsFindFirstOrThrowArgs>(args?: SelectSubset<T, conference_trainingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conference_trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_trainingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.findMany()
     * 
     * // Get first 10 Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conference_trainingsWithIdOnly = await prisma.conference_trainings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conference_trainingsFindManyArgs>(args?: SelectSubset<T, conference_trainingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conference_trainings.
     * @param {conference_trainingsCreateArgs} args - Arguments to create a Conference_trainings.
     * @example
     * // Create one Conference_trainings
     * const Conference_trainings = await prisma.conference_trainings.create({
     *   data: {
     *     // ... data to create a Conference_trainings
     *   }
     * })
     * 
     */
    create<T extends conference_trainingsCreateArgs>(args: SelectSubset<T, conference_trainingsCreateArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conference_trainings.
     * @param {conference_trainingsCreateManyArgs} args - Arguments to create many Conference_trainings.
     * @example
     * // Create many Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conference_trainingsCreateManyArgs>(args?: SelectSubset<T, conference_trainingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conference_trainings and returns the data saved in the database.
     * @param {conference_trainingsCreateManyAndReturnArgs} args - Arguments to create many Conference_trainings.
     * @example
     * // Create many Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conference_trainings and only return the `id`
     * const conference_trainingsWithIdOnly = await prisma.conference_trainings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conference_trainingsCreateManyAndReturnArgs>(args?: SelectSubset<T, conference_trainingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conference_trainings.
     * @param {conference_trainingsDeleteArgs} args - Arguments to delete one Conference_trainings.
     * @example
     * // Delete one Conference_trainings
     * const Conference_trainings = await prisma.conference_trainings.delete({
     *   where: {
     *     // ... filter to delete one Conference_trainings
     *   }
     * })
     * 
     */
    delete<T extends conference_trainingsDeleteArgs>(args: SelectSubset<T, conference_trainingsDeleteArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conference_trainings.
     * @param {conference_trainingsUpdateArgs} args - Arguments to update one Conference_trainings.
     * @example
     * // Update one Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conference_trainingsUpdateArgs>(args: SelectSubset<T, conference_trainingsUpdateArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conference_trainings.
     * @param {conference_trainingsDeleteManyArgs} args - Arguments to filter Conference_trainings to delete.
     * @example
     * // Delete a few Conference_trainings
     * const { count } = await prisma.conference_trainings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conference_trainingsDeleteManyArgs>(args?: SelectSubset<T, conference_trainingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conference_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_trainingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conference_trainingsUpdateManyArgs>(args: SelectSubset<T, conference_trainingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conference_trainings and returns the data updated in the database.
     * @param {conference_trainingsUpdateManyAndReturnArgs} args - Arguments to update many Conference_trainings.
     * @example
     * // Update many Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conference_trainings and only return the `id`
     * const conference_trainingsWithIdOnly = await prisma.conference_trainings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conference_trainingsUpdateManyAndReturnArgs>(args: SelectSubset<T, conference_trainingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conference_trainings.
     * @param {conference_trainingsUpsertArgs} args - Arguments to update or create a Conference_trainings.
     * @example
     * // Update or create a Conference_trainings
     * const conference_trainings = await prisma.conference_trainings.upsert({
     *   create: {
     *     // ... data to create a Conference_trainings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conference_trainings we want to update
     *   }
     * })
     */
    upsert<T extends conference_trainingsUpsertArgs>(args: SelectSubset<T, conference_trainingsUpsertArgs<ExtArgs>>): Prisma__conference_trainingsClient<$Result.GetResult<Prisma.$conference_trainingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conference_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_trainingsCountArgs} args - Arguments to filter Conference_trainings to count.
     * @example
     * // Count the number of Conference_trainings
     * const count = await prisma.conference_trainings.count({
     *   where: {
     *     // ... the filter for the Conference_trainings we want to count
     *   }
     * })
    **/
    count<T extends conference_trainingsCountArgs>(
      args?: Subset<T, conference_trainingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Conference_trainingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conference_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Conference_trainingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Conference_trainingsAggregateArgs>(args: Subset<T, Conference_trainingsAggregateArgs>): Prisma.PrismaPromise<GetConference_trainingsAggregateType<T>>

    /**
     * Group by Conference_trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conference_trainingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conference_trainingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conference_trainingsGroupByArgs['orderBy'] }
        : { orderBy?: conference_trainingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conference_trainingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConference_trainingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conference_trainings model
   */
  readonly fields: conference_trainingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conference_trainings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conference_trainingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conference_attendees<T extends conference_trainings$conference_attendeesArgs<ExtArgs> = {}>(args?: Subset<T, conference_trainings$conference_attendeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_attendeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conference_materials<T extends conference_trainings$conference_materialsArgs<ExtArgs> = {}>(args?: Subset<T, conference_trainings$conference_materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conference_materialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conference_trainings model
   */
  interface conference_trainingsFieldRefs {
    readonly id: FieldRef<"conference_trainings", 'String'>
    readonly title: FieldRef<"conference_trainings", 'String'>
    readonly description: FieldRef<"conference_trainings", 'String'>
    readonly category: FieldRef<"conference_trainings", 'String'>
    readonly location: FieldRef<"conference_trainings", 'String'>
    readonly start_date: FieldRef<"conference_trainings", 'DateTime'>
    readonly end_date: FieldRef<"conference_trainings", 'DateTime'>
    readonly capacity: FieldRef<"conference_trainings", 'Int'>
    readonly author: FieldRef<"conference_trainings", 'String'>
    readonly published: FieldRef<"conference_trainings", 'Boolean'>
    readonly created_at: FieldRef<"conference_trainings", 'DateTime'>
    readonly updated_at: FieldRef<"conference_trainings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conference_trainings findUnique
   */
  export type conference_trainingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which conference_trainings to fetch.
     */
    where: conference_trainingsWhereUniqueInput
  }

  /**
   * conference_trainings findUniqueOrThrow
   */
  export type conference_trainingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which conference_trainings to fetch.
     */
    where: conference_trainingsWhereUniqueInput
  }

  /**
   * conference_trainings findFirst
   */
  export type conference_trainingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which conference_trainings to fetch.
     */
    where?: conference_trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_trainings to fetch.
     */
    orderBy?: conference_trainingsOrderByWithRelationInput | conference_trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conference_trainings.
     */
    cursor?: conference_trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conference_trainings.
     */
    distinct?: Conference_trainingsScalarFieldEnum | Conference_trainingsScalarFieldEnum[]
  }

  /**
   * conference_trainings findFirstOrThrow
   */
  export type conference_trainingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which conference_trainings to fetch.
     */
    where?: conference_trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_trainings to fetch.
     */
    orderBy?: conference_trainingsOrderByWithRelationInput | conference_trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conference_trainings.
     */
    cursor?: conference_trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conference_trainings.
     */
    distinct?: Conference_trainingsScalarFieldEnum | Conference_trainingsScalarFieldEnum[]
  }

  /**
   * conference_trainings findMany
   */
  export type conference_trainingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * Filter, which conference_trainings to fetch.
     */
    where?: conference_trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conference_trainings to fetch.
     */
    orderBy?: conference_trainingsOrderByWithRelationInput | conference_trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conference_trainings.
     */
    cursor?: conference_trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conference_trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conference_trainings.
     */
    skip?: number
    distinct?: Conference_trainingsScalarFieldEnum | Conference_trainingsScalarFieldEnum[]
  }

  /**
   * conference_trainings create
   */
  export type conference_trainingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * The data needed to create a conference_trainings.
     */
    data: XOR<conference_trainingsCreateInput, conference_trainingsUncheckedCreateInput>
  }

  /**
   * conference_trainings createMany
   */
  export type conference_trainingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conference_trainings.
     */
    data: conference_trainingsCreateManyInput | conference_trainingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conference_trainings createManyAndReturn
   */
  export type conference_trainingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * The data used to create many conference_trainings.
     */
    data: conference_trainingsCreateManyInput | conference_trainingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conference_trainings update
   */
  export type conference_trainingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * The data needed to update a conference_trainings.
     */
    data: XOR<conference_trainingsUpdateInput, conference_trainingsUncheckedUpdateInput>
    /**
     * Choose, which conference_trainings to update.
     */
    where: conference_trainingsWhereUniqueInput
  }

  /**
   * conference_trainings updateMany
   */
  export type conference_trainingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conference_trainings.
     */
    data: XOR<conference_trainingsUpdateManyMutationInput, conference_trainingsUncheckedUpdateManyInput>
    /**
     * Filter which conference_trainings to update
     */
    where?: conference_trainingsWhereInput
    /**
     * Limit how many conference_trainings to update.
     */
    limit?: number
  }

  /**
   * conference_trainings updateManyAndReturn
   */
  export type conference_trainingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * The data used to update conference_trainings.
     */
    data: XOR<conference_trainingsUpdateManyMutationInput, conference_trainingsUncheckedUpdateManyInput>
    /**
     * Filter which conference_trainings to update
     */
    where?: conference_trainingsWhereInput
    /**
     * Limit how many conference_trainings to update.
     */
    limit?: number
  }

  /**
   * conference_trainings upsert
   */
  export type conference_trainingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * The filter to search for the conference_trainings to update in case it exists.
     */
    where: conference_trainingsWhereUniqueInput
    /**
     * In case the conference_trainings found by the `where` argument doesn't exist, create a new conference_trainings with this data.
     */
    create: XOR<conference_trainingsCreateInput, conference_trainingsUncheckedCreateInput>
    /**
     * In case the conference_trainings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conference_trainingsUpdateInput, conference_trainingsUncheckedUpdateInput>
  }

  /**
   * conference_trainings delete
   */
  export type conference_trainingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
    /**
     * Filter which conference_trainings to delete.
     */
    where: conference_trainingsWhereUniqueInput
  }

  /**
   * conference_trainings deleteMany
   */
  export type conference_trainingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conference_trainings to delete
     */
    where?: conference_trainingsWhereInput
    /**
     * Limit how many conference_trainings to delete.
     */
    limit?: number
  }

  /**
   * conference_trainings.conference_attendees
   */
  export type conference_trainings$conference_attendeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_attendees
     */
    select?: conference_attendeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_attendees
     */
    omit?: conference_attendeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_attendeesInclude<ExtArgs> | null
    where?: conference_attendeesWhereInput
    orderBy?: conference_attendeesOrderByWithRelationInput | conference_attendeesOrderByWithRelationInput[]
    cursor?: conference_attendeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Conference_attendeesScalarFieldEnum | Conference_attendeesScalarFieldEnum[]
  }

  /**
   * conference_trainings.conference_materials
   */
  export type conference_trainings$conference_materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_materials
     */
    select?: conference_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_materials
     */
    omit?: conference_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_materialsInclude<ExtArgs> | null
    where?: conference_materialsWhereInput
    orderBy?: conference_materialsOrderByWithRelationInput | conference_materialsOrderByWithRelationInput[]
    cursor?: conference_materialsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Conference_materialsScalarFieldEnum | Conference_materialsScalarFieldEnum[]
  }

  /**
   * conference_trainings without action
   */
  export type conference_trainingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conference_trainings
     */
    select?: conference_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conference_trainings
     */
    omit?: conference_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conference_trainingsInclude<ExtArgs> | null
  }


  /**
   * Model enrollments
   */

  export type AggregateEnrollments = {
    _count: EnrollmentsCountAggregateOutputType | null
    _avg: EnrollmentsAvgAggregateOutputType | null
    _sum: EnrollmentsSumAggregateOutputType | null
    _min: EnrollmentsMinAggregateOutputType | null
    _max: EnrollmentsMaxAggregateOutputType | null
  }

  export type EnrollmentsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    progress: number | null
    score: Decimal | null
  }

  export type EnrollmentsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    progress: number | null
    score: Decimal | null
  }

  export type EnrollmentsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    training_id: string | null
    status: string | null
    progress: number | null
    score: Decimal | null
    start_date: Date | null
    completed_at: Date | null
    last_accessed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EnrollmentsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    training_id: string | null
    status: string | null
    progress: number | null
    score: Decimal | null
    start_date: Date | null
    completed_at: Date | null
    last_accessed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EnrollmentsCountAggregateOutputType = {
    id: number
    user_id: number
    training_id: number
    status: number
    progress: number
    completed_items: number
    score: number
    start_date: number
    completed_at: number
    last_accessed_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EnrollmentsAvgAggregateInputType = {
    id?: true
    user_id?: true
    progress?: true
    score?: true
  }

  export type EnrollmentsSumAggregateInputType = {
    id?: true
    user_id?: true
    progress?: true
    score?: true
  }

  export type EnrollmentsMinAggregateInputType = {
    id?: true
    user_id?: true
    training_id?: true
    status?: true
    progress?: true
    score?: true
    start_date?: true
    completed_at?: true
    last_accessed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type EnrollmentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    training_id?: true
    status?: true
    progress?: true
    score?: true
    start_date?: true
    completed_at?: true
    last_accessed_at?: true
    created_at?: true
    updated_at?: true
  }

  export type EnrollmentsCountAggregateInputType = {
    id?: true
    user_id?: true
    training_id?: true
    status?: true
    progress?: true
    completed_items?: true
    score?: true
    start_date?: true
    completed_at?: true
    last_accessed_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EnrollmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrollments to aggregate.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned enrollments
    **/
    _count?: true | EnrollmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentsMaxAggregateInputType
  }

  export type GetEnrollmentsAggregateType<T extends EnrollmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollments[P]>
      : GetScalarType<T[P], AggregateEnrollments[P]>
  }




  export type enrollmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithAggregationInput | enrollmentsOrderByWithAggregationInput[]
    by: EnrollmentsScalarFieldEnum[] | EnrollmentsScalarFieldEnum
    having?: enrollmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentsCountAggregateInputType | true
    _avg?: EnrollmentsAvgAggregateInputType
    _sum?: EnrollmentsSumAggregateInputType
    _min?: EnrollmentsMinAggregateInputType
    _max?: EnrollmentsMaxAggregateInputType
  }

  export type EnrollmentsGroupByOutputType = {
    id: number
    user_id: number
    training_id: string
    status: string
    progress: number
    completed_items: JsonValue | null
    score: Decimal | null
    start_date: Date | null
    completed_at: Date | null
    last_accessed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: EnrollmentsCountAggregateOutputType | null
    _avg: EnrollmentsAvgAggregateOutputType | null
    _sum: EnrollmentsSumAggregateOutputType | null
    _min: EnrollmentsMinAggregateOutputType | null
    _max: EnrollmentsMaxAggregateOutputType | null
  }

  type GetEnrollmentsGroupByPayload<T extends enrollmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentsGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentsGroupByOutputType[P]>
        }
      >
    >


  export type enrollmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    training_id?: boolean
    status?: boolean
    progress?: boolean
    completed_items?: boolean
    score?: boolean
    start_date?: boolean
    completed_at?: boolean
    last_accessed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    training_id?: boolean
    status?: boolean
    progress?: boolean
    completed_items?: boolean
    score?: boolean
    start_date?: boolean
    completed_at?: boolean
    last_accessed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    training_id?: boolean
    status?: boolean
    progress?: boolean
    completed_items?: boolean
    score?: boolean
    start_date?: boolean
    completed_at?: boolean
    last_accessed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    training_id?: boolean
    status?: boolean
    progress?: boolean
    completed_items?: boolean
    score?: boolean
    start_date?: boolean
    completed_at?: boolean
    last_accessed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type enrollmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "training_id" | "status" | "progress" | "completed_items" | "score" | "start_date" | "completed_at" | "last_accessed_at" | "created_at" | "updated_at", ExtArgs["result"]["enrollments"]>
  export type enrollmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type enrollmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type enrollmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $enrollmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "enrollments"
    objects: {
      trainings: Prisma.$trainingsPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      training_id: string
      status: string
      progress: number
      completed_items: Prisma.JsonValue | null
      score: Prisma.Decimal | null
      start_date: Date | null
      completed_at: Date | null
      last_accessed_at: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["enrollments"]>
    composites: {}
  }

  type enrollmentsGetPayload<S extends boolean | null | undefined | enrollmentsDefaultArgs> = $Result.GetResult<Prisma.$enrollmentsPayload, S>

  type enrollmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<enrollmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentsCountAggregateInputType | true
    }

  export interface enrollmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['enrollments'], meta: { name: 'enrollments' } }
    /**
     * Find zero or one Enrollments that matches the filter.
     * @param {enrollmentsFindUniqueArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends enrollmentsFindUniqueArgs>(args: SelectSubset<T, enrollmentsFindUniqueArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {enrollmentsFindUniqueOrThrowArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends enrollmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, enrollmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindFirstArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends enrollmentsFindFirstArgs>(args?: SelectSubset<T, enrollmentsFindFirstArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindFirstOrThrowArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends enrollmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, enrollmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollments.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends enrollmentsFindManyArgs>(args?: SelectSubset<T, enrollmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollments.
     * @param {enrollmentsCreateArgs} args - Arguments to create a Enrollments.
     * @example
     * // Create one Enrollments
     * const Enrollments = await prisma.enrollments.create({
     *   data: {
     *     // ... data to create a Enrollments
     *   }
     * })
     * 
     */
    create<T extends enrollmentsCreateArgs>(args: SelectSubset<T, enrollmentsCreateArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {enrollmentsCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollments = await prisma.enrollments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends enrollmentsCreateManyArgs>(args?: SelectSubset<T, enrollmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {enrollmentsCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollments = await prisma.enrollments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends enrollmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, enrollmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollments.
     * @param {enrollmentsDeleteArgs} args - Arguments to delete one Enrollments.
     * @example
     * // Delete one Enrollments
     * const Enrollments = await prisma.enrollments.delete({
     *   where: {
     *     // ... filter to delete one Enrollments
     *   }
     * })
     * 
     */
    delete<T extends enrollmentsDeleteArgs>(args: SelectSubset<T, enrollmentsDeleteArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollments.
     * @param {enrollmentsUpdateArgs} args - Arguments to update one Enrollments.
     * @example
     * // Update one Enrollments
     * const enrollments = await prisma.enrollments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends enrollmentsUpdateArgs>(args: SelectSubset<T, enrollmentsUpdateArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {enrollmentsDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends enrollmentsDeleteManyArgs>(args?: SelectSubset<T, enrollmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollments = await prisma.enrollments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends enrollmentsUpdateManyArgs>(args: SelectSubset<T, enrollmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {enrollmentsUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollments = await prisma.enrollments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends enrollmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, enrollmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollments.
     * @param {enrollmentsUpsertArgs} args - Arguments to update or create a Enrollments.
     * @example
     * // Update or create a Enrollments
     * const enrollments = await prisma.enrollments.upsert({
     *   create: {
     *     // ... data to create a Enrollments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollments we want to update
     *   }
     * })
     */
    upsert<T extends enrollmentsUpsertArgs>(args: SelectSubset<T, enrollmentsUpsertArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollments.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends enrollmentsCountArgs>(
      args?: Subset<T, enrollmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentsAggregateArgs>(args: Subset<T, EnrollmentsAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentsAggregateType<T>>

    /**
     * Group by Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends enrollmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: enrollmentsGroupByArgs['orderBy'] }
        : { orderBy?: enrollmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, enrollmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the enrollments model
   */
  readonly fields: enrollmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for enrollments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__enrollmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainings<T extends trainingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, trainingsDefaultArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the enrollments model
   */
  interface enrollmentsFieldRefs {
    readonly id: FieldRef<"enrollments", 'Int'>
    readonly user_id: FieldRef<"enrollments", 'Int'>
    readonly training_id: FieldRef<"enrollments", 'String'>
    readonly status: FieldRef<"enrollments", 'String'>
    readonly progress: FieldRef<"enrollments", 'Int'>
    readonly completed_items: FieldRef<"enrollments", 'Json'>
    readonly score: FieldRef<"enrollments", 'Decimal'>
    readonly start_date: FieldRef<"enrollments", 'DateTime'>
    readonly completed_at: FieldRef<"enrollments", 'DateTime'>
    readonly last_accessed_at: FieldRef<"enrollments", 'DateTime'>
    readonly created_at: FieldRef<"enrollments", 'DateTime'>
    readonly updated_at: FieldRef<"enrollments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * enrollments findUnique
   */
  export type enrollmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments findUniqueOrThrow
   */
  export type enrollmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments findFirst
   */
  export type enrollmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     */
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments findFirstOrThrow
   */
  export type enrollmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     */
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments findMany
   */
  export type enrollmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments create
   */
  export type enrollmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a enrollments.
     */
    data: XOR<enrollmentsCreateInput, enrollmentsUncheckedCreateInput>
  }

  /**
   * enrollments createMany
   */
  export type enrollmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many enrollments.
     */
    data: enrollmentsCreateManyInput | enrollmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * enrollments createManyAndReturn
   */
  export type enrollmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * The data used to create many enrollments.
     */
    data: enrollmentsCreateManyInput | enrollmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * enrollments update
   */
  export type enrollmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a enrollments.
     */
    data: XOR<enrollmentsUpdateInput, enrollmentsUncheckedUpdateInput>
    /**
     * Choose, which enrollments to update.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments updateMany
   */
  export type enrollmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update enrollments.
     */
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyInput>
    /**
     * Filter which enrollments to update
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to update.
     */
    limit?: number
  }

  /**
   * enrollments updateManyAndReturn
   */
  export type enrollmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * The data used to update enrollments.
     */
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyInput>
    /**
     * Filter which enrollments to update
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * enrollments upsert
   */
  export type enrollmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the enrollments to update in case it exists.
     */
    where: enrollmentsWhereUniqueInput
    /**
     * In case the enrollments found by the `where` argument doesn't exist, create a new enrollments with this data.
     */
    create: XOR<enrollmentsCreateInput, enrollmentsUncheckedCreateInput>
    /**
     * In case the enrollments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<enrollmentsUpdateInput, enrollmentsUncheckedUpdateInput>
  }

  /**
   * enrollments delete
   */
  export type enrollmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter which enrollments to delete.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments deleteMany
   */
  export type enrollmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrollments to delete
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to delete.
     */
    limit?: number
  }

  /**
   * enrollments without action
   */
  export type enrollmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
  }


  /**
   * Model questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    points: number | null
    order_index: number | null
  }

  export type QuestionsSumAggregateOutputType = {
    points: number | null
    order_index: number | null
  }

  export type QuestionsMinAggregateOutputType = {
    id: string | null
    quiz_id: string | null
    question_text: string | null
    question_type: string | null
    points: number | null
    order_index: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsMaxAggregateOutputType = {
    id: string | null
    quiz_id: string | null
    question_text: string | null
    question_type: string | null
    points: number | null
    order_index: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    quiz_id: number
    question_text: number
    question_type: number
    options: number
    correct_answer: number
    points: number
    order_index: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    points?: true
    order_index?: true
  }

  export type QuestionsSumAggregateInputType = {
    points?: true
    order_index?: true
  }

  export type QuestionsMinAggregateInputType = {
    id?: true
    quiz_id?: true
    question_text?: true
    question_type?: true
    points?: true
    order_index?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    quiz_id?: true
    question_text?: true
    question_type?: true
    points?: true
    order_index?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    quiz_id?: true
    question_text?: true
    question_type?: true
    options?: true
    correct_answer?: true
    points?: true
    order_index?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to aggregate.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithAggregationInput | questionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _avg?: QuestionsAvgAggregateInputType
    _sum?: QuestionsSumAggregateInputType
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    id: string
    quiz_id: string
    question_text: string
    question_type: string
    options: JsonValue | null
    correct_answer: JsonValue
    points: number | null
    order_index: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    points?: boolean
    order_index?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizzes?: boolean | quizzesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type questionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    points?: boolean
    order_index?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizzes?: boolean | quizzesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type questionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    points?: boolean
    order_index?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizzes?: boolean | quizzesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type questionsSelectScalar = {
    id?: boolean
    quiz_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    points?: boolean
    order_index?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type questionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quiz_id" | "question_text" | "question_type" | "options" | "correct_answer" | "points" | "order_index" | "createdAt" | "updatedAt", ExtArgs["result"]["questions"]>
  export type questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | quizzesDefaultArgs<ExtArgs>
  }
  export type questionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | quizzesDefaultArgs<ExtArgs>
  }
  export type questionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | quizzesDefaultArgs<ExtArgs>
  }

  export type $questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions"
    objects: {
      quizzes: Prisma.$quizzesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quiz_id: string
      question_text: string
      question_type: string
      options: Prisma.JsonValue | null
      correct_answer: Prisma.JsonValue
      points: number | null
      order_index: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type questionsGetPayload<S extends boolean | null | undefined | questionsDefaultArgs> = $Result.GetResult<Prisma.$questionsPayload, S>

  type questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions'], meta: { name: 'questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {questionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionsFindUniqueArgs>(args: SelectSubset<T, questionsFindUniqueArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionsFindFirstArgs>(args?: SelectSubset<T, questionsFindFirstArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionsFindManyArgs>(args?: SelectSubset<T, questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Questions.
     * @param {questionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends questionsCreateArgs>(args: SelectSubset<T, questionsCreateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {questionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionsCreateManyArgs>(args?: SelectSubset<T, questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {questionsCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionsWithIdOnly = await prisma.questions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends questionsCreateManyAndReturnArgs>(args?: SelectSubset<T, questionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Questions.
     * @param {questionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends questionsDeleteArgs>(args: SelectSubset<T, questionsDeleteArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Questions.
     * @param {questionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionsUpdateArgs>(args: SelectSubset<T, questionsUpdateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {questionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionsDeleteManyArgs>(args?: SelectSubset<T, questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionsUpdateManyArgs>(args: SelectSubset<T, questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {questionsUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionsWithIdOnly = await prisma.questions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends questionsUpdateManyAndReturnArgs>(args: SelectSubset<T, questionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Questions.
     * @param {questionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends questionsUpsertArgs>(args: SelectSubset<T, questionsUpsertArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionsCountArgs>(
      args?: Subset<T, questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionsGroupByArgs['orderBy'] }
        : { orderBy?: questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions model
   */
  readonly fields: questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quizzes<T extends quizzesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, quizzesDefaultArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions model
   */
  interface questionsFieldRefs {
    readonly id: FieldRef<"questions", 'String'>
    readonly quiz_id: FieldRef<"questions", 'String'>
    readonly question_text: FieldRef<"questions", 'String'>
    readonly question_type: FieldRef<"questions", 'String'>
    readonly options: FieldRef<"questions", 'Json'>
    readonly correct_answer: FieldRef<"questions", 'Json'>
    readonly points: FieldRef<"questions", 'Int'>
    readonly order_index: FieldRef<"questions", 'Int'>
    readonly createdAt: FieldRef<"questions", 'DateTime'>
    readonly updatedAt: FieldRef<"questions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * questions findUnique
   */
  export type questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findUniqueOrThrow
   */
  export type questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findFirst
   */
  export type questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findFirstOrThrow
   */
  export type questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findMany
   */
  export type questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions create
   */
  export type questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a questions.
     */
    data: XOR<questionsCreateInput, questionsUncheckedCreateInput>
  }

  /**
   * questions createMany
   */
  export type questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionsCreateManyInput | questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questions createManyAndReturn
   */
  export type questionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * The data used to create many questions.
     */
    data: questionsCreateManyInput | questionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * questions update
   */
  export type questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a questions.
     */
    data: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
    /**
     * Choose, which questions to update.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions updateMany
   */
  export type questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionsWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
  }

  /**
   * questions updateManyAndReturn
   */
  export type questionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * The data used to update questions.
     */
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionsWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * questions upsert
   */
  export type questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the questions to update in case it exists.
     */
    where: questionsWhereUniqueInput
    /**
     * In case the questions found by the `where` argument doesn't exist, create a new questions with this data.
     */
    create: XOR<questionsCreateInput, questionsUncheckedCreateInput>
    /**
     * In case the questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
  }

  /**
   * questions delete
   */
  export type questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter which questions to delete.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions deleteMany
   */
  export type questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionsWhereInput
    /**
     * Limit how many questions to delete.
     */
    limit?: number
  }

  /**
   * questions without action
   */
  export type questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
  }


  /**
   * Model quizzes
   */

  export type AggregateQuizzes = {
    _count: QuizzesCountAggregateOutputType | null
    _avg: QuizzesAvgAggregateOutputType | null
    _sum: QuizzesSumAggregateOutputType | null
    _min: QuizzesMinAggregateOutputType | null
    _max: QuizzesMaxAggregateOutputType | null
  }

  export type QuizzesAvgAggregateOutputType = {
    pass_threshold: Decimal | null
  }

  export type QuizzesSumAggregateOutputType = {
    pass_threshold: Decimal | null
  }

  export type QuizzesMinAggregateOutputType = {
    id: string | null
    training_id: string | null
    title: string | null
    description: string | null
    pass_threshold: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizzesMaxAggregateOutputType = {
    id: string | null
    training_id: string | null
    title: string | null
    description: string | null
    pass_threshold: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizzesCountAggregateOutputType = {
    id: number
    training_id: number
    title: number
    description: number
    pass_threshold: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizzesAvgAggregateInputType = {
    pass_threshold?: true
  }

  export type QuizzesSumAggregateInputType = {
    pass_threshold?: true
  }

  export type QuizzesMinAggregateInputType = {
    id?: true
    training_id?: true
    title?: true
    description?: true
    pass_threshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizzesMaxAggregateInputType = {
    id?: true
    training_id?: true
    title?: true
    description?: true
    pass_threshold?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizzesCountAggregateInputType = {
    id?: true
    training_id?: true
    title?: true
    description?: true
    pass_threshold?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizzesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quizzes to aggregate.
     */
    where?: quizzesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizzesOrderByWithRelationInput | quizzesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quizzesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quizzes
    **/
    _count?: true | QuizzesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizzesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizzesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizzesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizzesMaxAggregateInputType
  }

  export type GetQuizzesAggregateType<T extends QuizzesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizzes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizzes[P]>
      : GetScalarType<T[P], AggregateQuizzes[P]>
  }




  export type quizzesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quizzesWhereInput
    orderBy?: quizzesOrderByWithAggregationInput | quizzesOrderByWithAggregationInput[]
    by: QuizzesScalarFieldEnum[] | QuizzesScalarFieldEnum
    having?: quizzesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizzesCountAggregateInputType | true
    _avg?: QuizzesAvgAggregateInputType
    _sum?: QuizzesSumAggregateInputType
    _min?: QuizzesMinAggregateInputType
    _max?: QuizzesMaxAggregateInputType
  }

  export type QuizzesGroupByOutputType = {
    id: string
    training_id: string | null
    title: string
    description: string | null
    pass_threshold: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    _count: QuizzesCountAggregateOutputType | null
    _avg: QuizzesAvgAggregateOutputType | null
    _sum: QuizzesSumAggregateOutputType | null
    _min: QuizzesMinAggregateOutputType | null
    _max: QuizzesMaxAggregateOutputType | null
  }

  type GetQuizzesGroupByPayload<T extends quizzesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizzesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizzesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizzesGroupByOutputType[P]>
            : GetScalarType<T[P], QuizzesGroupByOutputType[P]>
        }
      >
    >


  export type quizzesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    training_id?: boolean
    title?: boolean
    description?: boolean
    pass_threshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | quizzes$questionsArgs<ExtArgs>
    trainings?: boolean | quizzes$trainingsArgs<ExtArgs>
    _count?: boolean | QuizzesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizzes"]>

  export type quizzesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    training_id?: boolean
    title?: boolean
    description?: boolean
    pass_threshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainings?: boolean | quizzes$trainingsArgs<ExtArgs>
  }, ExtArgs["result"]["quizzes"]>

  export type quizzesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    training_id?: boolean
    title?: boolean
    description?: boolean
    pass_threshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainings?: boolean | quizzes$trainingsArgs<ExtArgs>
  }, ExtArgs["result"]["quizzes"]>

  export type quizzesSelectScalar = {
    id?: boolean
    training_id?: boolean
    title?: boolean
    description?: boolean
    pass_threshold?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type quizzesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "training_id" | "title" | "description" | "pass_threshold" | "createdAt" | "updatedAt", ExtArgs["result"]["quizzes"]>
  export type quizzesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | quizzes$questionsArgs<ExtArgs>
    trainings?: boolean | quizzes$trainingsArgs<ExtArgs>
    _count?: boolean | QuizzesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type quizzesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | quizzes$trainingsArgs<ExtArgs>
  }
  export type quizzesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | quizzes$trainingsArgs<ExtArgs>
  }

  export type $quizzesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quizzes"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>[]
      trainings: Prisma.$trainingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      training_id: string | null
      title: string
      description: string | null
      pass_threshold: Prisma.Decimal | null
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["quizzes"]>
    composites: {}
  }

  type quizzesGetPayload<S extends boolean | null | undefined | quizzesDefaultArgs> = $Result.GetResult<Prisma.$quizzesPayload, S>

  type quizzesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quizzesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizzesCountAggregateInputType | true
    }

  export interface quizzesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quizzes'], meta: { name: 'quizzes' } }
    /**
     * Find zero or one Quizzes that matches the filter.
     * @param {quizzesFindUniqueArgs} args - Arguments to find a Quizzes
     * @example
     * // Get one Quizzes
     * const quizzes = await prisma.quizzes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quizzesFindUniqueArgs>(args: SelectSubset<T, quizzesFindUniqueArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quizzes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quizzesFindUniqueOrThrowArgs} args - Arguments to find a Quizzes
     * @example
     * // Get one Quizzes
     * const quizzes = await prisma.quizzes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quizzesFindUniqueOrThrowArgs>(args: SelectSubset<T, quizzesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizzesFindFirstArgs} args - Arguments to find a Quizzes
     * @example
     * // Get one Quizzes
     * const quizzes = await prisma.quizzes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quizzesFindFirstArgs>(args?: SelectSubset<T, quizzesFindFirstArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quizzes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizzesFindFirstOrThrowArgs} args - Arguments to find a Quizzes
     * @example
     * // Get one Quizzes
     * const quizzes = await prisma.quizzes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quizzesFindFirstOrThrowArgs>(args?: SelectSubset<T, quizzesFindFirstOrThrowArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizzesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quizzes.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quizzes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizzesWithIdOnly = await prisma.quizzes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quizzesFindManyArgs>(args?: SelectSubset<T, quizzesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quizzes.
     * @param {quizzesCreateArgs} args - Arguments to create a Quizzes.
     * @example
     * // Create one Quizzes
     * const Quizzes = await prisma.quizzes.create({
     *   data: {
     *     // ... data to create a Quizzes
     *   }
     * })
     * 
     */
    create<T extends quizzesCreateArgs>(args: SelectSubset<T, quizzesCreateArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {quizzesCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quizzes = await prisma.quizzes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quizzesCreateManyArgs>(args?: SelectSubset<T, quizzesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {quizzesCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quizzes = await prisma.quizzes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizzesWithIdOnly = await prisma.quizzes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends quizzesCreateManyAndReturnArgs>(args?: SelectSubset<T, quizzesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quizzes.
     * @param {quizzesDeleteArgs} args - Arguments to delete one Quizzes.
     * @example
     * // Delete one Quizzes
     * const Quizzes = await prisma.quizzes.delete({
     *   where: {
     *     // ... filter to delete one Quizzes
     *   }
     * })
     * 
     */
    delete<T extends quizzesDeleteArgs>(args: SelectSubset<T, quizzesDeleteArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quizzes.
     * @param {quizzesUpdateArgs} args - Arguments to update one Quizzes.
     * @example
     * // Update one Quizzes
     * const quizzes = await prisma.quizzes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quizzesUpdateArgs>(args: SelectSubset<T, quizzesUpdateArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {quizzesDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quizzes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quizzesDeleteManyArgs>(args?: SelectSubset<T, quizzesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizzesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quizzes = await prisma.quizzes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quizzesUpdateManyArgs>(args: SelectSubset<T, quizzesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {quizzesUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quizzes = await prisma.quizzes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizzesWithIdOnly = await prisma.quizzes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends quizzesUpdateManyAndReturnArgs>(args: SelectSubset<T, quizzesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quizzes.
     * @param {quizzesUpsertArgs} args - Arguments to update or create a Quizzes.
     * @example
     * // Update or create a Quizzes
     * const quizzes = await prisma.quizzes.upsert({
     *   create: {
     *     // ... data to create a Quizzes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quizzes we want to update
     *   }
     * })
     */
    upsert<T extends quizzesUpsertArgs>(args: SelectSubset<T, quizzesUpsertArgs<ExtArgs>>): Prisma__quizzesClient<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizzesCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quizzes.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends quizzesCountArgs>(
      args?: Subset<T, quizzesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizzesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizzesAggregateArgs>(args: Subset<T, QuizzesAggregateArgs>): Prisma.PrismaPromise<GetQuizzesAggregateType<T>>

    /**
     * Group by Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quizzesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quizzesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quizzesGroupByArgs['orderBy'] }
        : { orderBy?: quizzesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quizzesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizzesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quizzes model
   */
  readonly fields: quizzesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quizzes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quizzesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends quizzes$questionsArgs<ExtArgs> = {}>(args?: Subset<T, quizzes$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trainings<T extends quizzes$trainingsArgs<ExtArgs> = {}>(args?: Subset<T, quizzes$trainingsArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quizzes model
   */
  interface quizzesFieldRefs {
    readonly id: FieldRef<"quizzes", 'String'>
    readonly training_id: FieldRef<"quizzes", 'String'>
    readonly title: FieldRef<"quizzes", 'String'>
    readonly description: FieldRef<"quizzes", 'String'>
    readonly pass_threshold: FieldRef<"quizzes", 'Decimal'>
    readonly createdAt: FieldRef<"quizzes", 'DateTime'>
    readonly updatedAt: FieldRef<"quizzes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * quizzes findUnique
   */
  export type quizzesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * Filter, which quizzes to fetch.
     */
    where: quizzesWhereUniqueInput
  }

  /**
   * quizzes findUniqueOrThrow
   */
  export type quizzesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * Filter, which quizzes to fetch.
     */
    where: quizzesWhereUniqueInput
  }

  /**
   * quizzes findFirst
   */
  export type quizzesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * Filter, which quizzes to fetch.
     */
    where?: quizzesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizzesOrderByWithRelationInput | quizzesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizzes.
     */
    cursor?: quizzesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizzes.
     */
    distinct?: QuizzesScalarFieldEnum | QuizzesScalarFieldEnum[]
  }

  /**
   * quizzes findFirstOrThrow
   */
  export type quizzesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * Filter, which quizzes to fetch.
     */
    where?: quizzesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizzesOrderByWithRelationInput | quizzesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quizzes.
     */
    cursor?: quizzesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quizzes.
     */
    distinct?: QuizzesScalarFieldEnum | QuizzesScalarFieldEnum[]
  }

  /**
   * quizzes findMany
   */
  export type quizzesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * Filter, which quizzes to fetch.
     */
    where?: quizzesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quizzes to fetch.
     */
    orderBy?: quizzesOrderByWithRelationInput | quizzesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quizzes.
     */
    cursor?: quizzesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quizzes.
     */
    skip?: number
    distinct?: QuizzesScalarFieldEnum | QuizzesScalarFieldEnum[]
  }

  /**
   * quizzes create
   */
  export type quizzesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * The data needed to create a quizzes.
     */
    data: XOR<quizzesCreateInput, quizzesUncheckedCreateInput>
  }

  /**
   * quizzes createMany
   */
  export type quizzesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quizzes.
     */
    data: quizzesCreateManyInput | quizzesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quizzes createManyAndReturn
   */
  export type quizzesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * The data used to create many quizzes.
     */
    data: quizzesCreateManyInput | quizzesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * quizzes update
   */
  export type quizzesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * The data needed to update a quizzes.
     */
    data: XOR<quizzesUpdateInput, quizzesUncheckedUpdateInput>
    /**
     * Choose, which quizzes to update.
     */
    where: quizzesWhereUniqueInput
  }

  /**
   * quizzes updateMany
   */
  export type quizzesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quizzes.
     */
    data: XOR<quizzesUpdateManyMutationInput, quizzesUncheckedUpdateManyInput>
    /**
     * Filter which quizzes to update
     */
    where?: quizzesWhereInput
    /**
     * Limit how many quizzes to update.
     */
    limit?: number
  }

  /**
   * quizzes updateManyAndReturn
   */
  export type quizzesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * The data used to update quizzes.
     */
    data: XOR<quizzesUpdateManyMutationInput, quizzesUncheckedUpdateManyInput>
    /**
     * Filter which quizzes to update
     */
    where?: quizzesWhereInput
    /**
     * Limit how many quizzes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * quizzes upsert
   */
  export type quizzesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * The filter to search for the quizzes to update in case it exists.
     */
    where: quizzesWhereUniqueInput
    /**
     * In case the quizzes found by the `where` argument doesn't exist, create a new quizzes with this data.
     */
    create: XOR<quizzesCreateInput, quizzesUncheckedCreateInput>
    /**
     * In case the quizzes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quizzesUpdateInput, quizzesUncheckedUpdateInput>
  }

  /**
   * quizzes delete
   */
  export type quizzesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    /**
     * Filter which quizzes to delete.
     */
    where: quizzesWhereUniqueInput
  }

  /**
   * quizzes deleteMany
   */
  export type quizzesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quizzes to delete
     */
    where?: quizzesWhereInput
    /**
     * Limit how many quizzes to delete.
     */
    limit?: number
  }

  /**
   * quizzes.questions
   */
  export type quizzes$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    cursor?: questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * quizzes.trainings
   */
  export type quizzes$trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    where?: trainingsWhereInput
  }

  /**
   * quizzes without action
   */
  export type quizzesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
  }


  /**
   * Model training_content
   */

  export type AggregateTraining_content = {
    _count: Training_contentCountAggregateOutputType | null
    _avg: Training_contentAvgAggregateOutputType | null
    _sum: Training_contentSumAggregateOutputType | null
    _min: Training_contentMinAggregateOutputType | null
    _max: Training_contentMaxAggregateOutputType | null
  }

  export type Training_contentAvgAggregateOutputType = {
    order_index: number | null
  }

  export type Training_contentSumAggregateOutputType = {
    order_index: number | null
  }

  export type Training_contentMinAggregateOutputType = {
    id: string | null
    training_id: string | null
    title: string | null
    content_type: string | null
    content_value: string | null
    order_index: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Training_contentMaxAggregateOutputType = {
    id: string | null
    training_id: string | null
    title: string | null
    content_type: string | null
    content_value: string | null
    order_index: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Training_contentCountAggregateOutputType = {
    id: number
    training_id: number
    title: number
    content_type: number
    content_value: number
    order_index: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Training_contentAvgAggregateInputType = {
    order_index?: true
  }

  export type Training_contentSumAggregateInputType = {
    order_index?: true
  }

  export type Training_contentMinAggregateInputType = {
    id?: true
    training_id?: true
    title?: true
    content_type?: true
    content_value?: true
    order_index?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Training_contentMaxAggregateInputType = {
    id?: true
    training_id?: true
    title?: true
    content_type?: true
    content_value?: true
    order_index?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Training_contentCountAggregateInputType = {
    id?: true
    training_id?: true
    title?: true
    content_type?: true
    content_value?: true
    order_index?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Training_contentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which training_content to aggregate.
     */
    where?: training_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of training_contents to fetch.
     */
    orderBy?: training_contentOrderByWithRelationInput | training_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: training_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` training_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` training_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned training_contents
    **/
    _count?: true | Training_contentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Training_contentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Training_contentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Training_contentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Training_contentMaxAggregateInputType
  }

  export type GetTraining_contentAggregateType<T extends Training_contentAggregateArgs> = {
        [P in keyof T & keyof AggregateTraining_content]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraining_content[P]>
      : GetScalarType<T[P], AggregateTraining_content[P]>
  }




  export type training_contentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: training_contentWhereInput
    orderBy?: training_contentOrderByWithAggregationInput | training_contentOrderByWithAggregationInput[]
    by: Training_contentScalarFieldEnum[] | Training_contentScalarFieldEnum
    having?: training_contentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Training_contentCountAggregateInputType | true
    _avg?: Training_contentAvgAggregateInputType
    _sum?: Training_contentSumAggregateInputType
    _min?: Training_contentMinAggregateInputType
    _max?: Training_contentMaxAggregateInputType
  }

  export type Training_contentGroupByOutputType = {
    id: string
    training_id: string
    title: string
    content_type: string
    content_value: string
    order_index: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: Training_contentCountAggregateOutputType | null
    _avg: Training_contentAvgAggregateOutputType | null
    _sum: Training_contentSumAggregateOutputType | null
    _min: Training_contentMinAggregateOutputType | null
    _max: Training_contentMaxAggregateOutputType | null
  }

  type GetTraining_contentGroupByPayload<T extends training_contentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Training_contentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Training_contentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Training_contentGroupByOutputType[P]>
            : GetScalarType<T[P], Training_contentGroupByOutputType[P]>
        }
      >
    >


  export type training_contentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    training_id?: boolean
    title?: boolean
    content_type?: boolean
    content_value?: boolean
    order_index?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training_content"]>

  export type training_contentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    training_id?: boolean
    title?: boolean
    content_type?: boolean
    content_value?: boolean
    order_index?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training_content"]>

  export type training_contentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    training_id?: boolean
    title?: boolean
    content_type?: boolean
    content_value?: boolean
    order_index?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["training_content"]>

  export type training_contentSelectScalar = {
    id?: boolean
    training_id?: boolean
    title?: boolean
    content_type?: boolean
    content_value?: boolean
    order_index?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type training_contentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "training_id" | "title" | "content_type" | "content_value" | "order_index" | "createdAt" | "updatedAt", ExtArgs["result"]["training_content"]>
  export type training_contentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }
  export type training_contentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }
  export type training_contentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
  }

  export type $training_contentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "training_content"
    objects: {
      trainings: Prisma.$trainingsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      training_id: string
      title: string
      content_type: string
      content_value: string
      order_index: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["training_content"]>
    composites: {}
  }

  type training_contentGetPayload<S extends boolean | null | undefined | training_contentDefaultArgs> = $Result.GetResult<Prisma.$training_contentPayload, S>

  type training_contentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<training_contentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Training_contentCountAggregateInputType | true
    }

  export interface training_contentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['training_content'], meta: { name: 'training_content' } }
    /**
     * Find zero or one Training_content that matches the filter.
     * @param {training_contentFindUniqueArgs} args - Arguments to find a Training_content
     * @example
     * // Get one Training_content
     * const training_content = await prisma.training_content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends training_contentFindUniqueArgs>(args: SelectSubset<T, training_contentFindUniqueArgs<ExtArgs>>): Prisma__training_contentClient<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Training_content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {training_contentFindUniqueOrThrowArgs} args - Arguments to find a Training_content
     * @example
     * // Get one Training_content
     * const training_content = await prisma.training_content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends training_contentFindUniqueOrThrowArgs>(args: SelectSubset<T, training_contentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__training_contentClient<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Training_content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {training_contentFindFirstArgs} args - Arguments to find a Training_content
     * @example
     * // Get one Training_content
     * const training_content = await prisma.training_content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends training_contentFindFirstArgs>(args?: SelectSubset<T, training_contentFindFirstArgs<ExtArgs>>): Prisma__training_contentClient<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Training_content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {training_contentFindFirstOrThrowArgs} args - Arguments to find a Training_content
     * @example
     * // Get one Training_content
     * const training_content = await prisma.training_content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends training_contentFindFirstOrThrowArgs>(args?: SelectSubset<T, training_contentFindFirstOrThrowArgs<ExtArgs>>): Prisma__training_contentClient<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Training_contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {training_contentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Training_contents
     * const training_contents = await prisma.training_content.findMany()
     * 
     * // Get first 10 Training_contents
     * const training_contents = await prisma.training_content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const training_contentWithIdOnly = await prisma.training_content.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends training_contentFindManyArgs>(args?: SelectSubset<T, training_contentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Training_content.
     * @param {training_contentCreateArgs} args - Arguments to create a Training_content.
     * @example
     * // Create one Training_content
     * const Training_content = await prisma.training_content.create({
     *   data: {
     *     // ... data to create a Training_content
     *   }
     * })
     * 
     */
    create<T extends training_contentCreateArgs>(args: SelectSubset<T, training_contentCreateArgs<ExtArgs>>): Prisma__training_contentClient<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Training_contents.
     * @param {training_contentCreateManyArgs} args - Arguments to create many Training_contents.
     * @example
     * // Create many Training_contents
     * const training_content = await prisma.training_content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends training_contentCreateManyArgs>(args?: SelectSubset<T, training_contentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Training_contents and returns the data saved in the database.
     * @param {training_contentCreateManyAndReturnArgs} args - Arguments to create many Training_contents.
     * @example
     * // Create many Training_contents
     * const training_content = await prisma.training_content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Training_contents and only return the `id`
     * const training_contentWithIdOnly = await prisma.training_content.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends training_contentCreateManyAndReturnArgs>(args?: SelectSubset<T, training_contentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Training_content.
     * @param {training_contentDeleteArgs} args - Arguments to delete one Training_content.
     * @example
     * // Delete one Training_content
     * const Training_content = await prisma.training_content.delete({
     *   where: {
     *     // ... filter to delete one Training_content
     *   }
     * })
     * 
     */
    delete<T extends training_contentDeleteArgs>(args: SelectSubset<T, training_contentDeleteArgs<ExtArgs>>): Prisma__training_contentClient<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Training_content.
     * @param {training_contentUpdateArgs} args - Arguments to update one Training_content.
     * @example
     * // Update one Training_content
     * const training_content = await prisma.training_content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends training_contentUpdateArgs>(args: SelectSubset<T, training_contentUpdateArgs<ExtArgs>>): Prisma__training_contentClient<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Training_contents.
     * @param {training_contentDeleteManyArgs} args - Arguments to filter Training_contents to delete.
     * @example
     * // Delete a few Training_contents
     * const { count } = await prisma.training_content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends training_contentDeleteManyArgs>(args?: SelectSubset<T, training_contentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Training_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {training_contentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Training_contents
     * const training_content = await prisma.training_content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends training_contentUpdateManyArgs>(args: SelectSubset<T, training_contentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Training_contents and returns the data updated in the database.
     * @param {training_contentUpdateManyAndReturnArgs} args - Arguments to update many Training_contents.
     * @example
     * // Update many Training_contents
     * const training_content = await prisma.training_content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Training_contents and only return the `id`
     * const training_contentWithIdOnly = await prisma.training_content.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends training_contentUpdateManyAndReturnArgs>(args: SelectSubset<T, training_contentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Training_content.
     * @param {training_contentUpsertArgs} args - Arguments to update or create a Training_content.
     * @example
     * // Update or create a Training_content
     * const training_content = await prisma.training_content.upsert({
     *   create: {
     *     // ... data to create a Training_content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Training_content we want to update
     *   }
     * })
     */
    upsert<T extends training_contentUpsertArgs>(args: SelectSubset<T, training_contentUpsertArgs<ExtArgs>>): Prisma__training_contentClient<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Training_contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {training_contentCountArgs} args - Arguments to filter Training_contents to count.
     * @example
     * // Count the number of Training_contents
     * const count = await prisma.training_content.count({
     *   where: {
     *     // ... the filter for the Training_contents we want to count
     *   }
     * })
    **/
    count<T extends training_contentCountArgs>(
      args?: Subset<T, training_contentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Training_contentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Training_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Training_contentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Training_contentAggregateArgs>(args: Subset<T, Training_contentAggregateArgs>): Prisma.PrismaPromise<GetTraining_contentAggregateType<T>>

    /**
     * Group by Training_content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {training_contentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends training_contentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: training_contentGroupByArgs['orderBy'] }
        : { orderBy?: training_contentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, training_contentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraining_contentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the training_content model
   */
  readonly fields: training_contentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for training_content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__training_contentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainings<T extends trainingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, trainingsDefaultArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the training_content model
   */
  interface training_contentFieldRefs {
    readonly id: FieldRef<"training_content", 'String'>
    readonly training_id: FieldRef<"training_content", 'String'>
    readonly title: FieldRef<"training_content", 'String'>
    readonly content_type: FieldRef<"training_content", 'String'>
    readonly content_value: FieldRef<"training_content", 'String'>
    readonly order_index: FieldRef<"training_content", 'Int'>
    readonly createdAt: FieldRef<"training_content", 'DateTime'>
    readonly updatedAt: FieldRef<"training_content", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * training_content findUnique
   */
  export type training_contentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * Filter, which training_content to fetch.
     */
    where: training_contentWhereUniqueInput
  }

  /**
   * training_content findUniqueOrThrow
   */
  export type training_contentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * Filter, which training_content to fetch.
     */
    where: training_contentWhereUniqueInput
  }

  /**
   * training_content findFirst
   */
  export type training_contentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * Filter, which training_content to fetch.
     */
    where?: training_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of training_contents to fetch.
     */
    orderBy?: training_contentOrderByWithRelationInput | training_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for training_contents.
     */
    cursor?: training_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` training_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` training_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of training_contents.
     */
    distinct?: Training_contentScalarFieldEnum | Training_contentScalarFieldEnum[]
  }

  /**
   * training_content findFirstOrThrow
   */
  export type training_contentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * Filter, which training_content to fetch.
     */
    where?: training_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of training_contents to fetch.
     */
    orderBy?: training_contentOrderByWithRelationInput | training_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for training_contents.
     */
    cursor?: training_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` training_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` training_contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of training_contents.
     */
    distinct?: Training_contentScalarFieldEnum | Training_contentScalarFieldEnum[]
  }

  /**
   * training_content findMany
   */
  export type training_contentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * Filter, which training_contents to fetch.
     */
    where?: training_contentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of training_contents to fetch.
     */
    orderBy?: training_contentOrderByWithRelationInput | training_contentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing training_contents.
     */
    cursor?: training_contentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` training_contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` training_contents.
     */
    skip?: number
    distinct?: Training_contentScalarFieldEnum | Training_contentScalarFieldEnum[]
  }

  /**
   * training_content create
   */
  export type training_contentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * The data needed to create a training_content.
     */
    data: XOR<training_contentCreateInput, training_contentUncheckedCreateInput>
  }

  /**
   * training_content createMany
   */
  export type training_contentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many training_contents.
     */
    data: training_contentCreateManyInput | training_contentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * training_content createManyAndReturn
   */
  export type training_contentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * The data used to create many training_contents.
     */
    data: training_contentCreateManyInput | training_contentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * training_content update
   */
  export type training_contentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * The data needed to update a training_content.
     */
    data: XOR<training_contentUpdateInput, training_contentUncheckedUpdateInput>
    /**
     * Choose, which training_content to update.
     */
    where: training_contentWhereUniqueInput
  }

  /**
   * training_content updateMany
   */
  export type training_contentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update training_contents.
     */
    data: XOR<training_contentUpdateManyMutationInput, training_contentUncheckedUpdateManyInput>
    /**
     * Filter which training_contents to update
     */
    where?: training_contentWhereInput
    /**
     * Limit how many training_contents to update.
     */
    limit?: number
  }

  /**
   * training_content updateManyAndReturn
   */
  export type training_contentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * The data used to update training_contents.
     */
    data: XOR<training_contentUpdateManyMutationInput, training_contentUncheckedUpdateManyInput>
    /**
     * Filter which training_contents to update
     */
    where?: training_contentWhereInput
    /**
     * Limit how many training_contents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * training_content upsert
   */
  export type training_contentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * The filter to search for the training_content to update in case it exists.
     */
    where: training_contentWhereUniqueInput
    /**
     * In case the training_content found by the `where` argument doesn't exist, create a new training_content with this data.
     */
    create: XOR<training_contentCreateInput, training_contentUncheckedCreateInput>
    /**
     * In case the training_content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<training_contentUpdateInput, training_contentUncheckedUpdateInput>
  }

  /**
   * training_content delete
   */
  export type training_contentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    /**
     * Filter which training_content to delete.
     */
    where: training_contentWhereUniqueInput
  }

  /**
   * training_content deleteMany
   */
  export type training_contentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which training_contents to delete
     */
    where?: training_contentWhereInput
    /**
     * Limit how many training_contents to delete.
     */
    limit?: number
  }

  /**
   * training_content without action
   */
  export type training_contentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
  }


  /**
   * Model trainings
   */

  export type AggregateTrainings = {
    _count: TrainingsCountAggregateOutputType | null
    _avg: TrainingsAvgAggregateOutputType | null
    _sum: TrainingsSumAggregateOutputType | null
    _min: TrainingsMinAggregateOutputType | null
    _max: TrainingsMaxAggregateOutputType | null
  }

  export type TrainingsAvgAggregateOutputType = {
    duration: number | null
  }

  export type TrainingsSumAggregateOutputType = {
    duration: number | null
  }

  export type TrainingsMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    duration: number | null
    author: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    certificateTemplate: string | null
    deadline: Date | null
    is_mandatory: boolean | null
  }

  export type TrainingsMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    duration: number | null
    author: string | null
    published: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    certificateTemplate: string | null
    deadline: Date | null
    is_mandatory: boolean | null
  }

  export type TrainingsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    duration: number
    author: number
    published: number
    tags: number
    createdAt: number
    updatedAt: number
    certificateTemplate: number
    learning_outcomes: number
    deadline: number
    is_mandatory: number
    _all: number
  }


  export type TrainingsAvgAggregateInputType = {
    duration?: true
  }

  export type TrainingsSumAggregateInputType = {
    duration?: true
  }

  export type TrainingsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    duration?: true
    author?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    certificateTemplate?: true
    deadline?: true
    is_mandatory?: true
  }

  export type TrainingsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    duration?: true
    author?: true
    published?: true
    createdAt?: true
    updatedAt?: true
    certificateTemplate?: true
    deadline?: true
    is_mandatory?: true
  }

  export type TrainingsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    duration?: true
    author?: true
    published?: true
    tags?: true
    createdAt?: true
    updatedAt?: true
    certificateTemplate?: true
    learning_outcomes?: true
    deadline?: true
    is_mandatory?: true
    _all?: true
  }

  export type TrainingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings to aggregate.
     */
    where?: trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings to fetch.
     */
    orderBy?: trainingsOrderByWithRelationInput | trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned trainings
    **/
    _count?: true | TrainingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingsMaxAggregateInputType
  }

  export type GetTrainingsAggregateType<T extends TrainingsAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainings[P]>
      : GetScalarType<T[P], AggregateTrainings[P]>
  }




  export type trainingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: trainingsWhereInput
    orderBy?: trainingsOrderByWithAggregationInput | trainingsOrderByWithAggregationInput[]
    by: TrainingsScalarFieldEnum[] | TrainingsScalarFieldEnum
    having?: trainingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingsCountAggregateInputType | true
    _avg?: TrainingsAvgAggregateInputType
    _sum?: TrainingsSumAggregateInputType
    _min?: TrainingsMinAggregateInputType
    _max?: TrainingsMaxAggregateInputType
  }

  export type TrainingsGroupByOutputType = {
    id: string
    title: string
    description: string | null
    category: string | null
    duration: number | null
    author: string | null
    published: boolean | null
    tags: string[]
    createdAt: Date | null
    updatedAt: Date | null
    certificateTemplate: string | null
    learning_outcomes: string[]
    deadline: Date | null
    is_mandatory: boolean | null
    _count: TrainingsCountAggregateOutputType | null
    _avg: TrainingsAvgAggregateOutputType | null
    _sum: TrainingsSumAggregateOutputType | null
    _min: TrainingsMinAggregateOutputType | null
    _max: TrainingsMaxAggregateOutputType | null
  }

  type GetTrainingsGroupByPayload<T extends trainingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingsGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingsGroupByOutputType[P]>
        }
      >
    >


  export type trainingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    duration?: boolean
    author?: boolean
    published?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificateTemplate?: boolean
    learning_outcomes?: boolean
    deadline?: boolean
    is_mandatory?: boolean
    bootcamp_trainings?: boolean | trainings$bootcamp_trainingsArgs<ExtArgs>
    enrollments?: boolean | trainings$enrollmentsArgs<ExtArgs>
    quizzes?: boolean | trainings$quizzesArgs<ExtArgs>
    training_content?: boolean | trainings$training_contentArgs<ExtArgs>
    user_training_assignments?: boolean | trainings$user_training_assignmentsArgs<ExtArgs>
    user_training_progress?: boolean | trainings$user_training_progressArgs<ExtArgs>
    _count?: boolean | TrainingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainings"]>

  export type trainingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    duration?: boolean
    author?: boolean
    published?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificateTemplate?: boolean
    learning_outcomes?: boolean
    deadline?: boolean
    is_mandatory?: boolean
  }, ExtArgs["result"]["trainings"]>

  export type trainingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    duration?: boolean
    author?: boolean
    published?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificateTemplate?: boolean
    learning_outcomes?: boolean
    deadline?: boolean
    is_mandatory?: boolean
  }, ExtArgs["result"]["trainings"]>

  export type trainingsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    duration?: boolean
    author?: boolean
    published?: boolean
    tags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    certificateTemplate?: boolean
    learning_outcomes?: boolean
    deadline?: boolean
    is_mandatory?: boolean
  }

  export type trainingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "duration" | "author" | "published" | "tags" | "createdAt" | "updatedAt" | "certificateTemplate" | "learning_outcomes" | "deadline" | "is_mandatory", ExtArgs["result"]["trainings"]>
  export type trainingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamp_trainings?: boolean | trainings$bootcamp_trainingsArgs<ExtArgs>
    enrollments?: boolean | trainings$enrollmentsArgs<ExtArgs>
    quizzes?: boolean | trainings$quizzesArgs<ExtArgs>
    training_content?: boolean | trainings$training_contentArgs<ExtArgs>
    user_training_assignments?: boolean | trainings$user_training_assignmentsArgs<ExtArgs>
    user_training_progress?: boolean | trainings$user_training_progressArgs<ExtArgs>
    _count?: boolean | TrainingsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type trainingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type trainingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $trainingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "trainings"
    objects: {
      bootcamp_trainings: Prisma.$bootcamp_trainingsPayload<ExtArgs>[]
      enrollments: Prisma.$enrollmentsPayload<ExtArgs>[]
      quizzes: Prisma.$quizzesPayload<ExtArgs>[]
      training_content: Prisma.$training_contentPayload<ExtArgs>[]
      user_training_assignments: Prisma.$user_training_assignmentsPayload<ExtArgs>[]
      user_training_progress: Prisma.$user_training_progressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      category: string | null
      duration: number | null
      author: string | null
      published: boolean | null
      tags: string[]
      createdAt: Date | null
      updatedAt: Date | null
      certificateTemplate: string | null
      learning_outcomes: string[]
      deadline: Date | null
      is_mandatory: boolean | null
    }, ExtArgs["result"]["trainings"]>
    composites: {}
  }

  type trainingsGetPayload<S extends boolean | null | undefined | trainingsDefaultArgs> = $Result.GetResult<Prisma.$trainingsPayload, S>

  type trainingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<trainingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrainingsCountAggregateInputType | true
    }

  export interface trainingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['trainings'], meta: { name: 'trainings' } }
    /**
     * Find zero or one Trainings that matches the filter.
     * @param {trainingsFindUniqueArgs} args - Arguments to find a Trainings
     * @example
     * // Get one Trainings
     * const trainings = await prisma.trainings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends trainingsFindUniqueArgs>(args: SelectSubset<T, trainingsFindUniqueArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Trainings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {trainingsFindUniqueOrThrowArgs} args - Arguments to find a Trainings
     * @example
     * // Get one Trainings
     * const trainings = await prisma.trainings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends trainingsFindUniqueOrThrowArgs>(args: SelectSubset<T, trainingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainingsFindFirstArgs} args - Arguments to find a Trainings
     * @example
     * // Get one Trainings
     * const trainings = await prisma.trainings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends trainingsFindFirstArgs>(args?: SelectSubset<T, trainingsFindFirstArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Trainings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainingsFindFirstOrThrowArgs} args - Arguments to find a Trainings
     * @example
     * // Get one Trainings
     * const trainings = await prisma.trainings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends trainingsFindFirstOrThrowArgs>(args?: SelectSubset<T, trainingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Trainings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trainings
     * const trainings = await prisma.trainings.findMany()
     * 
     * // Get first 10 Trainings
     * const trainings = await prisma.trainings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingsWithIdOnly = await prisma.trainings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends trainingsFindManyArgs>(args?: SelectSubset<T, trainingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Trainings.
     * @param {trainingsCreateArgs} args - Arguments to create a Trainings.
     * @example
     * // Create one Trainings
     * const Trainings = await prisma.trainings.create({
     *   data: {
     *     // ... data to create a Trainings
     *   }
     * })
     * 
     */
    create<T extends trainingsCreateArgs>(args: SelectSubset<T, trainingsCreateArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Trainings.
     * @param {trainingsCreateManyArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const trainings = await prisma.trainings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends trainingsCreateManyArgs>(args?: SelectSubset<T, trainingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trainings and returns the data saved in the database.
     * @param {trainingsCreateManyAndReturnArgs} args - Arguments to create many Trainings.
     * @example
     * // Create many Trainings
     * const trainings = await prisma.trainings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trainings and only return the `id`
     * const trainingsWithIdOnly = await prisma.trainings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends trainingsCreateManyAndReturnArgs>(args?: SelectSubset<T, trainingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Trainings.
     * @param {trainingsDeleteArgs} args - Arguments to delete one Trainings.
     * @example
     * // Delete one Trainings
     * const Trainings = await prisma.trainings.delete({
     *   where: {
     *     // ... filter to delete one Trainings
     *   }
     * })
     * 
     */
    delete<T extends trainingsDeleteArgs>(args: SelectSubset<T, trainingsDeleteArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Trainings.
     * @param {trainingsUpdateArgs} args - Arguments to update one Trainings.
     * @example
     * // Update one Trainings
     * const trainings = await prisma.trainings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends trainingsUpdateArgs>(args: SelectSubset<T, trainingsUpdateArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Trainings.
     * @param {trainingsDeleteManyArgs} args - Arguments to filter Trainings to delete.
     * @example
     * // Delete a few Trainings
     * const { count } = await prisma.trainings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends trainingsDeleteManyArgs>(args?: SelectSubset<T, trainingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trainings
     * const trainings = await prisma.trainings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends trainingsUpdateManyArgs>(args: SelectSubset<T, trainingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trainings and returns the data updated in the database.
     * @param {trainingsUpdateManyAndReturnArgs} args - Arguments to update many Trainings.
     * @example
     * // Update many Trainings
     * const trainings = await prisma.trainings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Trainings and only return the `id`
     * const trainingsWithIdOnly = await prisma.trainings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends trainingsUpdateManyAndReturnArgs>(args: SelectSubset<T, trainingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Trainings.
     * @param {trainingsUpsertArgs} args - Arguments to update or create a Trainings.
     * @example
     * // Update or create a Trainings
     * const trainings = await prisma.trainings.upsert({
     *   create: {
     *     // ... data to create a Trainings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Trainings we want to update
     *   }
     * })
     */
    upsert<T extends trainingsUpsertArgs>(args: SelectSubset<T, trainingsUpsertArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainingsCountArgs} args - Arguments to filter Trainings to count.
     * @example
     * // Count the number of Trainings
     * const count = await prisma.trainings.count({
     *   where: {
     *     // ... the filter for the Trainings we want to count
     *   }
     * })
    **/
    count<T extends trainingsCountArgs>(
      args?: Subset<T, trainingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingsAggregateArgs>(args: Subset<T, TrainingsAggregateArgs>): Prisma.PrismaPromise<GetTrainingsAggregateType<T>>

    /**
     * Group by Trainings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {trainingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends trainingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: trainingsGroupByArgs['orderBy'] }
        : { orderBy?: trainingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, trainingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the trainings model
   */
  readonly fields: trainingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for trainings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__trainingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bootcamp_trainings<T extends trainings$bootcamp_trainingsArgs<ExtArgs> = {}>(args?: Subset<T, trainings$bootcamp_trainingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bootcamp_trainingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends trainings$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, trainings$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizzes<T extends trainings$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, trainings$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quizzesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    training_content<T extends trainings$training_contentArgs<ExtArgs> = {}>(args?: Subset<T, trainings$training_contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$training_contentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_training_assignments<T extends trainings$user_training_assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, trainings$user_training_assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_training_progress<T extends trainings$user_training_progressArgs<ExtArgs> = {}>(args?: Subset<T, trainings$user_training_progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the trainings model
   */
  interface trainingsFieldRefs {
    readonly id: FieldRef<"trainings", 'String'>
    readonly title: FieldRef<"trainings", 'String'>
    readonly description: FieldRef<"trainings", 'String'>
    readonly category: FieldRef<"trainings", 'String'>
    readonly duration: FieldRef<"trainings", 'Int'>
    readonly author: FieldRef<"trainings", 'String'>
    readonly published: FieldRef<"trainings", 'Boolean'>
    readonly tags: FieldRef<"trainings", 'String[]'>
    readonly createdAt: FieldRef<"trainings", 'DateTime'>
    readonly updatedAt: FieldRef<"trainings", 'DateTime'>
    readonly certificateTemplate: FieldRef<"trainings", 'String'>
    readonly learning_outcomes: FieldRef<"trainings", 'String[]'>
    readonly deadline: FieldRef<"trainings", 'DateTime'>
    readonly is_mandatory: FieldRef<"trainings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * trainings findUnique
   */
  export type trainingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * Filter, which trainings to fetch.
     */
    where: trainingsWhereUniqueInput
  }

  /**
   * trainings findUniqueOrThrow
   */
  export type trainingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * Filter, which trainings to fetch.
     */
    where: trainingsWhereUniqueInput
  }

  /**
   * trainings findFirst
   */
  export type trainingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * Filter, which trainings to fetch.
     */
    where?: trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings to fetch.
     */
    orderBy?: trainingsOrderByWithRelationInput | trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings.
     */
    cursor?: trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings.
     */
    distinct?: TrainingsScalarFieldEnum | TrainingsScalarFieldEnum[]
  }

  /**
   * trainings findFirstOrThrow
   */
  export type trainingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * Filter, which trainings to fetch.
     */
    where?: trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings to fetch.
     */
    orderBy?: trainingsOrderByWithRelationInput | trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for trainings.
     */
    cursor?: trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of trainings.
     */
    distinct?: TrainingsScalarFieldEnum | TrainingsScalarFieldEnum[]
  }

  /**
   * trainings findMany
   */
  export type trainingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * Filter, which trainings to fetch.
     */
    where?: trainingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of trainings to fetch.
     */
    orderBy?: trainingsOrderByWithRelationInput | trainingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing trainings.
     */
    cursor?: trainingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` trainings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` trainings.
     */
    skip?: number
    distinct?: TrainingsScalarFieldEnum | TrainingsScalarFieldEnum[]
  }

  /**
   * trainings create
   */
  export type trainingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * The data needed to create a trainings.
     */
    data: XOR<trainingsCreateInput, trainingsUncheckedCreateInput>
  }

  /**
   * trainings createMany
   */
  export type trainingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many trainings.
     */
    data: trainingsCreateManyInput | trainingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trainings createManyAndReturn
   */
  export type trainingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * The data used to create many trainings.
     */
    data: trainingsCreateManyInput | trainingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * trainings update
   */
  export type trainingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * The data needed to update a trainings.
     */
    data: XOR<trainingsUpdateInput, trainingsUncheckedUpdateInput>
    /**
     * Choose, which trainings to update.
     */
    where: trainingsWhereUniqueInput
  }

  /**
   * trainings updateMany
   */
  export type trainingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update trainings.
     */
    data: XOR<trainingsUpdateManyMutationInput, trainingsUncheckedUpdateManyInput>
    /**
     * Filter which trainings to update
     */
    where?: trainingsWhereInput
    /**
     * Limit how many trainings to update.
     */
    limit?: number
  }

  /**
   * trainings updateManyAndReturn
   */
  export type trainingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * The data used to update trainings.
     */
    data: XOR<trainingsUpdateManyMutationInput, trainingsUncheckedUpdateManyInput>
    /**
     * Filter which trainings to update
     */
    where?: trainingsWhereInput
    /**
     * Limit how many trainings to update.
     */
    limit?: number
  }

  /**
   * trainings upsert
   */
  export type trainingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * The filter to search for the trainings to update in case it exists.
     */
    where: trainingsWhereUniqueInput
    /**
     * In case the trainings found by the `where` argument doesn't exist, create a new trainings with this data.
     */
    create: XOR<trainingsCreateInput, trainingsUncheckedCreateInput>
    /**
     * In case the trainings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<trainingsUpdateInput, trainingsUncheckedUpdateInput>
  }

  /**
   * trainings delete
   */
  export type trainingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
    /**
     * Filter which trainings to delete.
     */
    where: trainingsWhereUniqueInput
  }

  /**
   * trainings deleteMany
   */
  export type trainingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which trainings to delete
     */
    where?: trainingsWhereInput
    /**
     * Limit how many trainings to delete.
     */
    limit?: number
  }

  /**
   * trainings.bootcamp_trainings
   */
  export type trainings$bootcamp_trainingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamp_trainings
     */
    select?: bootcamp_trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamp_trainings
     */
    omit?: bootcamp_trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcamp_trainingsInclude<ExtArgs> | null
    where?: bootcamp_trainingsWhereInput
    orderBy?: bootcamp_trainingsOrderByWithRelationInput | bootcamp_trainingsOrderByWithRelationInput[]
    cursor?: bootcamp_trainingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bootcamp_trainingsScalarFieldEnum | Bootcamp_trainingsScalarFieldEnum[]
  }

  /**
   * trainings.enrollments
   */
  export type trainings$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    cursor?: enrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * trainings.quizzes
   */
  export type trainings$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quizzes
     */
    select?: quizzesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quizzes
     */
    omit?: quizzesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quizzesInclude<ExtArgs> | null
    where?: quizzesWhereInput
    orderBy?: quizzesOrderByWithRelationInput | quizzesOrderByWithRelationInput[]
    cursor?: quizzesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizzesScalarFieldEnum | QuizzesScalarFieldEnum[]
  }

  /**
   * trainings.training_content
   */
  export type trainings$training_contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the training_content
     */
    select?: training_contentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the training_content
     */
    omit?: training_contentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: training_contentInclude<ExtArgs> | null
    where?: training_contentWhereInput
    orderBy?: training_contentOrderByWithRelationInput | training_contentOrderByWithRelationInput[]
    cursor?: training_contentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Training_contentScalarFieldEnum | Training_contentScalarFieldEnum[]
  }

  /**
   * trainings.user_training_assignments
   */
  export type trainings$user_training_assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    where?: user_training_assignmentsWhereInput
    orderBy?: user_training_assignmentsOrderByWithRelationInput | user_training_assignmentsOrderByWithRelationInput[]
    cursor?: user_training_assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_training_assignmentsScalarFieldEnum | User_training_assignmentsScalarFieldEnum[]
  }

  /**
   * trainings.user_training_progress
   */
  export type trainings$user_training_progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    where?: user_training_progressWhereInput
    orderBy?: user_training_progressOrderByWithRelationInput | user_training_progressOrderByWithRelationInput[]
    cursor?: user_training_progressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_training_progressScalarFieldEnum | User_training_progressScalarFieldEnum[]
  }

  /**
   * trainings without action
   */
  export type trainingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the trainings
     */
    select?: trainingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the trainings
     */
    omit?: trainingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: trainingsInclude<ExtArgs> | null
  }


  /**
   * Model user_bootcamp_assignments
   */

  export type AggregateUser_bootcamp_assignments = {
    _count: User_bootcamp_assignmentsCountAggregateOutputType | null
    _avg: User_bootcamp_assignmentsAvgAggregateOutputType | null
    _sum: User_bootcamp_assignmentsSumAggregateOutputType | null
    _min: User_bootcamp_assignmentsMinAggregateOutputType | null
    _max: User_bootcamp_assignmentsMaxAggregateOutputType | null
  }

  export type User_bootcamp_assignmentsAvgAggregateOutputType = {
    user_id: number | null
  }

  export type User_bootcamp_assignmentsSumAggregateOutputType = {
    user_id: number | null
  }

  export type User_bootcamp_assignmentsMinAggregateOutputType = {
    id: string | null
    user_id: number | null
    bootcamp_id: string | null
    assigned_at: Date | null
    completed: boolean | null
    completion_date: Date | null
  }

  export type User_bootcamp_assignmentsMaxAggregateOutputType = {
    id: string | null
    user_id: number | null
    bootcamp_id: string | null
    assigned_at: Date | null
    completed: boolean | null
    completion_date: Date | null
  }

  export type User_bootcamp_assignmentsCountAggregateOutputType = {
    id: number
    user_id: number
    bootcamp_id: number
    assigned_at: number
    completed: number
    completion_date: number
    _all: number
  }


  export type User_bootcamp_assignmentsAvgAggregateInputType = {
    user_id?: true
  }

  export type User_bootcamp_assignmentsSumAggregateInputType = {
    user_id?: true
  }

  export type User_bootcamp_assignmentsMinAggregateInputType = {
    id?: true
    user_id?: true
    bootcamp_id?: true
    assigned_at?: true
    completed?: true
    completion_date?: true
  }

  export type User_bootcamp_assignmentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    bootcamp_id?: true
    assigned_at?: true
    completed?: true
    completion_date?: true
  }

  export type User_bootcamp_assignmentsCountAggregateInputType = {
    id?: true
    user_id?: true
    bootcamp_id?: true
    assigned_at?: true
    completed?: true
    completion_date?: true
    _all?: true
  }

  export type User_bootcamp_assignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_bootcamp_assignments to aggregate.
     */
    where?: user_bootcamp_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bootcamp_assignments to fetch.
     */
    orderBy?: user_bootcamp_assignmentsOrderByWithRelationInput | user_bootcamp_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_bootcamp_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bootcamp_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bootcamp_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_bootcamp_assignments
    **/
    _count?: true | User_bootcamp_assignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_bootcamp_assignmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_bootcamp_assignmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_bootcamp_assignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_bootcamp_assignmentsMaxAggregateInputType
  }

  export type GetUser_bootcamp_assignmentsAggregateType<T extends User_bootcamp_assignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_bootcamp_assignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_bootcamp_assignments[P]>
      : GetScalarType<T[P], AggregateUser_bootcamp_assignments[P]>
  }




  export type user_bootcamp_assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_bootcamp_assignmentsWhereInput
    orderBy?: user_bootcamp_assignmentsOrderByWithAggregationInput | user_bootcamp_assignmentsOrderByWithAggregationInput[]
    by: User_bootcamp_assignmentsScalarFieldEnum[] | User_bootcamp_assignmentsScalarFieldEnum
    having?: user_bootcamp_assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_bootcamp_assignmentsCountAggregateInputType | true
    _avg?: User_bootcamp_assignmentsAvgAggregateInputType
    _sum?: User_bootcamp_assignmentsSumAggregateInputType
    _min?: User_bootcamp_assignmentsMinAggregateInputType
    _max?: User_bootcamp_assignmentsMaxAggregateInputType
  }

  export type User_bootcamp_assignmentsGroupByOutputType = {
    id: string
    user_id: number
    bootcamp_id: string
    assigned_at: Date | null
    completed: boolean | null
    completion_date: Date | null
    _count: User_bootcamp_assignmentsCountAggregateOutputType | null
    _avg: User_bootcamp_assignmentsAvgAggregateOutputType | null
    _sum: User_bootcamp_assignmentsSumAggregateOutputType | null
    _min: User_bootcamp_assignmentsMinAggregateOutputType | null
    _max: User_bootcamp_assignmentsMaxAggregateOutputType | null
  }

  type GetUser_bootcamp_assignmentsGroupByPayload<T extends user_bootcamp_assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_bootcamp_assignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_bootcamp_assignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_bootcamp_assignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], User_bootcamp_assignmentsGroupByOutputType[P]>
        }
      >
    >


  export type user_bootcamp_assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bootcamp_id?: boolean
    assigned_at?: boolean
    completed?: boolean
    completion_date?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_bootcamp_assignments"]>

  export type user_bootcamp_assignmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bootcamp_id?: boolean
    assigned_at?: boolean
    completed?: boolean
    completion_date?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_bootcamp_assignments"]>

  export type user_bootcamp_assignmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    bootcamp_id?: boolean
    assigned_at?: boolean
    completed?: boolean
    completion_date?: boolean
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_bootcamp_assignments"]>

  export type user_bootcamp_assignmentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    bootcamp_id?: boolean
    assigned_at?: boolean
    completed?: boolean
    completion_date?: boolean
  }

  export type user_bootcamp_assignmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "bootcamp_id" | "assigned_at" | "completed" | "completion_date", ExtArgs["result"]["user_bootcamp_assignments"]>
  export type user_bootcamp_assignmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type user_bootcamp_assignmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type user_bootcamp_assignmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | bootcampsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $user_bootcamp_assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_bootcamp_assignments"
    objects: {
      bootcamps: Prisma.$bootcampsPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: number
      bootcamp_id: string
      assigned_at: Date | null
      completed: boolean | null
      completion_date: Date | null
    }, ExtArgs["result"]["user_bootcamp_assignments"]>
    composites: {}
  }

  type user_bootcamp_assignmentsGetPayload<S extends boolean | null | undefined | user_bootcamp_assignmentsDefaultArgs> = $Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload, S>

  type user_bootcamp_assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_bootcamp_assignmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_bootcamp_assignmentsCountAggregateInputType | true
    }

  export interface user_bootcamp_assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_bootcamp_assignments'], meta: { name: 'user_bootcamp_assignments' } }
    /**
     * Find zero or one User_bootcamp_assignments that matches the filter.
     * @param {user_bootcamp_assignmentsFindUniqueArgs} args - Arguments to find a User_bootcamp_assignments
     * @example
     * // Get one User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_bootcamp_assignmentsFindUniqueArgs>(args: SelectSubset<T, user_bootcamp_assignmentsFindUniqueArgs<ExtArgs>>): Prisma__user_bootcamp_assignmentsClient<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_bootcamp_assignments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_bootcamp_assignmentsFindUniqueOrThrowArgs} args - Arguments to find a User_bootcamp_assignments
     * @example
     * // Get one User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_bootcamp_assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_bootcamp_assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_bootcamp_assignmentsClient<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_bootcamp_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bootcamp_assignmentsFindFirstArgs} args - Arguments to find a User_bootcamp_assignments
     * @example
     * // Get one User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_bootcamp_assignmentsFindFirstArgs>(args?: SelectSubset<T, user_bootcamp_assignmentsFindFirstArgs<ExtArgs>>): Prisma__user_bootcamp_assignmentsClient<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_bootcamp_assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bootcamp_assignmentsFindFirstOrThrowArgs} args - Arguments to find a User_bootcamp_assignments
     * @example
     * // Get one User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_bootcamp_assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_bootcamp_assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_bootcamp_assignmentsClient<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_bootcamp_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bootcamp_assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.findMany()
     * 
     * // Get first 10 User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_bootcamp_assignmentsWithIdOnly = await prisma.user_bootcamp_assignments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_bootcamp_assignmentsFindManyArgs>(args?: SelectSubset<T, user_bootcamp_assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_bootcamp_assignments.
     * @param {user_bootcamp_assignmentsCreateArgs} args - Arguments to create a User_bootcamp_assignments.
     * @example
     * // Create one User_bootcamp_assignments
     * const User_bootcamp_assignments = await prisma.user_bootcamp_assignments.create({
     *   data: {
     *     // ... data to create a User_bootcamp_assignments
     *   }
     * })
     * 
     */
    create<T extends user_bootcamp_assignmentsCreateArgs>(args: SelectSubset<T, user_bootcamp_assignmentsCreateArgs<ExtArgs>>): Prisma__user_bootcamp_assignmentsClient<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_bootcamp_assignments.
     * @param {user_bootcamp_assignmentsCreateManyArgs} args - Arguments to create many User_bootcamp_assignments.
     * @example
     * // Create many User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_bootcamp_assignmentsCreateManyArgs>(args?: SelectSubset<T, user_bootcamp_assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_bootcamp_assignments and returns the data saved in the database.
     * @param {user_bootcamp_assignmentsCreateManyAndReturnArgs} args - Arguments to create many User_bootcamp_assignments.
     * @example
     * // Create many User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_bootcamp_assignments and only return the `id`
     * const user_bootcamp_assignmentsWithIdOnly = await prisma.user_bootcamp_assignments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_bootcamp_assignmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_bootcamp_assignmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_bootcamp_assignments.
     * @param {user_bootcamp_assignmentsDeleteArgs} args - Arguments to delete one User_bootcamp_assignments.
     * @example
     * // Delete one User_bootcamp_assignments
     * const User_bootcamp_assignments = await prisma.user_bootcamp_assignments.delete({
     *   where: {
     *     // ... filter to delete one User_bootcamp_assignments
     *   }
     * })
     * 
     */
    delete<T extends user_bootcamp_assignmentsDeleteArgs>(args: SelectSubset<T, user_bootcamp_assignmentsDeleteArgs<ExtArgs>>): Prisma__user_bootcamp_assignmentsClient<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_bootcamp_assignments.
     * @param {user_bootcamp_assignmentsUpdateArgs} args - Arguments to update one User_bootcamp_assignments.
     * @example
     * // Update one User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_bootcamp_assignmentsUpdateArgs>(args: SelectSubset<T, user_bootcamp_assignmentsUpdateArgs<ExtArgs>>): Prisma__user_bootcamp_assignmentsClient<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_bootcamp_assignments.
     * @param {user_bootcamp_assignmentsDeleteManyArgs} args - Arguments to filter User_bootcamp_assignments to delete.
     * @example
     * // Delete a few User_bootcamp_assignments
     * const { count } = await prisma.user_bootcamp_assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_bootcamp_assignmentsDeleteManyArgs>(args?: SelectSubset<T, user_bootcamp_assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_bootcamp_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bootcamp_assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_bootcamp_assignmentsUpdateManyArgs>(args: SelectSubset<T, user_bootcamp_assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_bootcamp_assignments and returns the data updated in the database.
     * @param {user_bootcamp_assignmentsUpdateManyAndReturnArgs} args - Arguments to update many User_bootcamp_assignments.
     * @example
     * // Update many User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_bootcamp_assignments and only return the `id`
     * const user_bootcamp_assignmentsWithIdOnly = await prisma.user_bootcamp_assignments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_bootcamp_assignmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_bootcamp_assignmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_bootcamp_assignments.
     * @param {user_bootcamp_assignmentsUpsertArgs} args - Arguments to update or create a User_bootcamp_assignments.
     * @example
     * // Update or create a User_bootcamp_assignments
     * const user_bootcamp_assignments = await prisma.user_bootcamp_assignments.upsert({
     *   create: {
     *     // ... data to create a User_bootcamp_assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_bootcamp_assignments we want to update
     *   }
     * })
     */
    upsert<T extends user_bootcamp_assignmentsUpsertArgs>(args: SelectSubset<T, user_bootcamp_assignmentsUpsertArgs<ExtArgs>>): Prisma__user_bootcamp_assignmentsClient<$Result.GetResult<Prisma.$user_bootcamp_assignmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_bootcamp_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bootcamp_assignmentsCountArgs} args - Arguments to filter User_bootcamp_assignments to count.
     * @example
     * // Count the number of User_bootcamp_assignments
     * const count = await prisma.user_bootcamp_assignments.count({
     *   where: {
     *     // ... the filter for the User_bootcamp_assignments we want to count
     *   }
     * })
    **/
    count<T extends user_bootcamp_assignmentsCountArgs>(
      args?: Subset<T, user_bootcamp_assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_bootcamp_assignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_bootcamp_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_bootcamp_assignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_bootcamp_assignmentsAggregateArgs>(args: Subset<T, User_bootcamp_assignmentsAggregateArgs>): Prisma.PrismaPromise<GetUser_bootcamp_assignmentsAggregateType<T>>

    /**
     * Group by User_bootcamp_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_bootcamp_assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_bootcamp_assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_bootcamp_assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: user_bootcamp_assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_bootcamp_assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_bootcamp_assignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_bootcamp_assignments model
   */
  readonly fields: user_bootcamp_assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_bootcamp_assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_bootcamp_assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bootcamps<T extends bootcampsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bootcampsDefaultArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_bootcamp_assignments model
   */
  interface user_bootcamp_assignmentsFieldRefs {
    readonly id: FieldRef<"user_bootcamp_assignments", 'String'>
    readonly user_id: FieldRef<"user_bootcamp_assignments", 'Int'>
    readonly bootcamp_id: FieldRef<"user_bootcamp_assignments", 'String'>
    readonly assigned_at: FieldRef<"user_bootcamp_assignments", 'DateTime'>
    readonly completed: FieldRef<"user_bootcamp_assignments", 'Boolean'>
    readonly completion_date: FieldRef<"user_bootcamp_assignments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_bootcamp_assignments findUnique
   */
  export type user_bootcamp_assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_bootcamp_assignments to fetch.
     */
    where: user_bootcamp_assignmentsWhereUniqueInput
  }

  /**
   * user_bootcamp_assignments findUniqueOrThrow
   */
  export type user_bootcamp_assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_bootcamp_assignments to fetch.
     */
    where: user_bootcamp_assignmentsWhereUniqueInput
  }

  /**
   * user_bootcamp_assignments findFirst
   */
  export type user_bootcamp_assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_bootcamp_assignments to fetch.
     */
    where?: user_bootcamp_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bootcamp_assignments to fetch.
     */
    orderBy?: user_bootcamp_assignmentsOrderByWithRelationInput | user_bootcamp_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_bootcamp_assignments.
     */
    cursor?: user_bootcamp_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bootcamp_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bootcamp_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_bootcamp_assignments.
     */
    distinct?: User_bootcamp_assignmentsScalarFieldEnum | User_bootcamp_assignmentsScalarFieldEnum[]
  }

  /**
   * user_bootcamp_assignments findFirstOrThrow
   */
  export type user_bootcamp_assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_bootcamp_assignments to fetch.
     */
    where?: user_bootcamp_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bootcamp_assignments to fetch.
     */
    orderBy?: user_bootcamp_assignmentsOrderByWithRelationInput | user_bootcamp_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_bootcamp_assignments.
     */
    cursor?: user_bootcamp_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bootcamp_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bootcamp_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_bootcamp_assignments.
     */
    distinct?: User_bootcamp_assignmentsScalarFieldEnum | User_bootcamp_assignmentsScalarFieldEnum[]
  }

  /**
   * user_bootcamp_assignments findMany
   */
  export type user_bootcamp_assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_bootcamp_assignments to fetch.
     */
    where?: user_bootcamp_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_bootcamp_assignments to fetch.
     */
    orderBy?: user_bootcamp_assignmentsOrderByWithRelationInput | user_bootcamp_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_bootcamp_assignments.
     */
    cursor?: user_bootcamp_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_bootcamp_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_bootcamp_assignments.
     */
    skip?: number
    distinct?: User_bootcamp_assignmentsScalarFieldEnum | User_bootcamp_assignmentsScalarFieldEnum[]
  }

  /**
   * user_bootcamp_assignments create
   */
  export type user_bootcamp_assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_bootcamp_assignments.
     */
    data: XOR<user_bootcamp_assignmentsCreateInput, user_bootcamp_assignmentsUncheckedCreateInput>
  }

  /**
   * user_bootcamp_assignments createMany
   */
  export type user_bootcamp_assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_bootcamp_assignments.
     */
    data: user_bootcamp_assignmentsCreateManyInput | user_bootcamp_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_bootcamp_assignments createManyAndReturn
   */
  export type user_bootcamp_assignmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to create many user_bootcamp_assignments.
     */
    data: user_bootcamp_assignmentsCreateManyInput | user_bootcamp_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_bootcamp_assignments update
   */
  export type user_bootcamp_assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_bootcamp_assignments.
     */
    data: XOR<user_bootcamp_assignmentsUpdateInput, user_bootcamp_assignmentsUncheckedUpdateInput>
    /**
     * Choose, which user_bootcamp_assignments to update.
     */
    where: user_bootcamp_assignmentsWhereUniqueInput
  }

  /**
   * user_bootcamp_assignments updateMany
   */
  export type user_bootcamp_assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_bootcamp_assignments.
     */
    data: XOR<user_bootcamp_assignmentsUpdateManyMutationInput, user_bootcamp_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which user_bootcamp_assignments to update
     */
    where?: user_bootcamp_assignmentsWhereInput
    /**
     * Limit how many user_bootcamp_assignments to update.
     */
    limit?: number
  }

  /**
   * user_bootcamp_assignments updateManyAndReturn
   */
  export type user_bootcamp_assignmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to update user_bootcamp_assignments.
     */
    data: XOR<user_bootcamp_assignmentsUpdateManyMutationInput, user_bootcamp_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which user_bootcamp_assignments to update
     */
    where?: user_bootcamp_assignmentsWhereInput
    /**
     * Limit how many user_bootcamp_assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_bootcamp_assignments upsert
   */
  export type user_bootcamp_assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_bootcamp_assignments to update in case it exists.
     */
    where: user_bootcamp_assignmentsWhereUniqueInput
    /**
     * In case the user_bootcamp_assignments found by the `where` argument doesn't exist, create a new user_bootcamp_assignments with this data.
     */
    create: XOR<user_bootcamp_assignmentsCreateInput, user_bootcamp_assignmentsUncheckedCreateInput>
    /**
     * In case the user_bootcamp_assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_bootcamp_assignmentsUpdateInput, user_bootcamp_assignmentsUncheckedUpdateInput>
  }

  /**
   * user_bootcamp_assignments delete
   */
  export type user_bootcamp_assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
    /**
     * Filter which user_bootcamp_assignments to delete.
     */
    where: user_bootcamp_assignmentsWhereUniqueInput
  }

  /**
   * user_bootcamp_assignments deleteMany
   */
  export type user_bootcamp_assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_bootcamp_assignments to delete
     */
    where?: user_bootcamp_assignmentsWhereInput
    /**
     * Limit how many user_bootcamp_assignments to delete.
     */
    limit?: number
  }

  /**
   * user_bootcamp_assignments without action
   */
  export type user_bootcamp_assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_bootcamp_assignments
     */
    select?: user_bootcamp_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_bootcamp_assignments
     */
    omit?: user_bootcamp_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_bootcamp_assignmentsInclude<ExtArgs> | null
  }


  /**
   * Model user_quiz_attempts
   */

  export type AggregateUser_quiz_attempts = {
    _count: User_quiz_attemptsCountAggregateOutputType | null
    _avg: User_quiz_attemptsAvgAggregateOutputType | null
    _sum: User_quiz_attemptsSumAggregateOutputType | null
    _min: User_quiz_attemptsMinAggregateOutputType | null
    _max: User_quiz_attemptsMaxAggregateOutputType | null
  }

  export type User_quiz_attemptsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    attempt_number: number | null
    score: Decimal | null
  }

  export type User_quiz_attemptsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    attempt_number: number | null
    score: Decimal | null
  }

  export type User_quiz_attemptsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    quiz_id: string | null
    training_id: string | null
    attempt_number: number | null
    score: Decimal | null
    passed: boolean | null
    submitted_at: Date | null
  }

  export type User_quiz_attemptsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    quiz_id: string | null
    training_id: string | null
    attempt_number: number | null
    score: Decimal | null
    passed: boolean | null
    submitted_at: Date | null
  }

  export type User_quiz_attemptsCountAggregateOutputType = {
    id: number
    user_id: number
    quiz_id: number
    training_id: number
    attempt_number: number
    score: number
    passed: number
    submitted_at: number
    answers: number
    _all: number
  }


  export type User_quiz_attemptsAvgAggregateInputType = {
    id?: true
    user_id?: true
    attempt_number?: true
    score?: true
  }

  export type User_quiz_attemptsSumAggregateInputType = {
    id?: true
    user_id?: true
    attempt_number?: true
    score?: true
  }

  export type User_quiz_attemptsMinAggregateInputType = {
    id?: true
    user_id?: true
    quiz_id?: true
    training_id?: true
    attempt_number?: true
    score?: true
    passed?: true
    submitted_at?: true
  }

  export type User_quiz_attemptsMaxAggregateInputType = {
    id?: true
    user_id?: true
    quiz_id?: true
    training_id?: true
    attempt_number?: true
    score?: true
    passed?: true
    submitted_at?: true
  }

  export type User_quiz_attemptsCountAggregateInputType = {
    id?: true
    user_id?: true
    quiz_id?: true
    training_id?: true
    attempt_number?: true
    score?: true
    passed?: true
    submitted_at?: true
    answers?: true
    _all?: true
  }

  export type User_quiz_attemptsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_quiz_attempts to aggregate.
     */
    where?: user_quiz_attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_quiz_attempts to fetch.
     */
    orderBy?: user_quiz_attemptsOrderByWithRelationInput | user_quiz_attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_quiz_attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_quiz_attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_quiz_attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_quiz_attempts
    **/
    _count?: true | User_quiz_attemptsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_quiz_attemptsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_quiz_attemptsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_quiz_attemptsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_quiz_attemptsMaxAggregateInputType
  }

  export type GetUser_quiz_attemptsAggregateType<T extends User_quiz_attemptsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_quiz_attempts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_quiz_attempts[P]>
      : GetScalarType<T[P], AggregateUser_quiz_attempts[P]>
  }




  export type user_quiz_attemptsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_quiz_attemptsWhereInput
    orderBy?: user_quiz_attemptsOrderByWithAggregationInput | user_quiz_attemptsOrderByWithAggregationInput[]
    by: User_quiz_attemptsScalarFieldEnum[] | User_quiz_attemptsScalarFieldEnum
    having?: user_quiz_attemptsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_quiz_attemptsCountAggregateInputType | true
    _avg?: User_quiz_attemptsAvgAggregateInputType
    _sum?: User_quiz_attemptsSumAggregateInputType
    _min?: User_quiz_attemptsMinAggregateInputType
    _max?: User_quiz_attemptsMaxAggregateInputType
  }

  export type User_quiz_attemptsGroupByOutputType = {
    id: number
    user_id: number
    quiz_id: string
    training_id: string
    attempt_number: number
    score: Decimal
    passed: boolean
    submitted_at: Date
    answers: JsonValue | null
    _count: User_quiz_attemptsCountAggregateOutputType | null
    _avg: User_quiz_attemptsAvgAggregateOutputType | null
    _sum: User_quiz_attemptsSumAggregateOutputType | null
    _min: User_quiz_attemptsMinAggregateOutputType | null
    _max: User_quiz_attemptsMaxAggregateOutputType | null
  }

  type GetUser_quiz_attemptsGroupByPayload<T extends user_quiz_attemptsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_quiz_attemptsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_quiz_attemptsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_quiz_attemptsGroupByOutputType[P]>
            : GetScalarType<T[P], User_quiz_attemptsGroupByOutputType[P]>
        }
      >
    >


  export type user_quiz_attemptsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    quiz_id?: boolean
    training_id?: boolean
    attempt_number?: boolean
    score?: boolean
    passed?: boolean
    submitted_at?: boolean
    answers?: boolean
  }, ExtArgs["result"]["user_quiz_attempts"]>

  export type user_quiz_attemptsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    quiz_id?: boolean
    training_id?: boolean
    attempt_number?: boolean
    score?: boolean
    passed?: boolean
    submitted_at?: boolean
    answers?: boolean
  }, ExtArgs["result"]["user_quiz_attempts"]>

  export type user_quiz_attemptsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    quiz_id?: boolean
    training_id?: boolean
    attempt_number?: boolean
    score?: boolean
    passed?: boolean
    submitted_at?: boolean
    answers?: boolean
  }, ExtArgs["result"]["user_quiz_attempts"]>

  export type user_quiz_attemptsSelectScalar = {
    id?: boolean
    user_id?: boolean
    quiz_id?: boolean
    training_id?: boolean
    attempt_number?: boolean
    score?: boolean
    passed?: boolean
    submitted_at?: boolean
    answers?: boolean
  }

  export type user_quiz_attemptsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "quiz_id" | "training_id" | "attempt_number" | "score" | "passed" | "submitted_at" | "answers", ExtArgs["result"]["user_quiz_attempts"]>

  export type $user_quiz_attemptsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_quiz_attempts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      quiz_id: string
      training_id: string
      attempt_number: number
      score: Prisma.Decimal
      passed: boolean
      submitted_at: Date
      answers: Prisma.JsonValue | null
    }, ExtArgs["result"]["user_quiz_attempts"]>
    composites: {}
  }

  type user_quiz_attemptsGetPayload<S extends boolean | null | undefined | user_quiz_attemptsDefaultArgs> = $Result.GetResult<Prisma.$user_quiz_attemptsPayload, S>

  type user_quiz_attemptsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_quiz_attemptsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_quiz_attemptsCountAggregateInputType | true
    }

  export interface user_quiz_attemptsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_quiz_attempts'], meta: { name: 'user_quiz_attempts' } }
    /**
     * Find zero or one User_quiz_attempts that matches the filter.
     * @param {user_quiz_attemptsFindUniqueArgs} args - Arguments to find a User_quiz_attempts
     * @example
     * // Get one User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_quiz_attemptsFindUniqueArgs>(args: SelectSubset<T, user_quiz_attemptsFindUniqueArgs<ExtArgs>>): Prisma__user_quiz_attemptsClient<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_quiz_attempts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_quiz_attemptsFindUniqueOrThrowArgs} args - Arguments to find a User_quiz_attempts
     * @example
     * // Get one User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_quiz_attemptsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_quiz_attemptsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_quiz_attemptsClient<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_quiz_attempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quiz_attemptsFindFirstArgs} args - Arguments to find a User_quiz_attempts
     * @example
     * // Get one User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_quiz_attemptsFindFirstArgs>(args?: SelectSubset<T, user_quiz_attemptsFindFirstArgs<ExtArgs>>): Prisma__user_quiz_attemptsClient<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_quiz_attempts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quiz_attemptsFindFirstOrThrowArgs} args - Arguments to find a User_quiz_attempts
     * @example
     * // Get one User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_quiz_attemptsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_quiz_attemptsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_quiz_attemptsClient<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_quiz_attempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quiz_attemptsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.findMany()
     * 
     * // Get first 10 User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_quiz_attemptsWithIdOnly = await prisma.user_quiz_attempts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_quiz_attemptsFindManyArgs>(args?: SelectSubset<T, user_quiz_attemptsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_quiz_attempts.
     * @param {user_quiz_attemptsCreateArgs} args - Arguments to create a User_quiz_attempts.
     * @example
     * // Create one User_quiz_attempts
     * const User_quiz_attempts = await prisma.user_quiz_attempts.create({
     *   data: {
     *     // ... data to create a User_quiz_attempts
     *   }
     * })
     * 
     */
    create<T extends user_quiz_attemptsCreateArgs>(args: SelectSubset<T, user_quiz_attemptsCreateArgs<ExtArgs>>): Prisma__user_quiz_attemptsClient<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_quiz_attempts.
     * @param {user_quiz_attemptsCreateManyArgs} args - Arguments to create many User_quiz_attempts.
     * @example
     * // Create many User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_quiz_attemptsCreateManyArgs>(args?: SelectSubset<T, user_quiz_attemptsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_quiz_attempts and returns the data saved in the database.
     * @param {user_quiz_attemptsCreateManyAndReturnArgs} args - Arguments to create many User_quiz_attempts.
     * @example
     * // Create many User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_quiz_attempts and only return the `id`
     * const user_quiz_attemptsWithIdOnly = await prisma.user_quiz_attempts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_quiz_attemptsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_quiz_attemptsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_quiz_attempts.
     * @param {user_quiz_attemptsDeleteArgs} args - Arguments to delete one User_quiz_attempts.
     * @example
     * // Delete one User_quiz_attempts
     * const User_quiz_attempts = await prisma.user_quiz_attempts.delete({
     *   where: {
     *     // ... filter to delete one User_quiz_attempts
     *   }
     * })
     * 
     */
    delete<T extends user_quiz_attemptsDeleteArgs>(args: SelectSubset<T, user_quiz_attemptsDeleteArgs<ExtArgs>>): Prisma__user_quiz_attemptsClient<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_quiz_attempts.
     * @param {user_quiz_attemptsUpdateArgs} args - Arguments to update one User_quiz_attempts.
     * @example
     * // Update one User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_quiz_attemptsUpdateArgs>(args: SelectSubset<T, user_quiz_attemptsUpdateArgs<ExtArgs>>): Prisma__user_quiz_attemptsClient<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_quiz_attempts.
     * @param {user_quiz_attemptsDeleteManyArgs} args - Arguments to filter User_quiz_attempts to delete.
     * @example
     * // Delete a few User_quiz_attempts
     * const { count } = await prisma.user_quiz_attempts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_quiz_attemptsDeleteManyArgs>(args?: SelectSubset<T, user_quiz_attemptsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_quiz_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quiz_attemptsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_quiz_attemptsUpdateManyArgs>(args: SelectSubset<T, user_quiz_attemptsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_quiz_attempts and returns the data updated in the database.
     * @param {user_quiz_attemptsUpdateManyAndReturnArgs} args - Arguments to update many User_quiz_attempts.
     * @example
     * // Update many User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_quiz_attempts and only return the `id`
     * const user_quiz_attemptsWithIdOnly = await prisma.user_quiz_attempts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_quiz_attemptsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_quiz_attemptsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_quiz_attempts.
     * @param {user_quiz_attemptsUpsertArgs} args - Arguments to update or create a User_quiz_attempts.
     * @example
     * // Update or create a User_quiz_attempts
     * const user_quiz_attempts = await prisma.user_quiz_attempts.upsert({
     *   create: {
     *     // ... data to create a User_quiz_attempts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_quiz_attempts we want to update
     *   }
     * })
     */
    upsert<T extends user_quiz_attemptsUpsertArgs>(args: SelectSubset<T, user_quiz_attemptsUpsertArgs<ExtArgs>>): Prisma__user_quiz_attemptsClient<$Result.GetResult<Prisma.$user_quiz_attemptsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_quiz_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quiz_attemptsCountArgs} args - Arguments to filter User_quiz_attempts to count.
     * @example
     * // Count the number of User_quiz_attempts
     * const count = await prisma.user_quiz_attempts.count({
     *   where: {
     *     // ... the filter for the User_quiz_attempts we want to count
     *   }
     * })
    **/
    count<T extends user_quiz_attemptsCountArgs>(
      args?: Subset<T, user_quiz_attemptsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_quiz_attemptsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_quiz_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_quiz_attemptsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_quiz_attemptsAggregateArgs>(args: Subset<T, User_quiz_attemptsAggregateArgs>): Prisma.PrismaPromise<GetUser_quiz_attemptsAggregateType<T>>

    /**
     * Group by User_quiz_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_quiz_attemptsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_quiz_attemptsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_quiz_attemptsGroupByArgs['orderBy'] }
        : { orderBy?: user_quiz_attemptsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_quiz_attemptsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_quiz_attemptsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_quiz_attempts model
   */
  readonly fields: user_quiz_attemptsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_quiz_attempts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_quiz_attemptsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_quiz_attempts model
   */
  interface user_quiz_attemptsFieldRefs {
    readonly id: FieldRef<"user_quiz_attempts", 'Int'>
    readonly user_id: FieldRef<"user_quiz_attempts", 'Int'>
    readonly quiz_id: FieldRef<"user_quiz_attempts", 'String'>
    readonly training_id: FieldRef<"user_quiz_attempts", 'String'>
    readonly attempt_number: FieldRef<"user_quiz_attempts", 'Int'>
    readonly score: FieldRef<"user_quiz_attempts", 'Decimal'>
    readonly passed: FieldRef<"user_quiz_attempts", 'Boolean'>
    readonly submitted_at: FieldRef<"user_quiz_attempts", 'DateTime'>
    readonly answers: FieldRef<"user_quiz_attempts", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * user_quiz_attempts findUnique
   */
  export type user_quiz_attemptsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * Filter, which user_quiz_attempts to fetch.
     */
    where: user_quiz_attemptsWhereUniqueInput
  }

  /**
   * user_quiz_attempts findUniqueOrThrow
   */
  export type user_quiz_attemptsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * Filter, which user_quiz_attempts to fetch.
     */
    where: user_quiz_attemptsWhereUniqueInput
  }

  /**
   * user_quiz_attempts findFirst
   */
  export type user_quiz_attemptsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * Filter, which user_quiz_attempts to fetch.
     */
    where?: user_quiz_attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_quiz_attempts to fetch.
     */
    orderBy?: user_quiz_attemptsOrderByWithRelationInput | user_quiz_attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_quiz_attempts.
     */
    cursor?: user_quiz_attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_quiz_attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_quiz_attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_quiz_attempts.
     */
    distinct?: User_quiz_attemptsScalarFieldEnum | User_quiz_attemptsScalarFieldEnum[]
  }

  /**
   * user_quiz_attempts findFirstOrThrow
   */
  export type user_quiz_attemptsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * Filter, which user_quiz_attempts to fetch.
     */
    where?: user_quiz_attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_quiz_attempts to fetch.
     */
    orderBy?: user_quiz_attemptsOrderByWithRelationInput | user_quiz_attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_quiz_attempts.
     */
    cursor?: user_quiz_attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_quiz_attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_quiz_attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_quiz_attempts.
     */
    distinct?: User_quiz_attemptsScalarFieldEnum | User_quiz_attemptsScalarFieldEnum[]
  }

  /**
   * user_quiz_attempts findMany
   */
  export type user_quiz_attemptsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * Filter, which user_quiz_attempts to fetch.
     */
    where?: user_quiz_attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_quiz_attempts to fetch.
     */
    orderBy?: user_quiz_attemptsOrderByWithRelationInput | user_quiz_attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_quiz_attempts.
     */
    cursor?: user_quiz_attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_quiz_attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_quiz_attempts.
     */
    skip?: number
    distinct?: User_quiz_attemptsScalarFieldEnum | User_quiz_attemptsScalarFieldEnum[]
  }

  /**
   * user_quiz_attempts create
   */
  export type user_quiz_attemptsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * The data needed to create a user_quiz_attempts.
     */
    data: XOR<user_quiz_attemptsCreateInput, user_quiz_attemptsUncheckedCreateInput>
  }

  /**
   * user_quiz_attempts createMany
   */
  export type user_quiz_attemptsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_quiz_attempts.
     */
    data: user_quiz_attemptsCreateManyInput | user_quiz_attemptsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_quiz_attempts createManyAndReturn
   */
  export type user_quiz_attemptsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * The data used to create many user_quiz_attempts.
     */
    data: user_quiz_attemptsCreateManyInput | user_quiz_attemptsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_quiz_attempts update
   */
  export type user_quiz_attemptsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * The data needed to update a user_quiz_attempts.
     */
    data: XOR<user_quiz_attemptsUpdateInput, user_quiz_attemptsUncheckedUpdateInput>
    /**
     * Choose, which user_quiz_attempts to update.
     */
    where: user_quiz_attemptsWhereUniqueInput
  }

  /**
   * user_quiz_attempts updateMany
   */
  export type user_quiz_attemptsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_quiz_attempts.
     */
    data: XOR<user_quiz_attemptsUpdateManyMutationInput, user_quiz_attemptsUncheckedUpdateManyInput>
    /**
     * Filter which user_quiz_attempts to update
     */
    where?: user_quiz_attemptsWhereInput
    /**
     * Limit how many user_quiz_attempts to update.
     */
    limit?: number
  }

  /**
   * user_quiz_attempts updateManyAndReturn
   */
  export type user_quiz_attemptsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * The data used to update user_quiz_attempts.
     */
    data: XOR<user_quiz_attemptsUpdateManyMutationInput, user_quiz_attemptsUncheckedUpdateManyInput>
    /**
     * Filter which user_quiz_attempts to update
     */
    where?: user_quiz_attemptsWhereInput
    /**
     * Limit how many user_quiz_attempts to update.
     */
    limit?: number
  }

  /**
   * user_quiz_attempts upsert
   */
  export type user_quiz_attemptsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * The filter to search for the user_quiz_attempts to update in case it exists.
     */
    where: user_quiz_attemptsWhereUniqueInput
    /**
     * In case the user_quiz_attempts found by the `where` argument doesn't exist, create a new user_quiz_attempts with this data.
     */
    create: XOR<user_quiz_attemptsCreateInput, user_quiz_attemptsUncheckedCreateInput>
    /**
     * In case the user_quiz_attempts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_quiz_attemptsUpdateInput, user_quiz_attemptsUncheckedUpdateInput>
  }

  /**
   * user_quiz_attempts delete
   */
  export type user_quiz_attemptsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
    /**
     * Filter which user_quiz_attempts to delete.
     */
    where: user_quiz_attemptsWhereUniqueInput
  }

  /**
   * user_quiz_attempts deleteMany
   */
  export type user_quiz_attemptsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_quiz_attempts to delete
     */
    where?: user_quiz_attemptsWhereInput
    /**
     * Limit how many user_quiz_attempts to delete.
     */
    limit?: number
  }

  /**
   * user_quiz_attempts without action
   */
  export type user_quiz_attemptsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_quiz_attempts
     */
    select?: user_quiz_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_quiz_attempts
     */
    omit?: user_quiz_attemptsOmit<ExtArgs> | null
  }


  /**
   * Model user_training_assignments
   */

  export type AggregateUser_training_assignments = {
    _count: User_training_assignmentsCountAggregateOutputType | null
    _avg: User_training_assignmentsAvgAggregateOutputType | null
    _sum: User_training_assignmentsSumAggregateOutputType | null
    _min: User_training_assignmentsMinAggregateOutputType | null
    _max: User_training_assignmentsMaxAggregateOutputType | null
  }

  export type User_training_assignmentsAvgAggregateOutputType = {
    assignment_id: number | null
    user_id: number | null
  }

  export type User_training_assignmentsSumAggregateOutputType = {
    assignment_id: number | null
    user_id: number | null
  }

  export type User_training_assignmentsMinAggregateOutputType = {
    assignment_id: number | null
    user_id: number | null
    training_id: string | null
    assigned_at: Date | null
  }

  export type User_training_assignmentsMaxAggregateOutputType = {
    assignment_id: number | null
    user_id: number | null
    training_id: string | null
    assigned_at: Date | null
  }

  export type User_training_assignmentsCountAggregateOutputType = {
    assignment_id: number
    user_id: number
    training_id: number
    assigned_at: number
    _all: number
  }


  export type User_training_assignmentsAvgAggregateInputType = {
    assignment_id?: true
    user_id?: true
  }

  export type User_training_assignmentsSumAggregateInputType = {
    assignment_id?: true
    user_id?: true
  }

  export type User_training_assignmentsMinAggregateInputType = {
    assignment_id?: true
    user_id?: true
    training_id?: true
    assigned_at?: true
  }

  export type User_training_assignmentsMaxAggregateInputType = {
    assignment_id?: true
    user_id?: true
    training_id?: true
    assigned_at?: true
  }

  export type User_training_assignmentsCountAggregateInputType = {
    assignment_id?: true
    user_id?: true
    training_id?: true
    assigned_at?: true
    _all?: true
  }

  export type User_training_assignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_training_assignments to aggregate.
     */
    where?: user_training_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_training_assignments to fetch.
     */
    orderBy?: user_training_assignmentsOrderByWithRelationInput | user_training_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_training_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_training_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_training_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_training_assignments
    **/
    _count?: true | User_training_assignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_training_assignmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_training_assignmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_training_assignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_training_assignmentsMaxAggregateInputType
  }

  export type GetUser_training_assignmentsAggregateType<T extends User_training_assignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_training_assignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_training_assignments[P]>
      : GetScalarType<T[P], AggregateUser_training_assignments[P]>
  }




  export type user_training_assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_training_assignmentsWhereInput
    orderBy?: user_training_assignmentsOrderByWithAggregationInput | user_training_assignmentsOrderByWithAggregationInput[]
    by: User_training_assignmentsScalarFieldEnum[] | User_training_assignmentsScalarFieldEnum
    having?: user_training_assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_training_assignmentsCountAggregateInputType | true
    _avg?: User_training_assignmentsAvgAggregateInputType
    _sum?: User_training_assignmentsSumAggregateInputType
    _min?: User_training_assignmentsMinAggregateInputType
    _max?: User_training_assignmentsMaxAggregateInputType
  }

  export type User_training_assignmentsGroupByOutputType = {
    assignment_id: number
    user_id: number
    training_id: string
    assigned_at: Date | null
    _count: User_training_assignmentsCountAggregateOutputType | null
    _avg: User_training_assignmentsAvgAggregateOutputType | null
    _sum: User_training_assignmentsSumAggregateOutputType | null
    _min: User_training_assignmentsMinAggregateOutputType | null
    _max: User_training_assignmentsMaxAggregateOutputType | null
  }

  type GetUser_training_assignmentsGroupByPayload<T extends user_training_assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_training_assignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_training_assignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_training_assignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], User_training_assignmentsGroupByOutputType[P]>
        }
      >
    >


  export type user_training_assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    user_id?: boolean
    training_id?: boolean
    assigned_at?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_training_assignments"]>

  export type user_training_assignmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    user_id?: boolean
    training_id?: boolean
    assigned_at?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_training_assignments"]>

  export type user_training_assignmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignment_id?: boolean
    user_id?: boolean
    training_id?: boolean
    assigned_at?: boolean
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_training_assignments"]>

  export type user_training_assignmentsSelectScalar = {
    assignment_id?: boolean
    user_id?: boolean
    training_id?: boolean
    assigned_at?: boolean
  }

  export type user_training_assignmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"assignment_id" | "user_id" | "training_id" | "assigned_at", ExtArgs["result"]["user_training_assignments"]>
  export type user_training_assignmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type user_training_assignmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type user_training_assignmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $user_training_assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_training_assignments"
    objects: {
      trainings: Prisma.$trainingsPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      assignment_id: number
      user_id: number
      training_id: string
      assigned_at: Date | null
    }, ExtArgs["result"]["user_training_assignments"]>
    composites: {}
  }

  type user_training_assignmentsGetPayload<S extends boolean | null | undefined | user_training_assignmentsDefaultArgs> = $Result.GetResult<Prisma.$user_training_assignmentsPayload, S>

  type user_training_assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_training_assignmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_training_assignmentsCountAggregateInputType | true
    }

  export interface user_training_assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_training_assignments'], meta: { name: 'user_training_assignments' } }
    /**
     * Find zero or one User_training_assignments that matches the filter.
     * @param {user_training_assignmentsFindUniqueArgs} args - Arguments to find a User_training_assignments
     * @example
     * // Get one User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_training_assignmentsFindUniqueArgs>(args: SelectSubset<T, user_training_assignmentsFindUniqueArgs<ExtArgs>>): Prisma__user_training_assignmentsClient<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_training_assignments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_training_assignmentsFindUniqueOrThrowArgs} args - Arguments to find a User_training_assignments
     * @example
     * // Get one User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_training_assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, user_training_assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_training_assignmentsClient<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_training_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_assignmentsFindFirstArgs} args - Arguments to find a User_training_assignments
     * @example
     * // Get one User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_training_assignmentsFindFirstArgs>(args?: SelectSubset<T, user_training_assignmentsFindFirstArgs<ExtArgs>>): Prisma__user_training_assignmentsClient<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_training_assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_assignmentsFindFirstOrThrowArgs} args - Arguments to find a User_training_assignments
     * @example
     * // Get one User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_training_assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, user_training_assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_training_assignmentsClient<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_training_assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.findMany()
     * 
     * // Get first 10 User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.findMany({ take: 10 })
     * 
     * // Only select the `assignment_id`
     * const user_training_assignmentsWithAssignment_idOnly = await prisma.user_training_assignments.findMany({ select: { assignment_id: true } })
     * 
     */
    findMany<T extends user_training_assignmentsFindManyArgs>(args?: SelectSubset<T, user_training_assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_training_assignments.
     * @param {user_training_assignmentsCreateArgs} args - Arguments to create a User_training_assignments.
     * @example
     * // Create one User_training_assignments
     * const User_training_assignments = await prisma.user_training_assignments.create({
     *   data: {
     *     // ... data to create a User_training_assignments
     *   }
     * })
     * 
     */
    create<T extends user_training_assignmentsCreateArgs>(args: SelectSubset<T, user_training_assignmentsCreateArgs<ExtArgs>>): Prisma__user_training_assignmentsClient<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_training_assignments.
     * @param {user_training_assignmentsCreateManyArgs} args - Arguments to create many User_training_assignments.
     * @example
     * // Create many User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_training_assignmentsCreateManyArgs>(args?: SelectSubset<T, user_training_assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_training_assignments and returns the data saved in the database.
     * @param {user_training_assignmentsCreateManyAndReturnArgs} args - Arguments to create many User_training_assignments.
     * @example
     * // Create many User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_training_assignments and only return the `assignment_id`
     * const user_training_assignmentsWithAssignment_idOnly = await prisma.user_training_assignments.createManyAndReturn({
     *   select: { assignment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_training_assignmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, user_training_assignmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_training_assignments.
     * @param {user_training_assignmentsDeleteArgs} args - Arguments to delete one User_training_assignments.
     * @example
     * // Delete one User_training_assignments
     * const User_training_assignments = await prisma.user_training_assignments.delete({
     *   where: {
     *     // ... filter to delete one User_training_assignments
     *   }
     * })
     * 
     */
    delete<T extends user_training_assignmentsDeleteArgs>(args: SelectSubset<T, user_training_assignmentsDeleteArgs<ExtArgs>>): Prisma__user_training_assignmentsClient<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_training_assignments.
     * @param {user_training_assignmentsUpdateArgs} args - Arguments to update one User_training_assignments.
     * @example
     * // Update one User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_training_assignmentsUpdateArgs>(args: SelectSubset<T, user_training_assignmentsUpdateArgs<ExtArgs>>): Prisma__user_training_assignmentsClient<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_training_assignments.
     * @param {user_training_assignmentsDeleteManyArgs} args - Arguments to filter User_training_assignments to delete.
     * @example
     * // Delete a few User_training_assignments
     * const { count } = await prisma.user_training_assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_training_assignmentsDeleteManyArgs>(args?: SelectSubset<T, user_training_assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_training_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_training_assignmentsUpdateManyArgs>(args: SelectSubset<T, user_training_assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_training_assignments and returns the data updated in the database.
     * @param {user_training_assignmentsUpdateManyAndReturnArgs} args - Arguments to update many User_training_assignments.
     * @example
     * // Update many User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_training_assignments and only return the `assignment_id`
     * const user_training_assignmentsWithAssignment_idOnly = await prisma.user_training_assignments.updateManyAndReturn({
     *   select: { assignment_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_training_assignmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, user_training_assignmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_training_assignments.
     * @param {user_training_assignmentsUpsertArgs} args - Arguments to update or create a User_training_assignments.
     * @example
     * // Update or create a User_training_assignments
     * const user_training_assignments = await prisma.user_training_assignments.upsert({
     *   create: {
     *     // ... data to create a User_training_assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_training_assignments we want to update
     *   }
     * })
     */
    upsert<T extends user_training_assignmentsUpsertArgs>(args: SelectSubset<T, user_training_assignmentsUpsertArgs<ExtArgs>>): Prisma__user_training_assignmentsClient<$Result.GetResult<Prisma.$user_training_assignmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_training_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_assignmentsCountArgs} args - Arguments to filter User_training_assignments to count.
     * @example
     * // Count the number of User_training_assignments
     * const count = await prisma.user_training_assignments.count({
     *   where: {
     *     // ... the filter for the User_training_assignments we want to count
     *   }
     * })
    **/
    count<T extends user_training_assignmentsCountArgs>(
      args?: Subset<T, user_training_assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_training_assignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_training_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_training_assignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_training_assignmentsAggregateArgs>(args: Subset<T, User_training_assignmentsAggregateArgs>): Prisma.PrismaPromise<GetUser_training_assignmentsAggregateType<T>>

    /**
     * Group by User_training_assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_training_assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_training_assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: user_training_assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_training_assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_training_assignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_training_assignments model
   */
  readonly fields: user_training_assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_training_assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_training_assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trainings<T extends trainingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, trainingsDefaultArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_training_assignments model
   */
  interface user_training_assignmentsFieldRefs {
    readonly assignment_id: FieldRef<"user_training_assignments", 'Int'>
    readonly user_id: FieldRef<"user_training_assignments", 'Int'>
    readonly training_id: FieldRef<"user_training_assignments", 'String'>
    readonly assigned_at: FieldRef<"user_training_assignments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_training_assignments findUnique
   */
  export type user_training_assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_training_assignments to fetch.
     */
    where: user_training_assignmentsWhereUniqueInput
  }

  /**
   * user_training_assignments findUniqueOrThrow
   */
  export type user_training_assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_training_assignments to fetch.
     */
    where: user_training_assignmentsWhereUniqueInput
  }

  /**
   * user_training_assignments findFirst
   */
  export type user_training_assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_training_assignments to fetch.
     */
    where?: user_training_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_training_assignments to fetch.
     */
    orderBy?: user_training_assignmentsOrderByWithRelationInput | user_training_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_training_assignments.
     */
    cursor?: user_training_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_training_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_training_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_training_assignments.
     */
    distinct?: User_training_assignmentsScalarFieldEnum | User_training_assignmentsScalarFieldEnum[]
  }

  /**
   * user_training_assignments findFirstOrThrow
   */
  export type user_training_assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_training_assignments to fetch.
     */
    where?: user_training_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_training_assignments to fetch.
     */
    orderBy?: user_training_assignmentsOrderByWithRelationInput | user_training_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_training_assignments.
     */
    cursor?: user_training_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_training_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_training_assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_training_assignments.
     */
    distinct?: User_training_assignmentsScalarFieldEnum | User_training_assignmentsScalarFieldEnum[]
  }

  /**
   * user_training_assignments findMany
   */
  export type user_training_assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which user_training_assignments to fetch.
     */
    where?: user_training_assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_training_assignments to fetch.
     */
    orderBy?: user_training_assignmentsOrderByWithRelationInput | user_training_assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_training_assignments.
     */
    cursor?: user_training_assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_training_assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_training_assignments.
     */
    skip?: number
    distinct?: User_training_assignmentsScalarFieldEnum | User_training_assignmentsScalarFieldEnum[]
  }

  /**
   * user_training_assignments create
   */
  export type user_training_assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a user_training_assignments.
     */
    data: XOR<user_training_assignmentsCreateInput, user_training_assignmentsUncheckedCreateInput>
  }

  /**
   * user_training_assignments createMany
   */
  export type user_training_assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_training_assignments.
     */
    data: user_training_assignmentsCreateManyInput | user_training_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_training_assignments createManyAndReturn
   */
  export type user_training_assignmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to create many user_training_assignments.
     */
    data: user_training_assignmentsCreateManyInput | user_training_assignmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_training_assignments update
   */
  export type user_training_assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a user_training_assignments.
     */
    data: XOR<user_training_assignmentsUpdateInput, user_training_assignmentsUncheckedUpdateInput>
    /**
     * Choose, which user_training_assignments to update.
     */
    where: user_training_assignmentsWhereUniqueInput
  }

  /**
   * user_training_assignments updateMany
   */
  export type user_training_assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_training_assignments.
     */
    data: XOR<user_training_assignmentsUpdateManyMutationInput, user_training_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which user_training_assignments to update
     */
    where?: user_training_assignmentsWhereInput
    /**
     * Limit how many user_training_assignments to update.
     */
    limit?: number
  }

  /**
   * user_training_assignments updateManyAndReturn
   */
  export type user_training_assignmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * The data used to update user_training_assignments.
     */
    data: XOR<user_training_assignmentsUpdateManyMutationInput, user_training_assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which user_training_assignments to update
     */
    where?: user_training_assignmentsWhereInput
    /**
     * Limit how many user_training_assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_training_assignments upsert
   */
  export type user_training_assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the user_training_assignments to update in case it exists.
     */
    where: user_training_assignmentsWhereUniqueInput
    /**
     * In case the user_training_assignments found by the `where` argument doesn't exist, create a new user_training_assignments with this data.
     */
    create: XOR<user_training_assignmentsCreateInput, user_training_assignmentsUncheckedCreateInput>
    /**
     * In case the user_training_assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_training_assignmentsUpdateInput, user_training_assignmentsUncheckedUpdateInput>
  }

  /**
   * user_training_assignments delete
   */
  export type user_training_assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
    /**
     * Filter which user_training_assignments to delete.
     */
    where: user_training_assignmentsWhereUniqueInput
  }

  /**
   * user_training_assignments deleteMany
   */
  export type user_training_assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_training_assignments to delete
     */
    where?: user_training_assignmentsWhereInput
    /**
     * Limit how many user_training_assignments to delete.
     */
    limit?: number
  }

  /**
   * user_training_assignments without action
   */
  export type user_training_assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_assignments
     */
    select?: user_training_assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_assignments
     */
    omit?: user_training_assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_assignmentsInclude<ExtArgs> | null
  }


  /**
   * Model user_training_progress
   */

  export type AggregateUser_training_progress = {
    _count: User_training_progressCountAggregateOutputType | null
    _avg: User_training_progressAvgAggregateOutputType | null
    _sum: User_training_progressSumAggregateOutputType | null
    _min: User_training_progressMinAggregateOutputType | null
    _max: User_training_progressMaxAggregateOutputType | null
  }

  export type User_training_progressAvgAggregateOutputType = {
    user_id: number | null
    progress_percentage: Decimal | null
    completion_duration_seconds: number | null
  }

  export type User_training_progressSumAggregateOutputType = {
    user_id: number | null
    progress_percentage: Decimal | null
    completion_duration_seconds: number | null
  }

  export type User_training_progressMinAggregateOutputType = {
    user_id: number | null
    bootcamp_id: string | null
    training_id: string | null
    status: string | null
    started_at: Date | null
    completed_at: Date | null
    progress_percentage: Decimal | null
    completion_duration_seconds: number | null
    updatedAt: Date | null
  }

  export type User_training_progressMaxAggregateOutputType = {
    user_id: number | null
    bootcamp_id: string | null
    training_id: string | null
    status: string | null
    started_at: Date | null
    completed_at: Date | null
    progress_percentage: Decimal | null
    completion_duration_seconds: number | null
    updatedAt: Date | null
  }

  export type User_training_progressCountAggregateOutputType = {
    user_id: number
    bootcamp_id: number
    training_id: number
    status: number
    started_at: number
    completed_at: number
    progress_percentage: number
    completed_content_items: number
    completion_duration_seconds: number
    updatedAt: number
    _all: number
  }


  export type User_training_progressAvgAggregateInputType = {
    user_id?: true
    progress_percentage?: true
    completion_duration_seconds?: true
  }

  export type User_training_progressSumAggregateInputType = {
    user_id?: true
    progress_percentage?: true
    completion_duration_seconds?: true
  }

  export type User_training_progressMinAggregateInputType = {
    user_id?: true
    bootcamp_id?: true
    training_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    progress_percentage?: true
    completion_duration_seconds?: true
    updatedAt?: true
  }

  export type User_training_progressMaxAggregateInputType = {
    user_id?: true
    bootcamp_id?: true
    training_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    progress_percentage?: true
    completion_duration_seconds?: true
    updatedAt?: true
  }

  export type User_training_progressCountAggregateInputType = {
    user_id?: true
    bootcamp_id?: true
    training_id?: true
    status?: true
    started_at?: true
    completed_at?: true
    progress_percentage?: true
    completed_content_items?: true
    completion_duration_seconds?: true
    updatedAt?: true
    _all?: true
  }

  export type User_training_progressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_training_progress to aggregate.
     */
    where?: user_training_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_training_progresses to fetch.
     */
    orderBy?: user_training_progressOrderByWithRelationInput | user_training_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_training_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_training_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_training_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_training_progresses
    **/
    _count?: true | User_training_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_training_progressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_training_progressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_training_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_training_progressMaxAggregateInputType
  }

  export type GetUser_training_progressAggregateType<T extends User_training_progressAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_training_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_training_progress[P]>
      : GetScalarType<T[P], AggregateUser_training_progress[P]>
  }




  export type user_training_progressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_training_progressWhereInput
    orderBy?: user_training_progressOrderByWithAggregationInput | user_training_progressOrderByWithAggregationInput[]
    by: User_training_progressScalarFieldEnum[] | User_training_progressScalarFieldEnum
    having?: user_training_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_training_progressCountAggregateInputType | true
    _avg?: User_training_progressAvgAggregateInputType
    _sum?: User_training_progressSumAggregateInputType
    _min?: User_training_progressMinAggregateInputType
    _max?: User_training_progressMaxAggregateInputType
  }

  export type User_training_progressGroupByOutputType = {
    user_id: number
    bootcamp_id: string | null
    training_id: string
    status: string
    started_at: Date | null
    completed_at: Date | null
    progress_percentage: Decimal
    completed_content_items: JsonValue
    completion_duration_seconds: number | null
    updatedAt: Date | null
    _count: User_training_progressCountAggregateOutputType | null
    _avg: User_training_progressAvgAggregateOutputType | null
    _sum: User_training_progressSumAggregateOutputType | null
    _min: User_training_progressMinAggregateOutputType | null
    _max: User_training_progressMaxAggregateOutputType | null
  }

  type GetUser_training_progressGroupByPayload<T extends user_training_progressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_training_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_training_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_training_progressGroupByOutputType[P]>
            : GetScalarType<T[P], User_training_progressGroupByOutputType[P]>
        }
      >
    >


  export type user_training_progressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    bootcamp_id?: boolean
    training_id?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    progress_percentage?: boolean
    completed_content_items?: boolean
    completion_duration_seconds?: boolean
    updatedAt?: boolean
    bootcamps?: boolean | user_training_progress$bootcampsArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_training_progress"]>

  export type user_training_progressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    bootcamp_id?: boolean
    training_id?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    progress_percentage?: boolean
    completed_content_items?: boolean
    completion_duration_seconds?: boolean
    updatedAt?: boolean
    bootcamps?: boolean | user_training_progress$bootcampsArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_training_progress"]>

  export type user_training_progressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    bootcamp_id?: boolean
    training_id?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    progress_percentage?: boolean
    completed_content_items?: boolean
    completion_duration_seconds?: boolean
    updatedAt?: boolean
    bootcamps?: boolean | user_training_progress$bootcampsArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_training_progress"]>

  export type user_training_progressSelectScalar = {
    user_id?: boolean
    bootcamp_id?: boolean
    training_id?: boolean
    status?: boolean
    started_at?: boolean
    completed_at?: boolean
    progress_percentage?: boolean
    completed_content_items?: boolean
    completion_duration_seconds?: boolean
    updatedAt?: boolean
  }

  export type user_training_progressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "bootcamp_id" | "training_id" | "status" | "started_at" | "completed_at" | "progress_percentage" | "completed_content_items" | "completion_duration_seconds" | "updatedAt", ExtArgs["result"]["user_training_progress"]>
  export type user_training_progressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | user_training_progress$bootcampsArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type user_training_progressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | user_training_progress$bootcampsArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type user_training_progressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bootcamps?: boolean | user_training_progress$bootcampsArgs<ExtArgs>
    trainings?: boolean | trainingsDefaultArgs<ExtArgs>
    users?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $user_training_progressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_training_progress"
    objects: {
      bootcamps: Prisma.$bootcampsPayload<ExtArgs> | null
      trainings: Prisma.$trainingsPayload<ExtArgs>
      users: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: number
      bootcamp_id: string | null
      training_id: string
      status: string
      started_at: Date | null
      completed_at: Date | null
      progress_percentage: Prisma.Decimal
      completed_content_items: Prisma.JsonValue
      completion_duration_seconds: number | null
      updatedAt: Date | null
    }, ExtArgs["result"]["user_training_progress"]>
    composites: {}
  }

  type user_training_progressGetPayload<S extends boolean | null | undefined | user_training_progressDefaultArgs> = $Result.GetResult<Prisma.$user_training_progressPayload, S>

  type user_training_progressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_training_progressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_training_progressCountAggregateInputType | true
    }

  export interface user_training_progressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_training_progress'], meta: { name: 'user_training_progress' } }
    /**
     * Find zero or one User_training_progress that matches the filter.
     * @param {user_training_progressFindUniqueArgs} args - Arguments to find a User_training_progress
     * @example
     * // Get one User_training_progress
     * const user_training_progress = await prisma.user_training_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_training_progressFindUniqueArgs>(args: SelectSubset<T, user_training_progressFindUniqueArgs<ExtArgs>>): Prisma__user_training_progressClient<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_training_progress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_training_progressFindUniqueOrThrowArgs} args - Arguments to find a User_training_progress
     * @example
     * // Get one User_training_progress
     * const user_training_progress = await prisma.user_training_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_training_progressFindUniqueOrThrowArgs>(args: SelectSubset<T, user_training_progressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_training_progressClient<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_training_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_progressFindFirstArgs} args - Arguments to find a User_training_progress
     * @example
     * // Get one User_training_progress
     * const user_training_progress = await prisma.user_training_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_training_progressFindFirstArgs>(args?: SelectSubset<T, user_training_progressFindFirstArgs<ExtArgs>>): Prisma__user_training_progressClient<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_training_progress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_progressFindFirstOrThrowArgs} args - Arguments to find a User_training_progress
     * @example
     * // Get one User_training_progress
     * const user_training_progress = await prisma.user_training_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_training_progressFindFirstOrThrowArgs>(args?: SelectSubset<T, user_training_progressFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_training_progressClient<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_training_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_progressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_training_progresses
     * const user_training_progresses = await prisma.user_training_progress.findMany()
     * 
     * // Get first 10 User_training_progresses
     * const user_training_progresses = await prisma.user_training_progress.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const user_training_progressWithUser_idOnly = await prisma.user_training_progress.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends user_training_progressFindManyArgs>(args?: SelectSubset<T, user_training_progressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_training_progress.
     * @param {user_training_progressCreateArgs} args - Arguments to create a User_training_progress.
     * @example
     * // Create one User_training_progress
     * const User_training_progress = await prisma.user_training_progress.create({
     *   data: {
     *     // ... data to create a User_training_progress
     *   }
     * })
     * 
     */
    create<T extends user_training_progressCreateArgs>(args: SelectSubset<T, user_training_progressCreateArgs<ExtArgs>>): Prisma__user_training_progressClient<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_training_progresses.
     * @param {user_training_progressCreateManyArgs} args - Arguments to create many User_training_progresses.
     * @example
     * // Create many User_training_progresses
     * const user_training_progress = await prisma.user_training_progress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_training_progressCreateManyArgs>(args?: SelectSubset<T, user_training_progressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_training_progresses and returns the data saved in the database.
     * @param {user_training_progressCreateManyAndReturnArgs} args - Arguments to create many User_training_progresses.
     * @example
     * // Create many User_training_progresses
     * const user_training_progress = await prisma.user_training_progress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_training_progresses and only return the `user_id`
     * const user_training_progressWithUser_idOnly = await prisma.user_training_progress.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_training_progressCreateManyAndReturnArgs>(args?: SelectSubset<T, user_training_progressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_training_progress.
     * @param {user_training_progressDeleteArgs} args - Arguments to delete one User_training_progress.
     * @example
     * // Delete one User_training_progress
     * const User_training_progress = await prisma.user_training_progress.delete({
     *   where: {
     *     // ... filter to delete one User_training_progress
     *   }
     * })
     * 
     */
    delete<T extends user_training_progressDeleteArgs>(args: SelectSubset<T, user_training_progressDeleteArgs<ExtArgs>>): Prisma__user_training_progressClient<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_training_progress.
     * @param {user_training_progressUpdateArgs} args - Arguments to update one User_training_progress.
     * @example
     * // Update one User_training_progress
     * const user_training_progress = await prisma.user_training_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_training_progressUpdateArgs>(args: SelectSubset<T, user_training_progressUpdateArgs<ExtArgs>>): Prisma__user_training_progressClient<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_training_progresses.
     * @param {user_training_progressDeleteManyArgs} args - Arguments to filter User_training_progresses to delete.
     * @example
     * // Delete a few User_training_progresses
     * const { count } = await prisma.user_training_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_training_progressDeleteManyArgs>(args?: SelectSubset<T, user_training_progressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_training_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_training_progresses
     * const user_training_progress = await prisma.user_training_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_training_progressUpdateManyArgs>(args: SelectSubset<T, user_training_progressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_training_progresses and returns the data updated in the database.
     * @param {user_training_progressUpdateManyAndReturnArgs} args - Arguments to update many User_training_progresses.
     * @example
     * // Update many User_training_progresses
     * const user_training_progress = await prisma.user_training_progress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_training_progresses and only return the `user_id`
     * const user_training_progressWithUser_idOnly = await prisma.user_training_progress.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_training_progressUpdateManyAndReturnArgs>(args: SelectSubset<T, user_training_progressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_training_progress.
     * @param {user_training_progressUpsertArgs} args - Arguments to update or create a User_training_progress.
     * @example
     * // Update or create a User_training_progress
     * const user_training_progress = await prisma.user_training_progress.upsert({
     *   create: {
     *     // ... data to create a User_training_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_training_progress we want to update
     *   }
     * })
     */
    upsert<T extends user_training_progressUpsertArgs>(args: SelectSubset<T, user_training_progressUpsertArgs<ExtArgs>>): Prisma__user_training_progressClient<$Result.GetResult<Prisma.$user_training_progressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_training_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_progressCountArgs} args - Arguments to filter User_training_progresses to count.
     * @example
     * // Count the number of User_training_progresses
     * const count = await prisma.user_training_progress.count({
     *   where: {
     *     // ... the filter for the User_training_progresses we want to count
     *   }
     * })
    **/
    count<T extends user_training_progressCountArgs>(
      args?: Subset<T, user_training_progressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_training_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_training_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_training_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_training_progressAggregateArgs>(args: Subset<T, User_training_progressAggregateArgs>): Prisma.PrismaPromise<GetUser_training_progressAggregateType<T>>

    /**
     * Group by User_training_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_training_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_training_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_training_progressGroupByArgs['orderBy'] }
        : { orderBy?: user_training_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_training_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_training_progressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_training_progress model
   */
  readonly fields: user_training_progressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_training_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_training_progressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bootcamps<T extends user_training_progress$bootcampsArgs<ExtArgs> = {}>(args?: Subset<T, user_training_progress$bootcampsArgs<ExtArgs>>): Prisma__bootcampsClient<$Result.GetResult<Prisma.$bootcampsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    trainings<T extends trainingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, trainingsDefaultArgs<ExtArgs>>): Prisma__trainingsClient<$Result.GetResult<Prisma.$trainingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_training_progress model
   */
  interface user_training_progressFieldRefs {
    readonly user_id: FieldRef<"user_training_progress", 'Int'>
    readonly bootcamp_id: FieldRef<"user_training_progress", 'String'>
    readonly training_id: FieldRef<"user_training_progress", 'String'>
    readonly status: FieldRef<"user_training_progress", 'String'>
    readonly started_at: FieldRef<"user_training_progress", 'DateTime'>
    readonly completed_at: FieldRef<"user_training_progress", 'DateTime'>
    readonly progress_percentage: FieldRef<"user_training_progress", 'Decimal'>
    readonly completed_content_items: FieldRef<"user_training_progress", 'Json'>
    readonly completion_duration_seconds: FieldRef<"user_training_progress", 'Int'>
    readonly updatedAt: FieldRef<"user_training_progress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_training_progress findUnique
   */
  export type user_training_progressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * Filter, which user_training_progress to fetch.
     */
    where: user_training_progressWhereUniqueInput
  }

  /**
   * user_training_progress findUniqueOrThrow
   */
  export type user_training_progressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * Filter, which user_training_progress to fetch.
     */
    where: user_training_progressWhereUniqueInput
  }

  /**
   * user_training_progress findFirst
   */
  export type user_training_progressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * Filter, which user_training_progress to fetch.
     */
    where?: user_training_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_training_progresses to fetch.
     */
    orderBy?: user_training_progressOrderByWithRelationInput | user_training_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_training_progresses.
     */
    cursor?: user_training_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_training_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_training_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_training_progresses.
     */
    distinct?: User_training_progressScalarFieldEnum | User_training_progressScalarFieldEnum[]
  }

  /**
   * user_training_progress findFirstOrThrow
   */
  export type user_training_progressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * Filter, which user_training_progress to fetch.
     */
    where?: user_training_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_training_progresses to fetch.
     */
    orderBy?: user_training_progressOrderByWithRelationInput | user_training_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_training_progresses.
     */
    cursor?: user_training_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_training_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_training_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_training_progresses.
     */
    distinct?: User_training_progressScalarFieldEnum | User_training_progressScalarFieldEnum[]
  }

  /**
   * user_training_progress findMany
   */
  export type user_training_progressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * Filter, which user_training_progresses to fetch.
     */
    where?: user_training_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_training_progresses to fetch.
     */
    orderBy?: user_training_progressOrderByWithRelationInput | user_training_progressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_training_progresses.
     */
    cursor?: user_training_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_training_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_training_progresses.
     */
    skip?: number
    distinct?: User_training_progressScalarFieldEnum | User_training_progressScalarFieldEnum[]
  }

  /**
   * user_training_progress create
   */
  export type user_training_progressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * The data needed to create a user_training_progress.
     */
    data: XOR<user_training_progressCreateInput, user_training_progressUncheckedCreateInput>
  }

  /**
   * user_training_progress createMany
   */
  export type user_training_progressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_training_progresses.
     */
    data: user_training_progressCreateManyInput | user_training_progressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_training_progress createManyAndReturn
   */
  export type user_training_progressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * The data used to create many user_training_progresses.
     */
    data: user_training_progressCreateManyInput | user_training_progressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_training_progress update
   */
  export type user_training_progressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * The data needed to update a user_training_progress.
     */
    data: XOR<user_training_progressUpdateInput, user_training_progressUncheckedUpdateInput>
    /**
     * Choose, which user_training_progress to update.
     */
    where: user_training_progressWhereUniqueInput
  }

  /**
   * user_training_progress updateMany
   */
  export type user_training_progressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_training_progresses.
     */
    data: XOR<user_training_progressUpdateManyMutationInput, user_training_progressUncheckedUpdateManyInput>
    /**
     * Filter which user_training_progresses to update
     */
    where?: user_training_progressWhereInput
    /**
     * Limit how many user_training_progresses to update.
     */
    limit?: number
  }

  /**
   * user_training_progress updateManyAndReturn
   */
  export type user_training_progressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * The data used to update user_training_progresses.
     */
    data: XOR<user_training_progressUpdateManyMutationInput, user_training_progressUncheckedUpdateManyInput>
    /**
     * Filter which user_training_progresses to update
     */
    where?: user_training_progressWhereInput
    /**
     * Limit how many user_training_progresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_training_progress upsert
   */
  export type user_training_progressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * The filter to search for the user_training_progress to update in case it exists.
     */
    where: user_training_progressWhereUniqueInput
    /**
     * In case the user_training_progress found by the `where` argument doesn't exist, create a new user_training_progress with this data.
     */
    create: XOR<user_training_progressCreateInput, user_training_progressUncheckedCreateInput>
    /**
     * In case the user_training_progress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_training_progressUpdateInput, user_training_progressUncheckedUpdateInput>
  }

  /**
   * user_training_progress delete
   */
  export type user_training_progressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
    /**
     * Filter which user_training_progress to delete.
     */
    where: user_training_progressWhereUniqueInput
  }

  /**
   * user_training_progress deleteMany
   */
  export type user_training_progressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_training_progresses to delete
     */
    where?: user_training_progressWhereInput
    /**
     * Limit how many user_training_progresses to delete.
     */
    limit?: number
  }

  /**
   * user_training_progress.bootcamps
   */
  export type user_training_progress$bootcampsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bootcamps
     */
    select?: bootcampsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bootcamps
     */
    omit?: bootcampsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bootcampsInclude<ExtArgs> | null
    where?: bootcampsWhereInput
  }

  /**
   * user_training_progress without action
   */
  export type user_training_progressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_training_progress
     */
    select?: user_training_progressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_training_progress
     */
    omit?: user_training_progressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_training_progressInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    loginType: 'loginType',
    microsoftId: 'microsoftId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    telesetCardNo: 'telesetCardNo',
    userId: 'userId',
    departmentId: 'departmentId',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    adminLevel: 'adminLevel',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    action_type: 'action_type',
    user_id: 'user_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    created_at: 'created_at',
    details: 'details',
    is_suspicious: 'is_suspicious'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const Admin_permission_logsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    modified_by: 'modified_by',
    action: 'action',
    previous_role: 'previous_role',
    new_role: 'new_role',
    action_date: 'action_date',
    notes: 'notes'
  };

  export type Admin_permission_logsScalarFieldEnum = (typeof Admin_permission_logsScalarFieldEnum)[keyof typeof Admin_permission_logsScalarFieldEnum]


  export const Admin_permissionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    granted_by: 'granted_by',
    permission_level: 'permission_level',
    granted_at: 'granted_at',
    revoked_at: 'revoked_at',
    is_active: 'is_active'
  };

  export type Admin_permissionsScalarFieldEnum = (typeof Admin_permissionsScalarFieldEnum)[keyof typeof Admin_permissionsScalarFieldEnum]


  export const Bootcamp_progressScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    bootcamp_id: 'bootcamp_id',
    current_training_index: 'current_training_index',
    progress_percentage: 'progress_percentage',
    last_activity: 'last_activity'
  };

  export type Bootcamp_progressScalarFieldEnum = (typeof Bootcamp_progressScalarFieldEnum)[keyof typeof Bootcamp_progressScalarFieldEnum]


  export const Bootcamp_trainingsScalarFieldEnum: {
    id: 'id',
    bootcamp_id: 'bootcamp_id',
    training_id: 'training_id',
    order_index: 'order_index',
    required: 'required',
    created_at: 'created_at'
  };

  export type Bootcamp_trainingsScalarFieldEnum = (typeof Bootcamp_trainingsScalarFieldEnum)[keyof typeof Bootcamp_trainingsScalarFieldEnum]


  export const BootcampsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    author: 'author',
    published: 'published',
    duration: 'duration',
    deadline: 'deadline',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BootcampsScalarFieldEnum = (typeof BootcampsScalarFieldEnum)[keyof typeof BootcampsScalarFieldEnum]


  export const Conference_attendeesScalarFieldEnum: {
    id: 'id',
    conference_id: 'conference_id',
    user_id: 'user_id',
    registered_at: 'registered_at',
    attended: 'attended',
    attendance_time: 'attendance_time',
    notes: 'notes'
  };

  export type Conference_attendeesScalarFieldEnum = (typeof Conference_attendeesScalarFieldEnum)[keyof typeof Conference_attendeesScalarFieldEnum]


  export const Conference_materialsScalarFieldEnum: {
    id: 'id',
    conference_id: 'conference_id',
    title: 'title',
    description: 'description',
    file_path: 'file_path',
    link: 'link',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Conference_materialsScalarFieldEnum = (typeof Conference_materialsScalarFieldEnum)[keyof typeof Conference_materialsScalarFieldEnum]


  export const Conference_trainingsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    location: 'location',
    start_date: 'start_date',
    end_date: 'end_date',
    capacity: 'capacity',
    author: 'author',
    published: 'published',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Conference_trainingsScalarFieldEnum = (typeof Conference_trainingsScalarFieldEnum)[keyof typeof Conference_trainingsScalarFieldEnum]


  export const EnrollmentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    training_id: 'training_id',
    status: 'status',
    progress: 'progress',
    completed_items: 'completed_items',
    score: 'score',
    start_date: 'start_date',
    completed_at: 'completed_at',
    last_accessed_at: 'last_accessed_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EnrollmentsScalarFieldEnum = (typeof EnrollmentsScalarFieldEnum)[keyof typeof EnrollmentsScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    quiz_id: 'quiz_id',
    question_text: 'question_text',
    question_type: 'question_type',
    options: 'options',
    correct_answer: 'correct_answer',
    points: 'points',
    order_index: 'order_index',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const QuizzesScalarFieldEnum: {
    id: 'id',
    training_id: 'training_id',
    title: 'title',
    description: 'description',
    pass_threshold: 'pass_threshold',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizzesScalarFieldEnum = (typeof QuizzesScalarFieldEnum)[keyof typeof QuizzesScalarFieldEnum]


  export const Training_contentScalarFieldEnum: {
    id: 'id',
    training_id: 'training_id',
    title: 'title',
    content_type: 'content_type',
    content_value: 'content_value',
    order_index: 'order_index',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Training_contentScalarFieldEnum = (typeof Training_contentScalarFieldEnum)[keyof typeof Training_contentScalarFieldEnum]


  export const TrainingsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    duration: 'duration',
    author: 'author',
    published: 'published',
    tags: 'tags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    certificateTemplate: 'certificateTemplate',
    learning_outcomes: 'learning_outcomes',
    deadline: 'deadline',
    is_mandatory: 'is_mandatory'
  };

  export type TrainingsScalarFieldEnum = (typeof TrainingsScalarFieldEnum)[keyof typeof TrainingsScalarFieldEnum]


  export const User_bootcamp_assignmentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    bootcamp_id: 'bootcamp_id',
    assigned_at: 'assigned_at',
    completed: 'completed',
    completion_date: 'completion_date'
  };

  export type User_bootcamp_assignmentsScalarFieldEnum = (typeof User_bootcamp_assignmentsScalarFieldEnum)[keyof typeof User_bootcamp_assignmentsScalarFieldEnum]


  export const User_quiz_attemptsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    quiz_id: 'quiz_id',
    training_id: 'training_id',
    attempt_number: 'attempt_number',
    score: 'score',
    passed: 'passed',
    submitted_at: 'submitted_at',
    answers: 'answers'
  };

  export type User_quiz_attemptsScalarFieldEnum = (typeof User_quiz_attemptsScalarFieldEnum)[keyof typeof User_quiz_attemptsScalarFieldEnum]


  export const User_training_assignmentsScalarFieldEnum: {
    assignment_id: 'assignment_id',
    user_id: 'user_id',
    training_id: 'training_id',
    assigned_at: 'assigned_at'
  };

  export type User_training_assignmentsScalarFieldEnum = (typeof User_training_assignmentsScalarFieldEnum)[keyof typeof User_training_assignmentsScalarFieldEnum]


  export const User_training_progressScalarFieldEnum: {
    user_id: 'user_id',
    bootcamp_id: 'bootcamp_id',
    training_id: 'training_id',
    status: 'status',
    started_at: 'started_at',
    completed_at: 'completed_at',
    progress_percentage: 'progress_percentage',
    completed_content_items: 'completed_content_items',
    completion_duration_seconds: 'completion_duration_seconds',
    updatedAt: 'updatedAt'
  };

  export type User_training_progressScalarFieldEnum = (typeof User_training_progressScalarFieldEnum)[keyof typeof User_training_progressScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'user_role'
   */
  export type Enumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role'>
    


  /**
   * Reference to a field of type 'user_role[]'
   */
  export type ListEnumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role[]'>
    


  /**
   * Reference to a field of type 'login_type'
   */
  export type Enumlogin_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'login_type'>
    


  /**
   * Reference to a field of type 'login_type[]'
   */
  export type ListEnumlogin_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'login_type[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: Enumuser_roleFilter<"User"> | $Enums.user_role
    loginType?: Enumlogin_typeFilter<"User"> | $Enums.login_type
    microsoftId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: Admin_permission_logsListRelationFilter
    admin_permission_logs_admin_permission_logs_user_idTousers?: Admin_permission_logsListRelationFilter
    admin_permissions_admin_permissions_granted_byTousers?: Admin_permissionsListRelationFilter
    admin_permissions_admin_permissions_user_idTousers?: Admin_permissionsListRelationFilter
    admin?: AdminListRelationFilter
    bootcamp_progress?: Bootcamp_progressListRelationFilter
    conference_attendees?: Conference_attendeesListRelationFilter
    employee?: EmployeeListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    logs?: LogListRelationFilter
    user_bootcamp_assignments?: User_bootcamp_assignmentsListRelationFilter
    user_training_assignments?: User_training_assignmentsListRelationFilter
    user_training_progress?: User_training_progressListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    microsoftId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsOrderByRelationAggregateInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsOrderByRelationAggregateInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsOrderByRelationAggregateInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsOrderByRelationAggregateInput
    admin?: AdminOrderByRelationAggregateInput
    bootcamp_progress?: bootcamp_progressOrderByRelationAggregateInput
    conference_attendees?: conference_attendeesOrderByRelationAggregateInput
    employee?: EmployeeOrderByRelationAggregateInput
    enrollments?: enrollmentsOrderByRelationAggregateInput
    logs?: LogOrderByRelationAggregateInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsOrderByRelationAggregateInput
    user_training_assignments?: user_training_assignmentsOrderByRelationAggregateInput
    user_training_progress?: user_training_progressOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: Enumuser_roleFilter<"User"> | $Enums.user_role
    loginType?: Enumlogin_typeFilter<"User"> | $Enums.login_type
    microsoftId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: Admin_permission_logsListRelationFilter
    admin_permission_logs_admin_permission_logs_user_idTousers?: Admin_permission_logsListRelationFilter
    admin_permissions_admin_permissions_granted_byTousers?: Admin_permissionsListRelationFilter
    admin_permissions_admin_permissions_user_idTousers?: Admin_permissionsListRelationFilter
    admin?: AdminListRelationFilter
    bootcamp_progress?: Bootcamp_progressListRelationFilter
    conference_attendees?: Conference_attendeesListRelationFilter
    employee?: EmployeeListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    logs?: LogListRelationFilter
    user_bootcamp_assignments?: User_bootcamp_assignmentsListRelationFilter
    user_training_assignments?: User_training_assignmentsListRelationFilter
    user_training_progress?: User_training_progressListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    microsoftId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: Enumuser_roleWithAggregatesFilter<"User"> | $Enums.user_role
    loginType?: Enumlogin_typeWithAggregatesFilter<"User"> | $Enums.login_type
    microsoftId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    telesetCardNo?: StringNullableFilter<"Employee"> | string | null
    userId?: IntFilter<"Employee"> | number
    departmentId?: IntNullableFilter<"Employee"> | number | null
    position?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    telesetCardNo?: SortOrderInput | SortOrder
    userId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    telesetCardNo?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    userId?: IntFilter<"Employee"> | number
    departmentId?: IntNullableFilter<"Employee"> | number | null
    position?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "telesetCardNo">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    telesetCardNo?: SortOrderInput | SortOrder
    userId?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    telesetCardNo?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    userId?: IntWithAggregatesFilter<"Employee"> | number
    departmentId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    position?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    adminLevel?: StringFilter<"Admin"> | string
    userId?: IntFilter<"Admin"> | number
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    adminLevel?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    adminLevel?: StringFilter<"Admin"> | string
    userId?: IntFilter<"Admin"> | number
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    adminLevel?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    adminLevel?: StringWithAggregatesFilter<"Admin"> | string
    userId?: IntWithAggregatesFilter<"Admin"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    employees?: EmployeeListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    employees?: EmployeeListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    id?: IntFilter<"Log"> | number
    action_type?: StringFilter<"Log"> | string
    user_id?: IntNullableFilter<"Log"> | number | null
    ip_address?: StringNullableFilter<"Log"> | string | null
    user_agent?: StringNullableFilter<"Log"> | string | null
    created_at?: DateTimeFilter<"Log"> | Date | string
    details?: JsonNullableFilter<"Log">
    is_suspicious?: BoolNullableFilter<"Log"> | boolean | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LogOrderByWithRelationInput = {
    id?: SortOrder
    action_type?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    details?: SortOrderInput | SortOrder
    is_suspicious?: SortOrderInput | SortOrder
    users?: UserOrderByWithRelationInput
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    action_type?: StringFilter<"Log"> | string
    user_id?: IntNullableFilter<"Log"> | number | null
    ip_address?: StringNullableFilter<"Log"> | string | null
    user_agent?: StringNullableFilter<"Log"> | string | null
    created_at?: DateTimeFilter<"Log"> | Date | string
    details?: JsonNullableFilter<"Log">
    is_suspicious?: BoolNullableFilter<"Log"> | boolean | null
    users?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LogOrderByWithAggregationInput = {
    id?: SortOrder
    action_type?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    created_at?: SortOrder
    details?: SortOrderInput | SortOrder
    is_suspicious?: SortOrderInput | SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Log"> | number
    action_type?: StringWithAggregatesFilter<"Log"> | string
    user_id?: IntNullableWithAggregatesFilter<"Log"> | number | null
    ip_address?: StringNullableWithAggregatesFilter<"Log"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"Log"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    details?: JsonNullableWithAggregatesFilter<"Log">
    is_suspicious?: BoolNullableWithAggregatesFilter<"Log"> | boolean | null
  }

  export type admin_permission_logsWhereInput = {
    AND?: admin_permission_logsWhereInput | admin_permission_logsWhereInput[]
    OR?: admin_permission_logsWhereInput[]
    NOT?: admin_permission_logsWhereInput | admin_permission_logsWhereInput[]
    id?: IntFilter<"admin_permission_logs"> | number
    user_id?: IntFilter<"admin_permission_logs"> | number
    modified_by?: IntFilter<"admin_permission_logs"> | number
    action?: StringFilter<"admin_permission_logs"> | string
    previous_role?: StringNullableFilter<"admin_permission_logs"> | string | null
    new_role?: StringNullableFilter<"admin_permission_logs"> | string | null
    action_date?: DateTimeFilter<"admin_permission_logs"> | Date | string
    notes?: StringNullableFilter<"admin_permission_logs"> | string | null
    users_admin_permission_logs_modified_byTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
    users_admin_permission_logs_user_idTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type admin_permission_logsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    modified_by?: SortOrder
    action?: SortOrder
    previous_role?: SortOrderInput | SortOrder
    new_role?: SortOrderInput | SortOrder
    action_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    users_admin_permission_logs_modified_byTousers?: UserOrderByWithRelationInput
    users_admin_permission_logs_user_idTousers?: UserOrderByWithRelationInput
  }

  export type admin_permission_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: admin_permission_logsWhereInput | admin_permission_logsWhereInput[]
    OR?: admin_permission_logsWhereInput[]
    NOT?: admin_permission_logsWhereInput | admin_permission_logsWhereInput[]
    user_id?: IntFilter<"admin_permission_logs"> | number
    modified_by?: IntFilter<"admin_permission_logs"> | number
    action?: StringFilter<"admin_permission_logs"> | string
    previous_role?: StringNullableFilter<"admin_permission_logs"> | string | null
    new_role?: StringNullableFilter<"admin_permission_logs"> | string | null
    action_date?: DateTimeFilter<"admin_permission_logs"> | Date | string
    notes?: StringNullableFilter<"admin_permission_logs"> | string | null
    users_admin_permission_logs_modified_byTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
    users_admin_permission_logs_user_idTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type admin_permission_logsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    modified_by?: SortOrder
    action?: SortOrder
    previous_role?: SortOrderInput | SortOrder
    new_role?: SortOrderInput | SortOrder
    action_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: admin_permission_logsCountOrderByAggregateInput
    _avg?: admin_permission_logsAvgOrderByAggregateInput
    _max?: admin_permission_logsMaxOrderByAggregateInput
    _min?: admin_permission_logsMinOrderByAggregateInput
    _sum?: admin_permission_logsSumOrderByAggregateInput
  }

  export type admin_permission_logsScalarWhereWithAggregatesInput = {
    AND?: admin_permission_logsScalarWhereWithAggregatesInput | admin_permission_logsScalarWhereWithAggregatesInput[]
    OR?: admin_permission_logsScalarWhereWithAggregatesInput[]
    NOT?: admin_permission_logsScalarWhereWithAggregatesInput | admin_permission_logsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin_permission_logs"> | number
    user_id?: IntWithAggregatesFilter<"admin_permission_logs"> | number
    modified_by?: IntWithAggregatesFilter<"admin_permission_logs"> | number
    action?: StringWithAggregatesFilter<"admin_permission_logs"> | string
    previous_role?: StringNullableWithAggregatesFilter<"admin_permission_logs"> | string | null
    new_role?: StringNullableWithAggregatesFilter<"admin_permission_logs"> | string | null
    action_date?: DateTimeWithAggregatesFilter<"admin_permission_logs"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"admin_permission_logs"> | string | null
  }

  export type admin_permissionsWhereInput = {
    AND?: admin_permissionsWhereInput | admin_permissionsWhereInput[]
    OR?: admin_permissionsWhereInput[]
    NOT?: admin_permissionsWhereInput | admin_permissionsWhereInput[]
    id?: IntFilter<"admin_permissions"> | number
    user_id?: IntFilter<"admin_permissions"> | number
    granted_by?: IntFilter<"admin_permissions"> | number
    permission_level?: StringFilter<"admin_permissions"> | string
    granted_at?: DateTimeFilter<"admin_permissions"> | Date | string
    revoked_at?: DateTimeNullableFilter<"admin_permissions"> | Date | string | null
    is_active?: BoolFilter<"admin_permissions"> | boolean
    users_admin_permissions_granted_byTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
    users_admin_permissions_user_idTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type admin_permissionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    granted_by?: SortOrder
    permission_level?: SortOrder
    granted_at?: SortOrder
    revoked_at?: SortOrderInput | SortOrder
    is_active?: SortOrder
    users_admin_permissions_granted_byTousers?: UserOrderByWithRelationInput
    users_admin_permissions_user_idTousers?: UserOrderByWithRelationInput
  }

  export type admin_permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_is_active?: admin_permissionsUser_idIs_activeCompoundUniqueInput
    AND?: admin_permissionsWhereInput | admin_permissionsWhereInput[]
    OR?: admin_permissionsWhereInput[]
    NOT?: admin_permissionsWhereInput | admin_permissionsWhereInput[]
    user_id?: IntFilter<"admin_permissions"> | number
    granted_by?: IntFilter<"admin_permissions"> | number
    permission_level?: StringFilter<"admin_permissions"> | string
    granted_at?: DateTimeFilter<"admin_permissions"> | Date | string
    revoked_at?: DateTimeNullableFilter<"admin_permissions"> | Date | string | null
    is_active?: BoolFilter<"admin_permissions"> | boolean
    users_admin_permissions_granted_byTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
    users_admin_permissions_user_idTousers?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id_is_active">

  export type admin_permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    granted_by?: SortOrder
    permission_level?: SortOrder
    granted_at?: SortOrder
    revoked_at?: SortOrderInput | SortOrder
    is_active?: SortOrder
    _count?: admin_permissionsCountOrderByAggregateInput
    _avg?: admin_permissionsAvgOrderByAggregateInput
    _max?: admin_permissionsMaxOrderByAggregateInput
    _min?: admin_permissionsMinOrderByAggregateInput
    _sum?: admin_permissionsSumOrderByAggregateInput
  }

  export type admin_permissionsScalarWhereWithAggregatesInput = {
    AND?: admin_permissionsScalarWhereWithAggregatesInput | admin_permissionsScalarWhereWithAggregatesInput[]
    OR?: admin_permissionsScalarWhereWithAggregatesInput[]
    NOT?: admin_permissionsScalarWhereWithAggregatesInput | admin_permissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"admin_permissions"> | number
    user_id?: IntWithAggregatesFilter<"admin_permissions"> | number
    granted_by?: IntWithAggregatesFilter<"admin_permissions"> | number
    permission_level?: StringWithAggregatesFilter<"admin_permissions"> | string
    granted_at?: DateTimeWithAggregatesFilter<"admin_permissions"> | Date | string
    revoked_at?: DateTimeNullableWithAggregatesFilter<"admin_permissions"> | Date | string | null
    is_active?: BoolWithAggregatesFilter<"admin_permissions"> | boolean
  }

  export type bootcamp_progressWhereInput = {
    AND?: bootcamp_progressWhereInput | bootcamp_progressWhereInput[]
    OR?: bootcamp_progressWhereInput[]
    NOT?: bootcamp_progressWhereInput | bootcamp_progressWhereInput[]
    id?: UuidFilter<"bootcamp_progress"> | string
    user_id?: IntFilter<"bootcamp_progress"> | number
    bootcamp_id?: UuidFilter<"bootcamp_progress"> | string
    current_training_index?: IntNullableFilter<"bootcamp_progress"> | number | null
    progress_percentage?: DecimalNullableFilter<"bootcamp_progress"> | Decimal | DecimalJsLike | number | string | null
    last_activity?: DateTimeNullableFilter<"bootcamp_progress"> | Date | string | null
    bootcamps?: XOR<BootcampsScalarRelationFilter, bootcampsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type bootcamp_progressOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    current_training_index?: SortOrderInput | SortOrder
    progress_percentage?: SortOrderInput | SortOrder
    last_activity?: SortOrderInput | SortOrder
    bootcamps?: bootcampsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type bootcamp_progressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_bootcamp_id?: bootcamp_progressUser_idBootcamp_idCompoundUniqueInput
    AND?: bootcamp_progressWhereInput | bootcamp_progressWhereInput[]
    OR?: bootcamp_progressWhereInput[]
    NOT?: bootcamp_progressWhereInput | bootcamp_progressWhereInput[]
    user_id?: IntFilter<"bootcamp_progress"> | number
    bootcamp_id?: UuidFilter<"bootcamp_progress"> | string
    current_training_index?: IntNullableFilter<"bootcamp_progress"> | number | null
    progress_percentage?: DecimalNullableFilter<"bootcamp_progress"> | Decimal | DecimalJsLike | number | string | null
    last_activity?: DateTimeNullableFilter<"bootcamp_progress"> | Date | string | null
    bootcamps?: XOR<BootcampsScalarRelationFilter, bootcampsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id_bootcamp_id">

  export type bootcamp_progressOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    current_training_index?: SortOrderInput | SortOrder
    progress_percentage?: SortOrderInput | SortOrder
    last_activity?: SortOrderInput | SortOrder
    _count?: bootcamp_progressCountOrderByAggregateInput
    _avg?: bootcamp_progressAvgOrderByAggregateInput
    _max?: bootcamp_progressMaxOrderByAggregateInput
    _min?: bootcamp_progressMinOrderByAggregateInput
    _sum?: bootcamp_progressSumOrderByAggregateInput
  }

  export type bootcamp_progressScalarWhereWithAggregatesInput = {
    AND?: bootcamp_progressScalarWhereWithAggregatesInput | bootcamp_progressScalarWhereWithAggregatesInput[]
    OR?: bootcamp_progressScalarWhereWithAggregatesInput[]
    NOT?: bootcamp_progressScalarWhereWithAggregatesInput | bootcamp_progressScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bootcamp_progress"> | string
    user_id?: IntWithAggregatesFilter<"bootcamp_progress"> | number
    bootcamp_id?: UuidWithAggregatesFilter<"bootcamp_progress"> | string
    current_training_index?: IntNullableWithAggregatesFilter<"bootcamp_progress"> | number | null
    progress_percentage?: DecimalNullableWithAggregatesFilter<"bootcamp_progress"> | Decimal | DecimalJsLike | number | string | null
    last_activity?: DateTimeNullableWithAggregatesFilter<"bootcamp_progress"> | Date | string | null
  }

  export type bootcamp_trainingsWhereInput = {
    AND?: bootcamp_trainingsWhereInput | bootcamp_trainingsWhereInput[]
    OR?: bootcamp_trainingsWhereInput[]
    NOT?: bootcamp_trainingsWhereInput | bootcamp_trainingsWhereInput[]
    id?: UuidFilter<"bootcamp_trainings"> | string
    bootcamp_id?: UuidFilter<"bootcamp_trainings"> | string
    training_id?: UuidFilter<"bootcamp_trainings"> | string
    order_index?: IntFilter<"bootcamp_trainings"> | number
    required?: BoolNullableFilter<"bootcamp_trainings"> | boolean | null
    created_at?: DateTimeNullableFilter<"bootcamp_trainings"> | Date | string | null
    bootcamps?: XOR<BootcampsScalarRelationFilter, bootcampsWhereInput>
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
  }

  export type bootcamp_trainingsOrderByWithRelationInput = {
    id?: SortOrder
    bootcamp_id?: SortOrder
    training_id?: SortOrder
    order_index?: SortOrder
    required?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    bootcamps?: bootcampsOrderByWithRelationInput
    trainings?: trainingsOrderByWithRelationInput
  }

  export type bootcamp_trainingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bootcamp_id_order_index?: bootcamp_trainingsBootcamp_idOrder_indexCompoundUniqueInput
    bootcamp_id_training_id?: bootcamp_trainingsBootcamp_idTraining_idCompoundUniqueInput
    AND?: bootcamp_trainingsWhereInput | bootcamp_trainingsWhereInput[]
    OR?: bootcamp_trainingsWhereInput[]
    NOT?: bootcamp_trainingsWhereInput | bootcamp_trainingsWhereInput[]
    bootcamp_id?: UuidFilter<"bootcamp_trainings"> | string
    training_id?: UuidFilter<"bootcamp_trainings"> | string
    order_index?: IntFilter<"bootcamp_trainings"> | number
    required?: BoolNullableFilter<"bootcamp_trainings"> | boolean | null
    created_at?: DateTimeNullableFilter<"bootcamp_trainings"> | Date | string | null
    bootcamps?: XOR<BootcampsScalarRelationFilter, bootcampsWhereInput>
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
  }, "id" | "bootcamp_id_order_index" | "bootcamp_id_training_id">

  export type bootcamp_trainingsOrderByWithAggregationInput = {
    id?: SortOrder
    bootcamp_id?: SortOrder
    training_id?: SortOrder
    order_index?: SortOrder
    required?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: bootcamp_trainingsCountOrderByAggregateInput
    _avg?: bootcamp_trainingsAvgOrderByAggregateInput
    _max?: bootcamp_trainingsMaxOrderByAggregateInput
    _min?: bootcamp_trainingsMinOrderByAggregateInput
    _sum?: bootcamp_trainingsSumOrderByAggregateInput
  }

  export type bootcamp_trainingsScalarWhereWithAggregatesInput = {
    AND?: bootcamp_trainingsScalarWhereWithAggregatesInput | bootcamp_trainingsScalarWhereWithAggregatesInput[]
    OR?: bootcamp_trainingsScalarWhereWithAggregatesInput[]
    NOT?: bootcamp_trainingsScalarWhereWithAggregatesInput | bootcamp_trainingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bootcamp_trainings"> | string
    bootcamp_id?: UuidWithAggregatesFilter<"bootcamp_trainings"> | string
    training_id?: UuidWithAggregatesFilter<"bootcamp_trainings"> | string
    order_index?: IntWithAggregatesFilter<"bootcamp_trainings"> | number
    required?: BoolNullableWithAggregatesFilter<"bootcamp_trainings"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bootcamp_trainings"> | Date | string | null
  }

  export type bootcampsWhereInput = {
    AND?: bootcampsWhereInput | bootcampsWhereInput[]
    OR?: bootcampsWhereInput[]
    NOT?: bootcampsWhereInput | bootcampsWhereInput[]
    id?: UuidFilter<"bootcamps"> | string
    title?: StringFilter<"bootcamps"> | string
    description?: StringNullableFilter<"bootcamps"> | string | null
    category?: StringNullableFilter<"bootcamps"> | string | null
    author?: StringNullableFilter<"bootcamps"> | string | null
    published?: BoolNullableFilter<"bootcamps"> | boolean | null
    duration?: IntNullableFilter<"bootcamps"> | number | null
    deadline?: DateTimeNullableFilter<"bootcamps"> | Date | string | null
    created_at?: DateTimeNullableFilter<"bootcamps"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bootcamps"> | Date | string | null
    bootcamp_progress?: Bootcamp_progressListRelationFilter
    bootcamp_trainings?: Bootcamp_trainingsListRelationFilter
    user_bootcamp_assignments?: User_bootcamp_assignmentsListRelationFilter
    user_training_progress?: User_training_progressListRelationFilter
  }

  export type bootcampsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    bootcamp_progress?: bootcamp_progressOrderByRelationAggregateInput
    bootcamp_trainings?: bootcamp_trainingsOrderByRelationAggregateInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsOrderByRelationAggregateInput
    user_training_progress?: user_training_progressOrderByRelationAggregateInput
  }

  export type bootcampsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bootcampsWhereInput | bootcampsWhereInput[]
    OR?: bootcampsWhereInput[]
    NOT?: bootcampsWhereInput | bootcampsWhereInput[]
    title?: StringFilter<"bootcamps"> | string
    description?: StringNullableFilter<"bootcamps"> | string | null
    category?: StringNullableFilter<"bootcamps"> | string | null
    author?: StringNullableFilter<"bootcamps"> | string | null
    published?: BoolNullableFilter<"bootcamps"> | boolean | null
    duration?: IntNullableFilter<"bootcamps"> | number | null
    deadline?: DateTimeNullableFilter<"bootcamps"> | Date | string | null
    created_at?: DateTimeNullableFilter<"bootcamps"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"bootcamps"> | Date | string | null
    bootcamp_progress?: Bootcamp_progressListRelationFilter
    bootcamp_trainings?: Bootcamp_trainingsListRelationFilter
    user_bootcamp_assignments?: User_bootcamp_assignmentsListRelationFilter
    user_training_progress?: User_training_progressListRelationFilter
  }, "id">

  export type bootcampsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: bootcampsCountOrderByAggregateInput
    _avg?: bootcampsAvgOrderByAggregateInput
    _max?: bootcampsMaxOrderByAggregateInput
    _min?: bootcampsMinOrderByAggregateInput
    _sum?: bootcampsSumOrderByAggregateInput
  }

  export type bootcampsScalarWhereWithAggregatesInput = {
    AND?: bootcampsScalarWhereWithAggregatesInput | bootcampsScalarWhereWithAggregatesInput[]
    OR?: bootcampsScalarWhereWithAggregatesInput[]
    NOT?: bootcampsScalarWhereWithAggregatesInput | bootcampsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"bootcamps"> | string
    title?: StringWithAggregatesFilter<"bootcamps"> | string
    description?: StringNullableWithAggregatesFilter<"bootcamps"> | string | null
    category?: StringNullableWithAggregatesFilter<"bootcamps"> | string | null
    author?: StringNullableWithAggregatesFilter<"bootcamps"> | string | null
    published?: BoolNullableWithAggregatesFilter<"bootcamps"> | boolean | null
    duration?: IntNullableWithAggregatesFilter<"bootcamps"> | number | null
    deadline?: DateTimeNullableWithAggregatesFilter<"bootcamps"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"bootcamps"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"bootcamps"> | Date | string | null
  }

  export type conference_attendeesWhereInput = {
    AND?: conference_attendeesWhereInput | conference_attendeesWhereInput[]
    OR?: conference_attendeesWhereInput[]
    NOT?: conference_attendeesWhereInput | conference_attendeesWhereInput[]
    id?: UuidFilter<"conference_attendees"> | string
    conference_id?: UuidFilter<"conference_attendees"> | string
    user_id?: IntFilter<"conference_attendees"> | number
    registered_at?: DateTimeNullableFilter<"conference_attendees"> | Date | string | null
    attended?: BoolNullableFilter<"conference_attendees"> | boolean | null
    attendance_time?: DateTimeNullableFilter<"conference_attendees"> | Date | string | null
    notes?: StringNullableFilter<"conference_attendees"> | string | null
    conference_trainings?: XOR<Conference_trainingsScalarRelationFilter, conference_trainingsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type conference_attendeesOrderByWithRelationInput = {
    id?: SortOrder
    conference_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrderInput | SortOrder
    attended?: SortOrderInput | SortOrder
    attendance_time?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    conference_trainings?: conference_trainingsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type conference_attendeesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conference_id_user_id?: conference_attendeesConference_idUser_idCompoundUniqueInput
    AND?: conference_attendeesWhereInput | conference_attendeesWhereInput[]
    OR?: conference_attendeesWhereInput[]
    NOT?: conference_attendeesWhereInput | conference_attendeesWhereInput[]
    conference_id?: UuidFilter<"conference_attendees"> | string
    user_id?: IntFilter<"conference_attendees"> | number
    registered_at?: DateTimeNullableFilter<"conference_attendees"> | Date | string | null
    attended?: BoolNullableFilter<"conference_attendees"> | boolean | null
    attendance_time?: DateTimeNullableFilter<"conference_attendees"> | Date | string | null
    notes?: StringNullableFilter<"conference_attendees"> | string | null
    conference_trainings?: XOR<Conference_trainingsScalarRelationFilter, conference_trainingsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "conference_id_user_id">

  export type conference_attendeesOrderByWithAggregationInput = {
    id?: SortOrder
    conference_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrderInput | SortOrder
    attended?: SortOrderInput | SortOrder
    attendance_time?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: conference_attendeesCountOrderByAggregateInput
    _avg?: conference_attendeesAvgOrderByAggregateInput
    _max?: conference_attendeesMaxOrderByAggregateInput
    _min?: conference_attendeesMinOrderByAggregateInput
    _sum?: conference_attendeesSumOrderByAggregateInput
  }

  export type conference_attendeesScalarWhereWithAggregatesInput = {
    AND?: conference_attendeesScalarWhereWithAggregatesInput | conference_attendeesScalarWhereWithAggregatesInput[]
    OR?: conference_attendeesScalarWhereWithAggregatesInput[]
    NOT?: conference_attendeesScalarWhereWithAggregatesInput | conference_attendeesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"conference_attendees"> | string
    conference_id?: UuidWithAggregatesFilter<"conference_attendees"> | string
    user_id?: IntWithAggregatesFilter<"conference_attendees"> | number
    registered_at?: DateTimeNullableWithAggregatesFilter<"conference_attendees"> | Date | string | null
    attended?: BoolNullableWithAggregatesFilter<"conference_attendees"> | boolean | null
    attendance_time?: DateTimeNullableWithAggregatesFilter<"conference_attendees"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"conference_attendees"> | string | null
  }

  export type conference_materialsWhereInput = {
    AND?: conference_materialsWhereInput | conference_materialsWhereInput[]
    OR?: conference_materialsWhereInput[]
    NOT?: conference_materialsWhereInput | conference_materialsWhereInput[]
    id?: UuidFilter<"conference_materials"> | string
    conference_id?: UuidFilter<"conference_materials"> | string
    title?: StringFilter<"conference_materials"> | string
    description?: StringNullableFilter<"conference_materials"> | string | null
    file_path?: StringNullableFilter<"conference_materials"> | string | null
    link?: StringNullableFilter<"conference_materials"> | string | null
    created_at?: DateTimeNullableFilter<"conference_materials"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"conference_materials"> | Date | string | null
    conference_trainings?: XOR<Conference_trainingsScalarRelationFilter, conference_trainingsWhereInput>
  }

  export type conference_materialsOrderByWithRelationInput = {
    id?: SortOrder
    conference_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    conference_trainings?: conference_trainingsOrderByWithRelationInput
  }

  export type conference_materialsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: conference_materialsWhereInput | conference_materialsWhereInput[]
    OR?: conference_materialsWhereInput[]
    NOT?: conference_materialsWhereInput | conference_materialsWhereInput[]
    conference_id?: UuidFilter<"conference_materials"> | string
    title?: StringFilter<"conference_materials"> | string
    description?: StringNullableFilter<"conference_materials"> | string | null
    file_path?: StringNullableFilter<"conference_materials"> | string | null
    link?: StringNullableFilter<"conference_materials"> | string | null
    created_at?: DateTimeNullableFilter<"conference_materials"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"conference_materials"> | Date | string | null
    conference_trainings?: XOR<Conference_trainingsScalarRelationFilter, conference_trainingsWhereInput>
  }, "id">

  export type conference_materialsOrderByWithAggregationInput = {
    id?: SortOrder
    conference_id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: conference_materialsCountOrderByAggregateInput
    _max?: conference_materialsMaxOrderByAggregateInput
    _min?: conference_materialsMinOrderByAggregateInput
  }

  export type conference_materialsScalarWhereWithAggregatesInput = {
    AND?: conference_materialsScalarWhereWithAggregatesInput | conference_materialsScalarWhereWithAggregatesInput[]
    OR?: conference_materialsScalarWhereWithAggregatesInput[]
    NOT?: conference_materialsScalarWhereWithAggregatesInput | conference_materialsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"conference_materials"> | string
    conference_id?: UuidWithAggregatesFilter<"conference_materials"> | string
    title?: StringWithAggregatesFilter<"conference_materials"> | string
    description?: StringNullableWithAggregatesFilter<"conference_materials"> | string | null
    file_path?: StringNullableWithAggregatesFilter<"conference_materials"> | string | null
    link?: StringNullableWithAggregatesFilter<"conference_materials"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"conference_materials"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"conference_materials"> | Date | string | null
  }

  export type conference_trainingsWhereInput = {
    AND?: conference_trainingsWhereInput | conference_trainingsWhereInput[]
    OR?: conference_trainingsWhereInput[]
    NOT?: conference_trainingsWhereInput | conference_trainingsWhereInput[]
    id?: UuidFilter<"conference_trainings"> | string
    title?: StringFilter<"conference_trainings"> | string
    description?: StringNullableFilter<"conference_trainings"> | string | null
    category?: StringNullableFilter<"conference_trainings"> | string | null
    location?: StringFilter<"conference_trainings"> | string
    start_date?: DateTimeFilter<"conference_trainings"> | Date | string
    end_date?: DateTimeFilter<"conference_trainings"> | Date | string
    capacity?: IntNullableFilter<"conference_trainings"> | number | null
    author?: StringNullableFilter<"conference_trainings"> | string | null
    published?: BoolNullableFilter<"conference_trainings"> | boolean | null
    created_at?: DateTimeNullableFilter<"conference_trainings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"conference_trainings"> | Date | string | null
    conference_attendees?: Conference_attendeesListRelationFilter
    conference_materials?: Conference_materialsListRelationFilter
  }

  export type conference_trainingsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    capacity?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    conference_attendees?: conference_attendeesOrderByRelationAggregateInput
    conference_materials?: conference_materialsOrderByRelationAggregateInput
  }

  export type conference_trainingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: conference_trainingsWhereInput | conference_trainingsWhereInput[]
    OR?: conference_trainingsWhereInput[]
    NOT?: conference_trainingsWhereInput | conference_trainingsWhereInput[]
    title?: StringFilter<"conference_trainings"> | string
    description?: StringNullableFilter<"conference_trainings"> | string | null
    category?: StringNullableFilter<"conference_trainings"> | string | null
    location?: StringFilter<"conference_trainings"> | string
    start_date?: DateTimeFilter<"conference_trainings"> | Date | string
    end_date?: DateTimeFilter<"conference_trainings"> | Date | string
    capacity?: IntNullableFilter<"conference_trainings"> | number | null
    author?: StringNullableFilter<"conference_trainings"> | string | null
    published?: BoolNullableFilter<"conference_trainings"> | boolean | null
    created_at?: DateTimeNullableFilter<"conference_trainings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"conference_trainings"> | Date | string | null
    conference_attendees?: Conference_attendeesListRelationFilter
    conference_materials?: Conference_materialsListRelationFilter
  }, "id">

  export type conference_trainingsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    capacity?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: conference_trainingsCountOrderByAggregateInput
    _avg?: conference_trainingsAvgOrderByAggregateInput
    _max?: conference_trainingsMaxOrderByAggregateInput
    _min?: conference_trainingsMinOrderByAggregateInput
    _sum?: conference_trainingsSumOrderByAggregateInput
  }

  export type conference_trainingsScalarWhereWithAggregatesInput = {
    AND?: conference_trainingsScalarWhereWithAggregatesInput | conference_trainingsScalarWhereWithAggregatesInput[]
    OR?: conference_trainingsScalarWhereWithAggregatesInput[]
    NOT?: conference_trainingsScalarWhereWithAggregatesInput | conference_trainingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"conference_trainings"> | string
    title?: StringWithAggregatesFilter<"conference_trainings"> | string
    description?: StringNullableWithAggregatesFilter<"conference_trainings"> | string | null
    category?: StringNullableWithAggregatesFilter<"conference_trainings"> | string | null
    location?: StringWithAggregatesFilter<"conference_trainings"> | string
    start_date?: DateTimeWithAggregatesFilter<"conference_trainings"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"conference_trainings"> | Date | string
    capacity?: IntNullableWithAggregatesFilter<"conference_trainings"> | number | null
    author?: StringNullableWithAggregatesFilter<"conference_trainings"> | string | null
    published?: BoolNullableWithAggregatesFilter<"conference_trainings"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"conference_trainings"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"conference_trainings"> | Date | string | null
  }

  export type enrollmentsWhereInput = {
    AND?: enrollmentsWhereInput | enrollmentsWhereInput[]
    OR?: enrollmentsWhereInput[]
    NOT?: enrollmentsWhereInput | enrollmentsWhereInput[]
    id?: IntFilter<"enrollments"> | number
    user_id?: IntFilter<"enrollments"> | number
    training_id?: UuidFilter<"enrollments"> | string
    status?: StringFilter<"enrollments"> | string
    progress?: IntFilter<"enrollments"> | number
    completed_items?: JsonNullableFilter<"enrollments">
    score?: DecimalNullableFilter<"enrollments"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    last_accessed_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    created_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type enrollmentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completed_items?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    last_accessed_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    trainings?: trainingsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type enrollmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_training_id?: enrollmentsUser_idTraining_idCompoundUniqueInput
    AND?: enrollmentsWhereInput | enrollmentsWhereInput[]
    OR?: enrollmentsWhereInput[]
    NOT?: enrollmentsWhereInput | enrollmentsWhereInput[]
    user_id?: IntFilter<"enrollments"> | number
    training_id?: UuidFilter<"enrollments"> | string
    status?: StringFilter<"enrollments"> | string
    progress?: IntFilter<"enrollments"> | number
    completed_items?: JsonNullableFilter<"enrollments">
    score?: DecimalNullableFilter<"enrollments"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    last_accessed_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    created_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id_training_id">

  export type enrollmentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completed_items?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    last_accessed_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: enrollmentsCountOrderByAggregateInput
    _avg?: enrollmentsAvgOrderByAggregateInput
    _max?: enrollmentsMaxOrderByAggregateInput
    _min?: enrollmentsMinOrderByAggregateInput
    _sum?: enrollmentsSumOrderByAggregateInput
  }

  export type enrollmentsScalarWhereWithAggregatesInput = {
    AND?: enrollmentsScalarWhereWithAggregatesInput | enrollmentsScalarWhereWithAggregatesInput[]
    OR?: enrollmentsScalarWhereWithAggregatesInput[]
    NOT?: enrollmentsScalarWhereWithAggregatesInput | enrollmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"enrollments"> | number
    user_id?: IntWithAggregatesFilter<"enrollments"> | number
    training_id?: UuidWithAggregatesFilter<"enrollments"> | string
    status?: StringWithAggregatesFilter<"enrollments"> | string
    progress?: IntWithAggregatesFilter<"enrollments"> | number
    completed_items?: JsonNullableWithAggregatesFilter<"enrollments">
    score?: DecimalNullableWithAggregatesFilter<"enrollments"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"enrollments"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"enrollments"> | Date | string | null
    last_accessed_at?: DateTimeNullableWithAggregatesFilter<"enrollments"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"enrollments"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"enrollments"> | Date | string | null
  }

  export type questionsWhereInput = {
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    id?: UuidFilter<"questions"> | string
    quiz_id?: UuidFilter<"questions"> | string
    question_text?: StringFilter<"questions"> | string
    question_type?: StringFilter<"questions"> | string
    options?: JsonNullableFilter<"questions">
    correct_answer?: JsonFilter<"questions">
    points?: IntNullableFilter<"questions"> | number | null
    order_index?: IntFilter<"questions"> | number
    createdAt?: DateTimeNullableFilter<"questions"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"questions"> | Date | string | null
    quizzes?: XOR<QuizzesScalarRelationFilter, quizzesWhereInput>
  }

  export type questionsOrderByWithRelationInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    options?: SortOrderInput | SortOrder
    correct_answer?: SortOrder
    points?: SortOrderInput | SortOrder
    order_index?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    quizzes?: quizzesOrderByWithRelationInput
  }

  export type questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quiz_id_order_index?: questionsQuiz_idOrder_indexCompoundUniqueInput
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    quiz_id?: UuidFilter<"questions"> | string
    question_text?: StringFilter<"questions"> | string
    question_type?: StringFilter<"questions"> | string
    options?: JsonNullableFilter<"questions">
    correct_answer?: JsonFilter<"questions">
    points?: IntNullableFilter<"questions"> | number | null
    order_index?: IntFilter<"questions"> | number
    createdAt?: DateTimeNullableFilter<"questions"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"questions"> | Date | string | null
    quizzes?: XOR<QuizzesScalarRelationFilter, quizzesWhereInput>
  }, "id" | "quiz_id_order_index">

  export type questionsOrderByWithAggregationInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    options?: SortOrderInput | SortOrder
    correct_answer?: SortOrder
    points?: SortOrderInput | SortOrder
    order_index?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: questionsCountOrderByAggregateInput
    _avg?: questionsAvgOrderByAggregateInput
    _max?: questionsMaxOrderByAggregateInput
    _min?: questionsMinOrderByAggregateInput
    _sum?: questionsSumOrderByAggregateInput
  }

  export type questionsScalarWhereWithAggregatesInput = {
    AND?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    OR?: questionsScalarWhereWithAggregatesInput[]
    NOT?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"questions"> | string
    quiz_id?: UuidWithAggregatesFilter<"questions"> | string
    question_text?: StringWithAggregatesFilter<"questions"> | string
    question_type?: StringWithAggregatesFilter<"questions"> | string
    options?: JsonNullableWithAggregatesFilter<"questions">
    correct_answer?: JsonWithAggregatesFilter<"questions">
    points?: IntNullableWithAggregatesFilter<"questions"> | number | null
    order_index?: IntWithAggregatesFilter<"questions"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"questions"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"questions"> | Date | string | null
  }

  export type quizzesWhereInput = {
    AND?: quizzesWhereInput | quizzesWhereInput[]
    OR?: quizzesWhereInput[]
    NOT?: quizzesWhereInput | quizzesWhereInput[]
    id?: UuidFilter<"quizzes"> | string
    training_id?: UuidNullableFilter<"quizzes"> | string | null
    title?: StringFilter<"quizzes"> | string
    description?: StringNullableFilter<"quizzes"> | string | null
    pass_threshold?: DecimalNullableFilter<"quizzes"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"quizzes"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"quizzes"> | Date | string | null
    questions?: QuestionsListRelationFilter
    trainings?: XOR<TrainingsNullableScalarRelationFilter, trainingsWhereInput> | null
  }

  export type quizzesOrderByWithRelationInput = {
    id?: SortOrder
    training_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    pass_threshold?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    questions?: questionsOrderByRelationAggregateInput
    trainings?: trainingsOrderByWithRelationInput
  }

  export type quizzesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: quizzesWhereInput | quizzesWhereInput[]
    OR?: quizzesWhereInput[]
    NOT?: quizzesWhereInput | quizzesWhereInput[]
    training_id?: UuidNullableFilter<"quizzes"> | string | null
    title?: StringFilter<"quizzes"> | string
    description?: StringNullableFilter<"quizzes"> | string | null
    pass_threshold?: DecimalNullableFilter<"quizzes"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"quizzes"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"quizzes"> | Date | string | null
    questions?: QuestionsListRelationFilter
    trainings?: XOR<TrainingsNullableScalarRelationFilter, trainingsWhereInput> | null
  }, "id">

  export type quizzesOrderByWithAggregationInput = {
    id?: SortOrder
    training_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    pass_threshold?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: quizzesCountOrderByAggregateInput
    _avg?: quizzesAvgOrderByAggregateInput
    _max?: quizzesMaxOrderByAggregateInput
    _min?: quizzesMinOrderByAggregateInput
    _sum?: quizzesSumOrderByAggregateInput
  }

  export type quizzesScalarWhereWithAggregatesInput = {
    AND?: quizzesScalarWhereWithAggregatesInput | quizzesScalarWhereWithAggregatesInput[]
    OR?: quizzesScalarWhereWithAggregatesInput[]
    NOT?: quizzesScalarWhereWithAggregatesInput | quizzesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"quizzes"> | string
    training_id?: UuidNullableWithAggregatesFilter<"quizzes"> | string | null
    title?: StringWithAggregatesFilter<"quizzes"> | string
    description?: StringNullableWithAggregatesFilter<"quizzes"> | string | null
    pass_threshold?: DecimalNullableWithAggregatesFilter<"quizzes"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"quizzes"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"quizzes"> | Date | string | null
  }

  export type training_contentWhereInput = {
    AND?: training_contentWhereInput | training_contentWhereInput[]
    OR?: training_contentWhereInput[]
    NOT?: training_contentWhereInput | training_contentWhereInput[]
    id?: UuidFilter<"training_content"> | string
    training_id?: UuidFilter<"training_content"> | string
    title?: StringFilter<"training_content"> | string
    content_type?: StringFilter<"training_content"> | string
    content_value?: StringFilter<"training_content"> | string
    order_index?: IntFilter<"training_content"> | number
    createdAt?: DateTimeNullableFilter<"training_content"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"training_content"> | Date | string | null
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
  }

  export type training_contentOrderByWithRelationInput = {
    id?: SortOrder
    training_id?: SortOrder
    title?: SortOrder
    content_type?: SortOrder
    content_value?: SortOrder
    order_index?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    trainings?: trainingsOrderByWithRelationInput
  }

  export type training_contentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    training_id_order_index?: training_contentTraining_idOrder_indexCompoundUniqueInput
    AND?: training_contentWhereInput | training_contentWhereInput[]
    OR?: training_contentWhereInput[]
    NOT?: training_contentWhereInput | training_contentWhereInput[]
    training_id?: UuidFilter<"training_content"> | string
    title?: StringFilter<"training_content"> | string
    content_type?: StringFilter<"training_content"> | string
    content_value?: StringFilter<"training_content"> | string
    order_index?: IntFilter<"training_content"> | number
    createdAt?: DateTimeNullableFilter<"training_content"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"training_content"> | Date | string | null
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
  }, "id" | "training_id_order_index">

  export type training_contentOrderByWithAggregationInput = {
    id?: SortOrder
    training_id?: SortOrder
    title?: SortOrder
    content_type?: SortOrder
    content_value?: SortOrder
    order_index?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: training_contentCountOrderByAggregateInput
    _avg?: training_contentAvgOrderByAggregateInput
    _max?: training_contentMaxOrderByAggregateInput
    _min?: training_contentMinOrderByAggregateInput
    _sum?: training_contentSumOrderByAggregateInput
  }

  export type training_contentScalarWhereWithAggregatesInput = {
    AND?: training_contentScalarWhereWithAggregatesInput | training_contentScalarWhereWithAggregatesInput[]
    OR?: training_contentScalarWhereWithAggregatesInput[]
    NOT?: training_contentScalarWhereWithAggregatesInput | training_contentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"training_content"> | string
    training_id?: UuidWithAggregatesFilter<"training_content"> | string
    title?: StringWithAggregatesFilter<"training_content"> | string
    content_type?: StringWithAggregatesFilter<"training_content"> | string
    content_value?: StringWithAggregatesFilter<"training_content"> | string
    order_index?: IntWithAggregatesFilter<"training_content"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"training_content"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"training_content"> | Date | string | null
  }

  export type trainingsWhereInput = {
    AND?: trainingsWhereInput | trainingsWhereInput[]
    OR?: trainingsWhereInput[]
    NOT?: trainingsWhereInput | trainingsWhereInput[]
    id?: UuidFilter<"trainings"> | string
    title?: StringFilter<"trainings"> | string
    description?: StringNullableFilter<"trainings"> | string | null
    category?: StringNullableFilter<"trainings"> | string | null
    duration?: IntNullableFilter<"trainings"> | number | null
    author?: StringNullableFilter<"trainings"> | string | null
    published?: BoolNullableFilter<"trainings"> | boolean | null
    tags?: StringNullableListFilter<"trainings">
    createdAt?: DateTimeNullableFilter<"trainings"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"trainings"> | Date | string | null
    certificateTemplate?: StringNullableFilter<"trainings"> | string | null
    learning_outcomes?: StringNullableListFilter<"trainings">
    deadline?: DateTimeNullableFilter<"trainings"> | Date | string | null
    is_mandatory?: BoolNullableFilter<"trainings"> | boolean | null
    bootcamp_trainings?: Bootcamp_trainingsListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    quizzes?: QuizzesListRelationFilter
    training_content?: Training_contentListRelationFilter
    user_training_assignments?: User_training_assignmentsListRelationFilter
    user_training_progress?: User_training_progressListRelationFilter
  }

  export type trainingsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    certificateTemplate?: SortOrderInput | SortOrder
    learning_outcomes?: SortOrder
    deadline?: SortOrderInput | SortOrder
    is_mandatory?: SortOrderInput | SortOrder
    bootcamp_trainings?: bootcamp_trainingsOrderByRelationAggregateInput
    enrollments?: enrollmentsOrderByRelationAggregateInput
    quizzes?: quizzesOrderByRelationAggregateInput
    training_content?: training_contentOrderByRelationAggregateInput
    user_training_assignments?: user_training_assignmentsOrderByRelationAggregateInput
    user_training_progress?: user_training_progressOrderByRelationAggregateInput
  }

  export type trainingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: trainingsWhereInput | trainingsWhereInput[]
    OR?: trainingsWhereInput[]
    NOT?: trainingsWhereInput | trainingsWhereInput[]
    title?: StringFilter<"trainings"> | string
    description?: StringNullableFilter<"trainings"> | string | null
    category?: StringNullableFilter<"trainings"> | string | null
    duration?: IntNullableFilter<"trainings"> | number | null
    author?: StringNullableFilter<"trainings"> | string | null
    published?: BoolNullableFilter<"trainings"> | boolean | null
    tags?: StringNullableListFilter<"trainings">
    createdAt?: DateTimeNullableFilter<"trainings"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"trainings"> | Date | string | null
    certificateTemplate?: StringNullableFilter<"trainings"> | string | null
    learning_outcomes?: StringNullableListFilter<"trainings">
    deadline?: DateTimeNullableFilter<"trainings"> | Date | string | null
    is_mandatory?: BoolNullableFilter<"trainings"> | boolean | null
    bootcamp_trainings?: Bootcamp_trainingsListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    quizzes?: QuizzesListRelationFilter
    training_content?: Training_contentListRelationFilter
    user_training_assignments?: User_training_assignmentsListRelationFilter
    user_training_progress?: User_training_progressListRelationFilter
  }, "id">

  export type trainingsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    published?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    certificateTemplate?: SortOrderInput | SortOrder
    learning_outcomes?: SortOrder
    deadline?: SortOrderInput | SortOrder
    is_mandatory?: SortOrderInput | SortOrder
    _count?: trainingsCountOrderByAggregateInput
    _avg?: trainingsAvgOrderByAggregateInput
    _max?: trainingsMaxOrderByAggregateInput
    _min?: trainingsMinOrderByAggregateInput
    _sum?: trainingsSumOrderByAggregateInput
  }

  export type trainingsScalarWhereWithAggregatesInput = {
    AND?: trainingsScalarWhereWithAggregatesInput | trainingsScalarWhereWithAggregatesInput[]
    OR?: trainingsScalarWhereWithAggregatesInput[]
    NOT?: trainingsScalarWhereWithAggregatesInput | trainingsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"trainings"> | string
    title?: StringWithAggregatesFilter<"trainings"> | string
    description?: StringNullableWithAggregatesFilter<"trainings"> | string | null
    category?: StringNullableWithAggregatesFilter<"trainings"> | string | null
    duration?: IntNullableWithAggregatesFilter<"trainings"> | number | null
    author?: StringNullableWithAggregatesFilter<"trainings"> | string | null
    published?: BoolNullableWithAggregatesFilter<"trainings"> | boolean | null
    tags?: StringNullableListFilter<"trainings">
    createdAt?: DateTimeNullableWithAggregatesFilter<"trainings"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"trainings"> | Date | string | null
    certificateTemplate?: StringNullableWithAggregatesFilter<"trainings"> | string | null
    learning_outcomes?: StringNullableListFilter<"trainings">
    deadline?: DateTimeNullableWithAggregatesFilter<"trainings"> | Date | string | null
    is_mandatory?: BoolNullableWithAggregatesFilter<"trainings"> | boolean | null
  }

  export type user_bootcamp_assignmentsWhereInput = {
    AND?: user_bootcamp_assignmentsWhereInput | user_bootcamp_assignmentsWhereInput[]
    OR?: user_bootcamp_assignmentsWhereInput[]
    NOT?: user_bootcamp_assignmentsWhereInput | user_bootcamp_assignmentsWhereInput[]
    id?: UuidFilter<"user_bootcamp_assignments"> | string
    user_id?: IntFilter<"user_bootcamp_assignments"> | number
    bootcamp_id?: UuidFilter<"user_bootcamp_assignments"> | string
    assigned_at?: DateTimeNullableFilter<"user_bootcamp_assignments"> | Date | string | null
    completed?: BoolNullableFilter<"user_bootcamp_assignments"> | boolean | null
    completion_date?: DateTimeNullableFilter<"user_bootcamp_assignments"> | Date | string | null
    bootcamps?: XOR<BootcampsScalarRelationFilter, bootcampsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type user_bootcamp_assignmentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    assigned_at?: SortOrderInput | SortOrder
    completed?: SortOrderInput | SortOrder
    completion_date?: SortOrderInput | SortOrder
    bootcamps?: bootcampsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type user_bootcamp_assignmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id_bootcamp_id?: user_bootcamp_assignmentsUser_idBootcamp_idCompoundUniqueInput
    AND?: user_bootcamp_assignmentsWhereInput | user_bootcamp_assignmentsWhereInput[]
    OR?: user_bootcamp_assignmentsWhereInput[]
    NOT?: user_bootcamp_assignmentsWhereInput | user_bootcamp_assignmentsWhereInput[]
    user_id?: IntFilter<"user_bootcamp_assignments"> | number
    bootcamp_id?: UuidFilter<"user_bootcamp_assignments"> | string
    assigned_at?: DateTimeNullableFilter<"user_bootcamp_assignments"> | Date | string | null
    completed?: BoolNullableFilter<"user_bootcamp_assignments"> | boolean | null
    completion_date?: DateTimeNullableFilter<"user_bootcamp_assignments"> | Date | string | null
    bootcamps?: XOR<BootcampsScalarRelationFilter, bootcampsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "user_id_bootcamp_id">

  export type user_bootcamp_assignmentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    assigned_at?: SortOrderInput | SortOrder
    completed?: SortOrderInput | SortOrder
    completion_date?: SortOrderInput | SortOrder
    _count?: user_bootcamp_assignmentsCountOrderByAggregateInput
    _avg?: user_bootcamp_assignmentsAvgOrderByAggregateInput
    _max?: user_bootcamp_assignmentsMaxOrderByAggregateInput
    _min?: user_bootcamp_assignmentsMinOrderByAggregateInput
    _sum?: user_bootcamp_assignmentsSumOrderByAggregateInput
  }

  export type user_bootcamp_assignmentsScalarWhereWithAggregatesInput = {
    AND?: user_bootcamp_assignmentsScalarWhereWithAggregatesInput | user_bootcamp_assignmentsScalarWhereWithAggregatesInput[]
    OR?: user_bootcamp_assignmentsScalarWhereWithAggregatesInput[]
    NOT?: user_bootcamp_assignmentsScalarWhereWithAggregatesInput | user_bootcamp_assignmentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"user_bootcamp_assignments"> | string
    user_id?: IntWithAggregatesFilter<"user_bootcamp_assignments"> | number
    bootcamp_id?: UuidWithAggregatesFilter<"user_bootcamp_assignments"> | string
    assigned_at?: DateTimeNullableWithAggregatesFilter<"user_bootcamp_assignments"> | Date | string | null
    completed?: BoolNullableWithAggregatesFilter<"user_bootcamp_assignments"> | boolean | null
    completion_date?: DateTimeNullableWithAggregatesFilter<"user_bootcamp_assignments"> | Date | string | null
  }

  export type user_quiz_attemptsWhereInput = {
    AND?: user_quiz_attemptsWhereInput | user_quiz_attemptsWhereInput[]
    OR?: user_quiz_attemptsWhereInput[]
    NOT?: user_quiz_attemptsWhereInput | user_quiz_attemptsWhereInput[]
    id?: IntFilter<"user_quiz_attempts"> | number
    user_id?: IntFilter<"user_quiz_attempts"> | number
    quiz_id?: UuidFilter<"user_quiz_attempts"> | string
    training_id?: UuidFilter<"user_quiz_attempts"> | string
    attempt_number?: IntFilter<"user_quiz_attempts"> | number
    score?: DecimalFilter<"user_quiz_attempts"> | Decimal | DecimalJsLike | number | string
    passed?: BoolFilter<"user_quiz_attempts"> | boolean
    submitted_at?: DateTimeFilter<"user_quiz_attempts"> | Date | string
    answers?: JsonNullableFilter<"user_quiz_attempts">
  }

  export type user_quiz_attemptsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    quiz_id?: SortOrder
    training_id?: SortOrder
    attempt_number?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    submitted_at?: SortOrder
    answers?: SortOrderInput | SortOrder
  }

  export type user_quiz_attemptsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_quiz_id_attempt_number?: user_quiz_attemptsUser_idQuiz_idAttempt_numberCompoundUniqueInput
    AND?: user_quiz_attemptsWhereInput | user_quiz_attemptsWhereInput[]
    OR?: user_quiz_attemptsWhereInput[]
    NOT?: user_quiz_attemptsWhereInput | user_quiz_attemptsWhereInput[]
    user_id?: IntFilter<"user_quiz_attempts"> | number
    quiz_id?: UuidFilter<"user_quiz_attempts"> | string
    training_id?: UuidFilter<"user_quiz_attempts"> | string
    attempt_number?: IntFilter<"user_quiz_attempts"> | number
    score?: DecimalFilter<"user_quiz_attempts"> | Decimal | DecimalJsLike | number | string
    passed?: BoolFilter<"user_quiz_attempts"> | boolean
    submitted_at?: DateTimeFilter<"user_quiz_attempts"> | Date | string
    answers?: JsonNullableFilter<"user_quiz_attempts">
  }, "id" | "user_id_quiz_id_attempt_number">

  export type user_quiz_attemptsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    quiz_id?: SortOrder
    training_id?: SortOrder
    attempt_number?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    submitted_at?: SortOrder
    answers?: SortOrderInput | SortOrder
    _count?: user_quiz_attemptsCountOrderByAggregateInput
    _avg?: user_quiz_attemptsAvgOrderByAggregateInput
    _max?: user_quiz_attemptsMaxOrderByAggregateInput
    _min?: user_quiz_attemptsMinOrderByAggregateInput
    _sum?: user_quiz_attemptsSumOrderByAggregateInput
  }

  export type user_quiz_attemptsScalarWhereWithAggregatesInput = {
    AND?: user_quiz_attemptsScalarWhereWithAggregatesInput | user_quiz_attemptsScalarWhereWithAggregatesInput[]
    OR?: user_quiz_attemptsScalarWhereWithAggregatesInput[]
    NOT?: user_quiz_attemptsScalarWhereWithAggregatesInput | user_quiz_attemptsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_quiz_attempts"> | number
    user_id?: IntWithAggregatesFilter<"user_quiz_attempts"> | number
    quiz_id?: UuidWithAggregatesFilter<"user_quiz_attempts"> | string
    training_id?: UuidWithAggregatesFilter<"user_quiz_attempts"> | string
    attempt_number?: IntWithAggregatesFilter<"user_quiz_attempts"> | number
    score?: DecimalWithAggregatesFilter<"user_quiz_attempts"> | Decimal | DecimalJsLike | number | string
    passed?: BoolWithAggregatesFilter<"user_quiz_attempts"> | boolean
    submitted_at?: DateTimeWithAggregatesFilter<"user_quiz_attempts"> | Date | string
    answers?: JsonNullableWithAggregatesFilter<"user_quiz_attempts">
  }

  export type user_training_assignmentsWhereInput = {
    AND?: user_training_assignmentsWhereInput | user_training_assignmentsWhereInput[]
    OR?: user_training_assignmentsWhereInput[]
    NOT?: user_training_assignmentsWhereInput | user_training_assignmentsWhereInput[]
    assignment_id?: IntFilter<"user_training_assignments"> | number
    user_id?: IntFilter<"user_training_assignments"> | number
    training_id?: UuidFilter<"user_training_assignments"> | string
    assigned_at?: DateTimeNullableFilter<"user_training_assignments"> | Date | string | null
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type user_training_assignmentsOrderByWithRelationInput = {
    assignment_id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    assigned_at?: SortOrderInput | SortOrder
    trainings?: trainingsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type user_training_assignmentsWhereUniqueInput = Prisma.AtLeast<{
    assignment_id?: number
    user_id_training_id?: user_training_assignmentsUser_idTraining_idCompoundUniqueInput
    AND?: user_training_assignmentsWhereInput | user_training_assignmentsWhereInput[]
    OR?: user_training_assignmentsWhereInput[]
    NOT?: user_training_assignmentsWhereInput | user_training_assignmentsWhereInput[]
    user_id?: IntFilter<"user_training_assignments"> | number
    training_id?: UuidFilter<"user_training_assignments"> | string
    assigned_at?: DateTimeNullableFilter<"user_training_assignments"> | Date | string | null
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "assignment_id" | "user_id_training_id">

  export type user_training_assignmentsOrderByWithAggregationInput = {
    assignment_id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    assigned_at?: SortOrderInput | SortOrder
    _count?: user_training_assignmentsCountOrderByAggregateInput
    _avg?: user_training_assignmentsAvgOrderByAggregateInput
    _max?: user_training_assignmentsMaxOrderByAggregateInput
    _min?: user_training_assignmentsMinOrderByAggregateInput
    _sum?: user_training_assignmentsSumOrderByAggregateInput
  }

  export type user_training_assignmentsScalarWhereWithAggregatesInput = {
    AND?: user_training_assignmentsScalarWhereWithAggregatesInput | user_training_assignmentsScalarWhereWithAggregatesInput[]
    OR?: user_training_assignmentsScalarWhereWithAggregatesInput[]
    NOT?: user_training_assignmentsScalarWhereWithAggregatesInput | user_training_assignmentsScalarWhereWithAggregatesInput[]
    assignment_id?: IntWithAggregatesFilter<"user_training_assignments"> | number
    user_id?: IntWithAggregatesFilter<"user_training_assignments"> | number
    training_id?: UuidWithAggregatesFilter<"user_training_assignments"> | string
    assigned_at?: DateTimeNullableWithAggregatesFilter<"user_training_assignments"> | Date | string | null
  }

  export type user_training_progressWhereInput = {
    AND?: user_training_progressWhereInput | user_training_progressWhereInput[]
    OR?: user_training_progressWhereInput[]
    NOT?: user_training_progressWhereInput | user_training_progressWhereInput[]
    user_id?: IntFilter<"user_training_progress"> | number
    bootcamp_id?: UuidNullableFilter<"user_training_progress"> | string | null
    training_id?: UuidFilter<"user_training_progress"> | string
    status?: StringFilter<"user_training_progress"> | string
    started_at?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
    progress_percentage?: DecimalFilter<"user_training_progress"> | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonFilter<"user_training_progress">
    completion_duration_seconds?: IntNullableFilter<"user_training_progress"> | number | null
    updatedAt?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
    bootcamps?: XOR<BootcampsNullableScalarRelationFilter, bootcampsWhereInput> | null
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type user_training_progressOrderByWithRelationInput = {
    user_id?: SortOrder
    bootcamp_id?: SortOrderInput | SortOrder
    training_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    progress_percentage?: SortOrder
    completed_content_items?: SortOrder
    completion_duration_seconds?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    bootcamps?: bootcampsOrderByWithRelationInput
    trainings?: trainingsOrderByWithRelationInput
    users?: UserOrderByWithRelationInput
  }

  export type user_training_progressWhereUniqueInput = Prisma.AtLeast<{
    user_id_training_id?: user_training_progressUser_idTraining_idCompoundUniqueInput
    AND?: user_training_progressWhereInput | user_training_progressWhereInput[]
    OR?: user_training_progressWhereInput[]
    NOT?: user_training_progressWhereInput | user_training_progressWhereInput[]
    user_id?: IntFilter<"user_training_progress"> | number
    bootcamp_id?: UuidNullableFilter<"user_training_progress"> | string | null
    training_id?: UuidFilter<"user_training_progress"> | string
    status?: StringFilter<"user_training_progress"> | string
    started_at?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
    progress_percentage?: DecimalFilter<"user_training_progress"> | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonFilter<"user_training_progress">
    completion_duration_seconds?: IntNullableFilter<"user_training_progress"> | number | null
    updatedAt?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
    bootcamps?: XOR<BootcampsNullableScalarRelationFilter, bootcampsWhereInput> | null
    trainings?: XOR<TrainingsScalarRelationFilter, trainingsWhereInput>
    users?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "user_id_training_id">

  export type user_training_progressOrderByWithAggregationInput = {
    user_id?: SortOrder
    bootcamp_id?: SortOrderInput | SortOrder
    training_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    progress_percentage?: SortOrder
    completed_content_items?: SortOrder
    completion_duration_seconds?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: user_training_progressCountOrderByAggregateInput
    _avg?: user_training_progressAvgOrderByAggregateInput
    _max?: user_training_progressMaxOrderByAggregateInput
    _min?: user_training_progressMinOrderByAggregateInput
    _sum?: user_training_progressSumOrderByAggregateInput
  }

  export type user_training_progressScalarWhereWithAggregatesInput = {
    AND?: user_training_progressScalarWhereWithAggregatesInput | user_training_progressScalarWhereWithAggregatesInput[]
    OR?: user_training_progressScalarWhereWithAggregatesInput[]
    NOT?: user_training_progressScalarWhereWithAggregatesInput | user_training_progressScalarWhereWithAggregatesInput[]
    user_id?: IntWithAggregatesFilter<"user_training_progress"> | number
    bootcamp_id?: UuidNullableWithAggregatesFilter<"user_training_progress"> | string | null
    training_id?: UuidWithAggregatesFilter<"user_training_progress"> | string
    status?: StringWithAggregatesFilter<"user_training_progress"> | string
    started_at?: DateTimeNullableWithAggregatesFilter<"user_training_progress"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"user_training_progress"> | Date | string | null
    progress_percentage?: DecimalWithAggregatesFilter<"user_training_progress"> | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonWithAggregatesFilter<"user_training_progress">
    completion_duration_seconds?: IntNullableWithAggregatesFilter<"user_training_progress"> | number | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"user_training_progress"> | Date | string | null
  }

  export type UserCreateInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    telesetCardNo?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    telesetCardNo?: string | null
    userId: number
    departmentId?: number | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateInput = {
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyInput = {
    id?: number
    telesetCardNo?: string | null
    userId: number
    departmentId?: number | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    adminLevel: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    adminLevel: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    adminLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminLevel?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: number
    adminLevel: string
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    adminLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminLevel?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogCreateInput = {
    action_type: string
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: boolean | null
    users?: UserCreateNestedOneWithoutLogsInput
  }

  export type LogUncheckedCreateInput = {
    id?: number
    action_type: string
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: boolean | null
  }

  export type LogUpdateInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: NullableBoolFieldUpdateOperationsInput | boolean | null
    users?: UserUpdateOneWithoutLogsNestedInput
  }

  export type LogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LogCreateManyInput = {
    id?: number
    action_type: string
    user_id?: number | null
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: boolean | null
  }

  export type LogUpdateManyMutationInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type admin_permission_logsCreateInput = {
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
    users_admin_permission_logs_modified_byTousers: UserCreateNestedOneWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput
    users_admin_permission_logs_user_idTousers: UserCreateNestedOneWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput
  }

  export type admin_permission_logsUncheckedCreateInput = {
    id?: number
    user_id: number
    modified_by: number
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
  }

  export type admin_permission_logsUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    users_admin_permission_logs_modified_byTousers?: UserUpdateOneRequiredWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersNestedInput
    users_admin_permission_logs_user_idTousers?: UserUpdateOneRequiredWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersNestedInput
  }

  export type admin_permission_logsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    modified_by?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permission_logsCreateManyInput = {
    id?: number
    user_id: number
    modified_by: number
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
  }

  export type admin_permission_logsUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permission_logsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    modified_by?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permissionsCreateInput = {
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
    users_admin_permissions_granted_byTousers: UserCreateNestedOneWithoutAdmin_permissions_admin_permissions_granted_byTousersInput
    users_admin_permissions_user_idTousers: UserCreateNestedOneWithoutAdmin_permissions_admin_permissions_user_idTousersInput
  }

  export type admin_permissionsUncheckedCreateInput = {
    id?: number
    user_id: number
    granted_by: number
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
  }

  export type admin_permissionsUpdateInput = {
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    users_admin_permissions_granted_byTousers?: UserUpdateOneRequiredWithoutAdmin_permissions_admin_permissions_granted_byTousersNestedInput
    users_admin_permissions_user_idTousers?: UserUpdateOneRequiredWithoutAdmin_permissions_admin_permissions_user_idTousersNestedInput
  }

  export type admin_permissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    granted_by?: IntFieldUpdateOperationsInput | number
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_permissionsCreateManyInput = {
    id?: number
    user_id: number
    granted_by: number
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
  }

  export type admin_permissionsUpdateManyMutationInput = {
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_permissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    granted_by?: IntFieldUpdateOperationsInput | number
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type bootcamp_progressCreateInput = {
    id?: string
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
    bootcamps: bootcampsCreateNestedOneWithoutBootcamp_progressInput
    users: UserCreateNestedOneWithoutBootcamp_progressInput
  }

  export type bootcamp_progressUncheckedCreateInput = {
    id?: string
    user_id: number
    bootcamp_id: string
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
  }

  export type bootcamp_progressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneRequiredWithoutBootcamp_progressNestedInput
    users?: UserUpdateOneRequiredWithoutBootcamp_progressNestedInput
  }

  export type bootcamp_progressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_progressCreateManyInput = {
    id?: string
    user_id: number
    bootcamp_id: string
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
  }

  export type bootcamp_progressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_progressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_trainingsCreateInput = {
    id?: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
    bootcamps: bootcampsCreateNestedOneWithoutBootcamp_trainingsInput
    trainings: trainingsCreateNestedOneWithoutBootcamp_trainingsInput
  }

  export type bootcamp_trainingsUncheckedCreateInput = {
    id?: string
    bootcamp_id: string
    training_id: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
  }

  export type bootcamp_trainingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneRequiredWithoutBootcamp_trainingsNestedInput
    trainings?: trainingsUpdateOneRequiredWithoutBootcamp_trainingsNestedInput
  }

  export type bootcamp_trainingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_trainingsCreateManyInput = {
    id?: string
    bootcamp_id: string
    training_id: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
  }

  export type bootcamp_trainingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_trainingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcampsCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutBootcampsInput
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutBootcampsInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutBootcampsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutBootcampsInput
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutBootcampsInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutBootcampsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutBootcampsNestedInput
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutBootcampsNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutBootcampsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutBootcampsNestedInput
  }

  export type bootcampsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutBootcampsNestedInput
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutBootcampsNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutBootcampsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutBootcampsNestedInput
  }

  export type bootcampsCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type bootcampsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcampsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_attendeesCreateInput = {
    id?: string
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
    conference_trainings: conference_trainingsCreateNestedOneWithoutConference_attendeesInput
    users: UserCreateNestedOneWithoutConference_attendeesInput
  }

  export type conference_attendeesUncheckedCreateInput = {
    id?: string
    conference_id: string
    user_id: number
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
  }

  export type conference_attendeesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    conference_trainings?: conference_trainingsUpdateOneRequiredWithoutConference_attendeesNestedInput
    users?: UserUpdateOneRequiredWithoutConference_attendeesNestedInput
  }

  export type conference_attendeesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conference_id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conference_attendeesCreateManyInput = {
    id?: string
    conference_id: string
    user_id: number
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
  }

  export type conference_attendeesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conference_attendeesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conference_id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conference_materialsCreateInput = {
    id?: string
    title: string
    description?: string | null
    file_path?: string | null
    link?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    conference_trainings: conference_trainingsCreateNestedOneWithoutConference_materialsInput
  }

  export type conference_materialsUncheckedCreateInput = {
    id?: string
    conference_id: string
    title: string
    description?: string | null
    file_path?: string | null
    link?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type conference_materialsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conference_trainings?: conference_trainingsUpdateOneRequiredWithoutConference_materialsNestedInput
  }

  export type conference_materialsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conference_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_materialsCreateManyInput = {
    id?: string
    conference_id: string
    title: string
    description?: string | null
    file_path?: string | null
    link?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type conference_materialsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_materialsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conference_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_trainingsCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    location: string
    start_date: Date | string
    end_date: Date | string
    capacity?: number | null
    author?: string | null
    published?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    conference_attendees?: conference_attendeesCreateNestedManyWithoutConference_trainingsInput
    conference_materials?: conference_materialsCreateNestedManyWithoutConference_trainingsInput
  }

  export type conference_trainingsUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    location: string
    start_date: Date | string
    end_date: Date | string
    capacity?: number | null
    author?: string | null
    published?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutConference_trainingsInput
    conference_materials?: conference_materialsUncheckedCreateNestedManyWithoutConference_trainingsInput
  }

  export type conference_trainingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conference_attendees?: conference_attendeesUpdateManyWithoutConference_trainingsNestedInput
    conference_materials?: conference_materialsUpdateManyWithoutConference_trainingsNestedInput
  }

  export type conference_trainingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutConference_trainingsNestedInput
    conference_materials?: conference_materialsUncheckedUpdateManyWithoutConference_trainingsNestedInput
  }

  export type conference_trainingsCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    location: string
    start_date: Date | string
    end_date: Date | string
    capacity?: number | null
    author?: string | null
    published?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type conference_trainingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_trainingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsCreateInput = {
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    trainings: trainingsCreateNestedOneWithoutEnrollmentsInput
    users: UserCreateNestedOneWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateInput = {
    id?: number
    user_id: number
    training_id: string
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type enrollmentsUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainings?: trainingsUpdateOneRequiredWithoutEnrollmentsNestedInput
    users?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsCreateManyInput = {
    id?: number
    user_id: number
    training_id: string
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type enrollmentsUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsCreateInput = {
    id?: string
    question_text: string
    question_type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    points?: number | null
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    quizzes: quizzesCreateNestedOneWithoutQuestionsInput
  }

  export type questionsUncheckedCreateInput = {
    id?: string
    quiz_id: string
    question_text: string
    question_type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    points?: number | null
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type questionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    points?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: quizzesUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    points?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsCreateManyInput = {
    id?: string
    quiz_id: string
    question_text: string
    question_type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    points?: number | null
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type questionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    points?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quiz_id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    points?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type quizzesCreateInput = {
    id?: string
    title: string
    description?: string | null
    pass_threshold?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    questions?: questionsCreateNestedManyWithoutQuizzesInput
    trainings?: trainingsCreateNestedOneWithoutQuizzesInput
  }

  export type quizzesUncheckedCreateInput = {
    id?: string
    training_id?: string | null
    title: string
    description?: string | null
    pass_threshold?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    questions?: questionsUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type quizzesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: questionsUpdateManyWithoutQuizzesNestedInput
    trainings?: trainingsUpdateOneWithoutQuizzesNestedInput
  }

  export type quizzesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_id?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: questionsUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type quizzesCreateManyInput = {
    id?: string
    training_id?: string | null
    title: string
    description?: string | null
    pass_threshold?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type quizzesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type quizzesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_id?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type training_contentCreateInput = {
    id?: string
    title: string
    content_type: string
    content_value: string
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    trainings: trainingsCreateNestedOneWithoutTraining_contentInput
  }

  export type training_contentUncheckedCreateInput = {
    id?: string
    training_id: string
    title: string
    content_type: string
    content_value: string
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type training_contentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content_type?: StringFieldUpdateOperationsInput | string
    content_value?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainings?: trainingsUpdateOneRequiredWithoutTraining_contentNestedInput
  }

  export type training_contentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content_type?: StringFieldUpdateOperationsInput | string
    content_value?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type training_contentCreateManyInput = {
    id?: string
    training_id: string
    title: string
    content_type: string
    content_value: string
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type training_contentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content_type?: StringFieldUpdateOperationsInput | string
    content_value?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type training_contentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content_type?: StringFieldUpdateOperationsInput | string
    content_value?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type trainingsCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesUncheckedCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUncheckedUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
  }

  export type trainingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type trainingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type user_bootcamp_assignmentsCreateInput = {
    id?: string
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
    bootcamps: bootcampsCreateNestedOneWithoutUser_bootcamp_assignmentsInput
    users: UserCreateNestedOneWithoutUser_bootcamp_assignmentsInput
  }

  export type user_bootcamp_assignmentsUncheckedCreateInput = {
    id?: string
    user_id: number
    bootcamp_id: string
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
  }

  export type user_bootcamp_assignmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneRequiredWithoutUser_bootcamp_assignmentsNestedInput
    users?: UserUpdateOneRequiredWithoutUser_bootcamp_assignmentsNestedInput
  }

  export type user_bootcamp_assignmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_bootcamp_assignmentsCreateManyInput = {
    id?: string
    user_id: number
    bootcamp_id: string
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
  }

  export type user_bootcamp_assignmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_bootcamp_assignmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_quiz_attemptsCreateInput = {
    user_id: number
    quiz_id: string
    training_id: string
    attempt_number?: number
    score?: Decimal | DecimalJsLike | number | string
    passed?: boolean
    submitted_at?: Date | string
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type user_quiz_attemptsUncheckedCreateInput = {
    id?: number
    user_id: number
    quiz_id: string
    training_id: string
    attempt_number?: number
    score?: Decimal | DecimalJsLike | number | string
    passed?: boolean
    submitted_at?: Date | string
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type user_quiz_attemptsUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    attempt_number?: IntFieldUpdateOperationsInput | number
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passed?: BoolFieldUpdateOperationsInput | boolean
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type user_quiz_attemptsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    attempt_number?: IntFieldUpdateOperationsInput | number
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passed?: BoolFieldUpdateOperationsInput | boolean
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type user_quiz_attemptsCreateManyInput = {
    id?: number
    user_id: number
    quiz_id: string
    training_id: string
    attempt_number?: number
    score?: Decimal | DecimalJsLike | number | string
    passed?: boolean
    submitted_at?: Date | string
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type user_quiz_attemptsUpdateManyMutationInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    attempt_number?: IntFieldUpdateOperationsInput | number
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passed?: BoolFieldUpdateOperationsInput | boolean
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type user_quiz_attemptsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    quiz_id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    attempt_number?: IntFieldUpdateOperationsInput | number
    score?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    passed?: BoolFieldUpdateOperationsInput | boolean
    submitted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: NullableJsonNullValueInput | InputJsonValue
  }

  export type user_training_assignmentsCreateInput = {
    assigned_at?: Date | string | null
    trainings: trainingsCreateNestedOneWithoutUser_training_assignmentsInput
    users: UserCreateNestedOneWithoutUser_training_assignmentsInput
  }

  export type user_training_assignmentsUncheckedCreateInput = {
    assignment_id?: number
    user_id: number
    training_id: string
    assigned_at?: Date | string | null
  }

  export type user_training_assignmentsUpdateInput = {
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainings?: trainingsUpdateOneRequiredWithoutUser_training_assignmentsNestedInput
    users?: UserUpdateOneRequiredWithoutUser_training_assignmentsNestedInput
  }

  export type user_training_assignmentsUncheckedUpdateInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_assignmentsCreateManyInput = {
    assignment_id?: number
    user_id: number
    training_id: string
    assigned_at?: Date | string | null
  }

  export type user_training_assignmentsUpdateManyMutationInput = {
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_assignmentsUncheckedUpdateManyInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressCreateInput = {
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
    bootcamps?: bootcampsCreateNestedOneWithoutUser_training_progressInput
    trainings: trainingsCreateNestedOneWithoutUser_training_progressInput
    users: UserCreateNestedOneWithoutUser_training_progressInput
  }

  export type user_training_progressUncheckedCreateInput = {
    user_id: number
    bootcamp_id?: string | null
    training_id: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
  }

  export type user_training_progressUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneWithoutUser_training_progressNestedInput
    trainings?: trainingsUpdateOneRequiredWithoutUser_training_progressNestedInput
    users?: UserUpdateOneRequiredWithoutUser_training_progressNestedInput
  }

  export type user_training_progressUncheckedUpdateInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    bootcamp_id?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressCreateManyInput = {
    user_id: number
    bootcamp_id?: string | null
    training_id: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
  }

  export type user_training_progressUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressUncheckedUpdateManyInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    bootcamp_id?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Enumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type Enumlogin_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.login_type | Enumlogin_typeFieldRefInput<$PrismaModel>
    in?: $Enums.login_type[] | ListEnumlogin_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.login_type[] | ListEnumlogin_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumlogin_typeFilter<$PrismaModel> | $Enums.login_type
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Admin_permission_logsListRelationFilter = {
    every?: admin_permission_logsWhereInput
    some?: admin_permission_logsWhereInput
    none?: admin_permission_logsWhereInput
  }

  export type Admin_permissionsListRelationFilter = {
    every?: admin_permissionsWhereInput
    some?: admin_permissionsWhereInput
    none?: admin_permissionsWhereInput
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type Bootcamp_progressListRelationFilter = {
    every?: bootcamp_progressWhereInput
    some?: bootcamp_progressWhereInput
    none?: bootcamp_progressWhereInput
  }

  export type Conference_attendeesListRelationFilter = {
    every?: conference_attendeesWhereInput
    some?: conference_attendeesWhereInput
    none?: conference_attendeesWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type EnrollmentsListRelationFilter = {
    every?: enrollmentsWhereInput
    some?: enrollmentsWhereInput
    none?: enrollmentsWhereInput
  }

  export type LogListRelationFilter = {
    every?: LogWhereInput
    some?: LogWhereInput
    none?: LogWhereInput
  }

  export type User_bootcamp_assignmentsListRelationFilter = {
    every?: user_bootcamp_assignmentsWhereInput
    some?: user_bootcamp_assignmentsWhereInput
    none?: user_bootcamp_assignmentsWhereInput
  }

  export type User_training_assignmentsListRelationFilter = {
    every?: user_training_assignmentsWhereInput
    some?: user_training_assignmentsWhereInput
    none?: user_training_assignmentsWhereInput
  }

  export type User_training_progressListRelationFilter = {
    every?: user_training_progressWhereInput
    some?: user_training_progressWhereInput
    none?: user_training_progressWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type admin_permission_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type admin_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bootcamp_progressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conference_attendeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type enrollmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_bootcamp_assignmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_training_assignmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_training_progressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    microsoftId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    microsoftId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    loginType?: SortOrder
    microsoftId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Enumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type Enumlogin_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.login_type | Enumlogin_typeFieldRefInput<$PrismaModel>
    in?: $Enums.login_type[] | ListEnumlogin_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.login_type[] | ListEnumlogin_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumlogin_typeWithAggregatesFilter<$PrismaModel> | $Enums.login_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlogin_typeFilter<$PrismaModel>
    _max?: NestedEnumlogin_typeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    telesetCardNo?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    telesetCardNo?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    telesetCardNo?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    departmentId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    adminLevel?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    adminLevel?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    adminLevel?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LogCountOrderByAggregateInput = {
    id?: SortOrder
    action_type?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    details?: SortOrder
    is_suspicious?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    id?: SortOrder
    action_type?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    is_suspicious?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    id?: SortOrder
    action_type?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    created_at?: SortOrder
    is_suspicious?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type admin_permission_logsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    modified_by?: SortOrder
    action?: SortOrder
    previous_role?: SortOrder
    new_role?: SortOrder
    action_date?: SortOrder
    notes?: SortOrder
  }

  export type admin_permission_logsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    modified_by?: SortOrder
  }

  export type admin_permission_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    modified_by?: SortOrder
    action?: SortOrder
    previous_role?: SortOrder
    new_role?: SortOrder
    action_date?: SortOrder
    notes?: SortOrder
  }

  export type admin_permission_logsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    modified_by?: SortOrder
    action?: SortOrder
    previous_role?: SortOrder
    new_role?: SortOrder
    action_date?: SortOrder
    notes?: SortOrder
  }

  export type admin_permission_logsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    modified_by?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type admin_permissionsUser_idIs_activeCompoundUniqueInput = {
    user_id: number
    is_active: boolean
  }

  export type admin_permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    granted_by?: SortOrder
    permission_level?: SortOrder
    granted_at?: SortOrder
    revoked_at?: SortOrder
    is_active?: SortOrder
  }

  export type admin_permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    granted_by?: SortOrder
  }

  export type admin_permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    granted_by?: SortOrder
    permission_level?: SortOrder
    granted_at?: SortOrder
    revoked_at?: SortOrder
    is_active?: SortOrder
  }

  export type admin_permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    granted_by?: SortOrder
    permission_level?: SortOrder
    granted_at?: SortOrder
    revoked_at?: SortOrder
    is_active?: SortOrder
  }

  export type admin_permissionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    granted_by?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BootcampsScalarRelationFilter = {
    is?: bootcampsWhereInput
    isNot?: bootcampsWhereInput
  }

  export type bootcamp_progressUser_idBootcamp_idCompoundUniqueInput = {
    user_id: number
    bootcamp_id: string
  }

  export type bootcamp_progressCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    current_training_index?: SortOrder
    progress_percentage?: SortOrder
    last_activity?: SortOrder
  }

  export type bootcamp_progressAvgOrderByAggregateInput = {
    user_id?: SortOrder
    current_training_index?: SortOrder
    progress_percentage?: SortOrder
  }

  export type bootcamp_progressMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    current_training_index?: SortOrder
    progress_percentage?: SortOrder
    last_activity?: SortOrder
  }

  export type bootcamp_progressMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    current_training_index?: SortOrder
    progress_percentage?: SortOrder
    last_activity?: SortOrder
  }

  export type bootcamp_progressSumOrderByAggregateInput = {
    user_id?: SortOrder
    current_training_index?: SortOrder
    progress_percentage?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TrainingsScalarRelationFilter = {
    is?: trainingsWhereInput
    isNot?: trainingsWhereInput
  }

  export type bootcamp_trainingsBootcamp_idOrder_indexCompoundUniqueInput = {
    bootcamp_id: string
    order_index: number
  }

  export type bootcamp_trainingsBootcamp_idTraining_idCompoundUniqueInput = {
    bootcamp_id: string
    training_id: string
  }

  export type bootcamp_trainingsCountOrderByAggregateInput = {
    id?: SortOrder
    bootcamp_id?: SortOrder
    training_id?: SortOrder
    order_index?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
  }

  export type bootcamp_trainingsAvgOrderByAggregateInput = {
    order_index?: SortOrder
  }

  export type bootcamp_trainingsMaxOrderByAggregateInput = {
    id?: SortOrder
    bootcamp_id?: SortOrder
    training_id?: SortOrder
    order_index?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
  }

  export type bootcamp_trainingsMinOrderByAggregateInput = {
    id?: SortOrder
    bootcamp_id?: SortOrder
    training_id?: SortOrder
    order_index?: SortOrder
    required?: SortOrder
    created_at?: SortOrder
  }

  export type bootcamp_trainingsSumOrderByAggregateInput = {
    order_index?: SortOrder
  }

  export type Bootcamp_trainingsListRelationFilter = {
    every?: bootcamp_trainingsWhereInput
    some?: bootcamp_trainingsWhereInput
    none?: bootcamp_trainingsWhereInput
  }

  export type bootcamp_trainingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bootcampsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    author?: SortOrder
    published?: SortOrder
    duration?: SortOrder
    deadline?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bootcampsAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type bootcampsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    author?: SortOrder
    published?: SortOrder
    duration?: SortOrder
    deadline?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bootcampsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    author?: SortOrder
    published?: SortOrder
    duration?: SortOrder
    deadline?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type bootcampsSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type Conference_trainingsScalarRelationFilter = {
    is?: conference_trainingsWhereInput
    isNot?: conference_trainingsWhereInput
  }

  export type conference_attendeesConference_idUser_idCompoundUniqueInput = {
    conference_id: string
    user_id: number
  }

  export type conference_attendeesCountOrderByAggregateInput = {
    id?: SortOrder
    conference_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    attended?: SortOrder
    attendance_time?: SortOrder
    notes?: SortOrder
  }

  export type conference_attendeesAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type conference_attendeesMaxOrderByAggregateInput = {
    id?: SortOrder
    conference_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    attended?: SortOrder
    attendance_time?: SortOrder
    notes?: SortOrder
  }

  export type conference_attendeesMinOrderByAggregateInput = {
    id?: SortOrder
    conference_id?: SortOrder
    user_id?: SortOrder
    registered_at?: SortOrder
    attended?: SortOrder
    attendance_time?: SortOrder
    notes?: SortOrder
  }

  export type conference_attendeesSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type conference_materialsCountOrderByAggregateInput = {
    id?: SortOrder
    conference_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_path?: SortOrder
    link?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type conference_materialsMaxOrderByAggregateInput = {
    id?: SortOrder
    conference_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_path?: SortOrder
    link?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type conference_materialsMinOrderByAggregateInput = {
    id?: SortOrder
    conference_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_path?: SortOrder
    link?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Conference_materialsListRelationFilter = {
    every?: conference_materialsWhereInput
    some?: conference_materialsWhereInput
    none?: conference_materialsWhereInput
  }

  export type conference_materialsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type conference_trainingsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    capacity?: SortOrder
    author?: SortOrder
    published?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type conference_trainingsAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type conference_trainingsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    capacity?: SortOrder
    author?: SortOrder
    published?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type conference_trainingsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    location?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    capacity?: SortOrder
    author?: SortOrder
    published?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type conference_trainingsSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type enrollmentsUser_idTraining_idCompoundUniqueInput = {
    user_id: number
    training_id: string
  }

  export type enrollmentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completed_items?: SortOrder
    score?: SortOrder
    start_date?: SortOrder
    completed_at?: SortOrder
    last_accessed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type enrollmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    progress?: SortOrder
    score?: SortOrder
  }

  export type enrollmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    score?: SortOrder
    start_date?: SortOrder
    completed_at?: SortOrder
    last_accessed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type enrollmentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    score?: SortOrder
    start_date?: SortOrder
    completed_at?: SortOrder
    last_accessed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type enrollmentsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    progress?: SortOrder
    score?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type QuizzesScalarRelationFilter = {
    is?: quizzesWhereInput
    isNot?: quizzesWhereInput
  }

  export type questionsQuiz_idOrder_indexCompoundUniqueInput = {
    quiz_id: string
    order_index: number
  }

  export type questionsCountOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    points?: SortOrder
    order_index?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionsAvgOrderByAggregateInput = {
    points?: SortOrder
    order_index?: SortOrder
  }

  export type questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    points?: SortOrder
    order_index?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionsMinOrderByAggregateInput = {
    id?: SortOrder
    quiz_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    points?: SortOrder
    order_index?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type questionsSumOrderByAggregateInput = {
    points?: SortOrder
    order_index?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type QuestionsListRelationFilter = {
    every?: questionsWhereInput
    some?: questionsWhereInput
    none?: questionsWhereInput
  }

  export type TrainingsNullableScalarRelationFilter = {
    is?: trainingsWhereInput | null
    isNot?: trainingsWhereInput | null
  }

  export type questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quizzesCountOrderByAggregateInput = {
    id?: SortOrder
    training_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pass_threshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quizzesAvgOrderByAggregateInput = {
    pass_threshold?: SortOrder
  }

  export type quizzesMaxOrderByAggregateInput = {
    id?: SortOrder
    training_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pass_threshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quizzesMinOrderByAggregateInput = {
    id?: SortOrder
    training_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    pass_threshold?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type quizzesSumOrderByAggregateInput = {
    pass_threshold?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type training_contentTraining_idOrder_indexCompoundUniqueInput = {
    training_id: string
    order_index: number
  }

  export type training_contentCountOrderByAggregateInput = {
    id?: SortOrder
    training_id?: SortOrder
    title?: SortOrder
    content_type?: SortOrder
    content_value?: SortOrder
    order_index?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type training_contentAvgOrderByAggregateInput = {
    order_index?: SortOrder
  }

  export type training_contentMaxOrderByAggregateInput = {
    id?: SortOrder
    training_id?: SortOrder
    title?: SortOrder
    content_type?: SortOrder
    content_value?: SortOrder
    order_index?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type training_contentMinOrderByAggregateInput = {
    id?: SortOrder
    training_id?: SortOrder
    title?: SortOrder
    content_type?: SortOrder
    content_value?: SortOrder
    order_index?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type training_contentSumOrderByAggregateInput = {
    order_index?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type QuizzesListRelationFilter = {
    every?: quizzesWhereInput
    some?: quizzesWhereInput
    none?: quizzesWhereInput
  }

  export type Training_contentListRelationFilter = {
    every?: training_contentWhereInput
    some?: training_contentWhereInput
    none?: training_contentWhereInput
  }

  export type quizzesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type training_contentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type trainingsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    author?: SortOrder
    published?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificateTemplate?: SortOrder
    learning_outcomes?: SortOrder
    deadline?: SortOrder
    is_mandatory?: SortOrder
  }

  export type trainingsAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type trainingsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    author?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificateTemplate?: SortOrder
    deadline?: SortOrder
    is_mandatory?: SortOrder
  }

  export type trainingsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    duration?: SortOrder
    author?: SortOrder
    published?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    certificateTemplate?: SortOrder
    deadline?: SortOrder
    is_mandatory?: SortOrder
  }

  export type trainingsSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type user_bootcamp_assignmentsUser_idBootcamp_idCompoundUniqueInput = {
    user_id: number
    bootcamp_id: string
  }

  export type user_bootcamp_assignmentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    assigned_at?: SortOrder
    completed?: SortOrder
    completion_date?: SortOrder
  }

  export type user_bootcamp_assignmentsAvgOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type user_bootcamp_assignmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    assigned_at?: SortOrder
    completed?: SortOrder
    completion_date?: SortOrder
  }

  export type user_bootcamp_assignmentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    assigned_at?: SortOrder
    completed?: SortOrder
    completion_date?: SortOrder
  }

  export type user_bootcamp_assignmentsSumOrderByAggregateInput = {
    user_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type user_quiz_attemptsUser_idQuiz_idAttempt_numberCompoundUniqueInput = {
    user_id: number
    quiz_id: string
    attempt_number: number
  }

  export type user_quiz_attemptsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quiz_id?: SortOrder
    training_id?: SortOrder
    attempt_number?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    submitted_at?: SortOrder
    answers?: SortOrder
  }

  export type user_quiz_attemptsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    attempt_number?: SortOrder
    score?: SortOrder
  }

  export type user_quiz_attemptsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quiz_id?: SortOrder
    training_id?: SortOrder
    attempt_number?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    submitted_at?: SortOrder
  }

  export type user_quiz_attemptsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    quiz_id?: SortOrder
    training_id?: SortOrder
    attempt_number?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    submitted_at?: SortOrder
  }

  export type user_quiz_attemptsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    attempt_number?: SortOrder
    score?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type user_training_assignmentsUser_idTraining_idCompoundUniqueInput = {
    user_id: number
    training_id: string
  }

  export type user_training_assignmentsCountOrderByAggregateInput = {
    assignment_id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    assigned_at?: SortOrder
  }

  export type user_training_assignmentsAvgOrderByAggregateInput = {
    assignment_id?: SortOrder
    user_id?: SortOrder
  }

  export type user_training_assignmentsMaxOrderByAggregateInput = {
    assignment_id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    assigned_at?: SortOrder
  }

  export type user_training_assignmentsMinOrderByAggregateInput = {
    assignment_id?: SortOrder
    user_id?: SortOrder
    training_id?: SortOrder
    assigned_at?: SortOrder
  }

  export type user_training_assignmentsSumOrderByAggregateInput = {
    assignment_id?: SortOrder
    user_id?: SortOrder
  }

  export type BootcampsNullableScalarRelationFilter = {
    is?: bootcampsWhereInput | null
    isNot?: bootcampsWhereInput | null
  }

  export type user_training_progressUser_idTraining_idCompoundUniqueInput = {
    user_id: number
    training_id: string
  }

  export type user_training_progressCountOrderByAggregateInput = {
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    training_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    progress_percentage?: SortOrder
    completed_content_items?: SortOrder
    completion_duration_seconds?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_training_progressAvgOrderByAggregateInput = {
    user_id?: SortOrder
    progress_percentage?: SortOrder
    completion_duration_seconds?: SortOrder
  }

  export type user_training_progressMaxOrderByAggregateInput = {
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    training_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    progress_percentage?: SortOrder
    completion_duration_seconds?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_training_progressMinOrderByAggregateInput = {
    user_id?: SortOrder
    bootcamp_id?: SortOrder
    training_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
    progress_percentage?: SortOrder
    completion_duration_seconds?: SortOrder
    updatedAt?: SortOrder
  }

  export type user_training_progressSumOrderByAggregateInput = {
    user_id?: SortOrder
    progress_percentage?: SortOrder
    completion_duration_seconds?: SortOrder
  }

  export type admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    create?: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput> | admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput[] | admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    connectOrCreate?: admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    createMany?: admin_permission_logsCreateManyUsers_admin_permission_logs_modified_byTousersInputEnvelope
    connect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
  }

  export type admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput = {
    create?: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput> | admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput[] | admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput[]
    connectOrCreate?: admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput[]
    createMany?: admin_permission_logsCreateManyUsers_admin_permission_logs_user_idTousersInputEnvelope
    connect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
  }

  export type admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput = {
    create?: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput> | admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput[] | admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput[]
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput[]
    createMany?: admin_permissionsCreateManyUsers_admin_permissions_granted_byTousersInputEnvelope
    connect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
  }

  export type admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput = {
    create?: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput> | admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput[] | admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput[]
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput[]
    createMany?: admin_permissionsCreateManyUsers_admin_permissions_user_idTousersInputEnvelope
    connect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
  }

  export type AdminCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type bootcamp_progressCreateNestedManyWithoutUsersInput = {
    create?: XOR<bootcamp_progressCreateWithoutUsersInput, bootcamp_progressUncheckedCreateWithoutUsersInput> | bootcamp_progressCreateWithoutUsersInput[] | bootcamp_progressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bootcamp_progressCreateOrConnectWithoutUsersInput | bootcamp_progressCreateOrConnectWithoutUsersInput[]
    createMany?: bootcamp_progressCreateManyUsersInputEnvelope
    connect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
  }

  export type conference_attendeesCreateNestedManyWithoutUsersInput = {
    create?: XOR<conference_attendeesCreateWithoutUsersInput, conference_attendeesUncheckedCreateWithoutUsersInput> | conference_attendeesCreateWithoutUsersInput[] | conference_attendeesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: conference_attendeesCreateOrConnectWithoutUsersInput | conference_attendeesCreateOrConnectWithoutUsersInput[]
    createMany?: conference_attendeesCreateManyUsersInputEnvelope
    connect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type enrollmentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput> | enrollmentsCreateWithoutUsersInput[] | enrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutUsersInput | enrollmentsCreateOrConnectWithoutUsersInput[]
    createMany?: enrollmentsCreateManyUsersInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type LogCreateNestedManyWithoutUsersInput = {
    create?: XOR<LogCreateWithoutUsersInput, LogUncheckedCreateWithoutUsersInput> | LogCreateWithoutUsersInput[] | LogUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUsersInput | LogCreateOrConnectWithoutUsersInput[]
    createMany?: LogCreateManyUsersInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_bootcamp_assignmentsCreateWithoutUsersInput, user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput> | user_bootcamp_assignmentsCreateWithoutUsersInput[] | user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput | user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput[]
    createMany?: user_bootcamp_assignmentsCreateManyUsersInputEnvelope
    connect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
  }

  export type user_training_assignmentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_training_assignmentsCreateWithoutUsersInput, user_training_assignmentsUncheckedCreateWithoutUsersInput> | user_training_assignmentsCreateWithoutUsersInput[] | user_training_assignmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_training_assignmentsCreateOrConnectWithoutUsersInput | user_training_assignmentsCreateOrConnectWithoutUsersInput[]
    createMany?: user_training_assignmentsCreateManyUsersInputEnvelope
    connect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
  }

  export type user_training_progressCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_training_progressCreateWithoutUsersInput, user_training_progressUncheckedCreateWithoutUsersInput> | user_training_progressCreateWithoutUsersInput[] | user_training_progressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutUsersInput | user_training_progressCreateOrConnectWithoutUsersInput[]
    createMany?: user_training_progressCreateManyUsersInputEnvelope
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
  }

  export type admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    create?: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput> | admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput[] | admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    connectOrCreate?: admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    createMany?: admin_permission_logsCreateManyUsers_admin_permission_logs_modified_byTousersInputEnvelope
    connect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
  }

  export type admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput = {
    create?: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput> | admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput[] | admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput[]
    connectOrCreate?: admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput[]
    createMany?: admin_permission_logsCreateManyUsers_admin_permission_logs_user_idTousersInputEnvelope
    connect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
  }

  export type admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput = {
    create?: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput> | admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput[] | admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput[]
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput[]
    createMany?: admin_permissionsCreateManyUsers_admin_permissions_granted_byTousersInputEnvelope
    connect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
  }

  export type admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput = {
    create?: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput> | admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput[] | admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput[]
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput[]
    createMany?: admin_permissionsCreateManyUsers_admin_permissions_user_idTousersInputEnvelope
    connect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<bootcamp_progressCreateWithoutUsersInput, bootcamp_progressUncheckedCreateWithoutUsersInput> | bootcamp_progressCreateWithoutUsersInput[] | bootcamp_progressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bootcamp_progressCreateOrConnectWithoutUsersInput | bootcamp_progressCreateOrConnectWithoutUsersInput[]
    createMany?: bootcamp_progressCreateManyUsersInputEnvelope
    connect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
  }

  export type conference_attendeesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<conference_attendeesCreateWithoutUsersInput, conference_attendeesUncheckedCreateWithoutUsersInput> | conference_attendeesCreateWithoutUsersInput[] | conference_attendeesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: conference_attendeesCreateOrConnectWithoutUsersInput | conference_attendeesCreateOrConnectWithoutUsersInput[]
    createMany?: conference_attendeesCreateManyUsersInputEnvelope
    connect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type enrollmentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput> | enrollmentsCreateWithoutUsersInput[] | enrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutUsersInput | enrollmentsCreateOrConnectWithoutUsersInput[]
    createMany?: enrollmentsCreateManyUsersInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type LogUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<LogCreateWithoutUsersInput, LogUncheckedCreateWithoutUsersInput> | LogCreateWithoutUsersInput[] | LogUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUsersInput | LogCreateOrConnectWithoutUsersInput[]
    createMany?: LogCreateManyUsersInputEnvelope
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
  }

  export type user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_bootcamp_assignmentsCreateWithoutUsersInput, user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput> | user_bootcamp_assignmentsCreateWithoutUsersInput[] | user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput | user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput[]
    createMany?: user_bootcamp_assignmentsCreateManyUsersInputEnvelope
    connect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
  }

  export type user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_training_assignmentsCreateWithoutUsersInput, user_training_assignmentsUncheckedCreateWithoutUsersInput> | user_training_assignmentsCreateWithoutUsersInput[] | user_training_assignmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_training_assignmentsCreateOrConnectWithoutUsersInput | user_training_assignmentsCreateOrConnectWithoutUsersInput[]
    createMany?: user_training_assignmentsCreateManyUsersInputEnvelope
    connect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
  }

  export type user_training_progressUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_training_progressCreateWithoutUsersInput, user_training_progressUncheckedCreateWithoutUsersInput> | user_training_progressCreateWithoutUsersInput[] | user_training_progressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutUsersInput | user_training_progressCreateOrConnectWithoutUsersInput[]
    createMany?: user_training_progressCreateManyUsersInputEnvelope
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type Enumuser_roleFieldUpdateOperationsInput = {
    set?: $Enums.user_role
  }

  export type Enumlogin_typeFieldUpdateOperationsInput = {
    set?: $Enums.login_type
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput = {
    create?: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput> | admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput[] | admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    connectOrCreate?: admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    upsert?: admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    createMany?: admin_permission_logsCreateManyUsers_admin_permission_logs_modified_byTousersInputEnvelope
    set?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    disconnect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    delete?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    connect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    update?: admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    updateMany?: admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    deleteMany?: admin_permission_logsScalarWhereInput | admin_permission_logsScalarWhereInput[]
  }

  export type admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput = {
    create?: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput> | admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput[] | admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput[]
    connectOrCreate?: admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput[]
    upsert?: admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput[]
    createMany?: admin_permission_logsCreateManyUsers_admin_permission_logs_user_idTousersInputEnvelope
    set?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    disconnect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    delete?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    connect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    update?: admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput[]
    updateMany?: admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_user_idTousersInput[]
    deleteMany?: admin_permission_logsScalarWhereInput | admin_permission_logsScalarWhereInput[]
  }

  export type admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput = {
    create?: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput> | admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput[] | admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput[]
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput[]
    upsert?: admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput[]
    createMany?: admin_permissionsCreateManyUsers_admin_permissions_granted_byTousersInputEnvelope
    set?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    disconnect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    delete?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    connect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    update?: admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput[]
    updateMany?: admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_granted_byTousersInput[]
    deleteMany?: admin_permissionsScalarWhereInput | admin_permissionsScalarWhereInput[]
  }

  export type admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput = {
    create?: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput> | admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput[] | admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput[]
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput[]
    upsert?: admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput[]
    createMany?: admin_permissionsCreateManyUsers_admin_permissions_user_idTousersInputEnvelope
    set?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    disconnect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    delete?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    connect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    update?: admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput[]
    updateMany?: admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_user_idTousersInput[]
    deleteMany?: admin_permissionsScalarWhereInput | admin_permissionsScalarWhereInput[]
  }

  export type AdminUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutUserInput | AdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutUserInput | AdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutUserInput | AdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type bootcamp_progressUpdateManyWithoutUsersNestedInput = {
    create?: XOR<bootcamp_progressCreateWithoutUsersInput, bootcamp_progressUncheckedCreateWithoutUsersInput> | bootcamp_progressCreateWithoutUsersInput[] | bootcamp_progressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bootcamp_progressCreateOrConnectWithoutUsersInput | bootcamp_progressCreateOrConnectWithoutUsersInput[]
    upsert?: bootcamp_progressUpsertWithWhereUniqueWithoutUsersInput | bootcamp_progressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: bootcamp_progressCreateManyUsersInputEnvelope
    set?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    disconnect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    delete?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    connect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    update?: bootcamp_progressUpdateWithWhereUniqueWithoutUsersInput | bootcamp_progressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: bootcamp_progressUpdateManyWithWhereWithoutUsersInput | bootcamp_progressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: bootcamp_progressScalarWhereInput | bootcamp_progressScalarWhereInput[]
  }

  export type conference_attendeesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<conference_attendeesCreateWithoutUsersInput, conference_attendeesUncheckedCreateWithoutUsersInput> | conference_attendeesCreateWithoutUsersInput[] | conference_attendeesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: conference_attendeesCreateOrConnectWithoutUsersInput | conference_attendeesCreateOrConnectWithoutUsersInput[]
    upsert?: conference_attendeesUpsertWithWhereUniqueWithoutUsersInput | conference_attendeesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: conference_attendeesCreateManyUsersInputEnvelope
    set?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    disconnect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    delete?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    connect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    update?: conference_attendeesUpdateWithWhereUniqueWithoutUsersInput | conference_attendeesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: conference_attendeesUpdateManyWithWhereWithoutUsersInput | conference_attendeesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: conference_attendeesScalarWhereInput | conference_attendeesScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutUserInput | EmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutUserInput | EmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutUserInput | EmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type enrollmentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput> | enrollmentsCreateWithoutUsersInput[] | enrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutUsersInput | enrollmentsCreateOrConnectWithoutUsersInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutUsersInput | enrollmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: enrollmentsCreateManyUsersInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutUsersInput | enrollmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutUsersInput | enrollmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type LogUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LogCreateWithoutUsersInput, LogUncheckedCreateWithoutUsersInput> | LogCreateWithoutUsersInput[] | LogUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUsersInput | LogCreateOrConnectWithoutUsersInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUsersInput | LogUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: LogCreateManyUsersInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUsersInput | LogUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUsersInput | LogUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_bootcamp_assignmentsCreateWithoutUsersInput, user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput> | user_bootcamp_assignmentsCreateWithoutUsersInput[] | user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput | user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput[]
    upsert?: user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutUsersInput | user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_bootcamp_assignmentsCreateManyUsersInputEnvelope
    set?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    disconnect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    delete?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    connect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    update?: user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutUsersInput | user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_bootcamp_assignmentsUpdateManyWithWhereWithoutUsersInput | user_bootcamp_assignmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_bootcamp_assignmentsScalarWhereInput | user_bootcamp_assignmentsScalarWhereInput[]
  }

  export type user_training_assignmentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_training_assignmentsCreateWithoutUsersInput, user_training_assignmentsUncheckedCreateWithoutUsersInput> | user_training_assignmentsCreateWithoutUsersInput[] | user_training_assignmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_training_assignmentsCreateOrConnectWithoutUsersInput | user_training_assignmentsCreateOrConnectWithoutUsersInput[]
    upsert?: user_training_assignmentsUpsertWithWhereUniqueWithoutUsersInput | user_training_assignmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_training_assignmentsCreateManyUsersInputEnvelope
    set?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    disconnect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    delete?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    connect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    update?: user_training_assignmentsUpdateWithWhereUniqueWithoutUsersInput | user_training_assignmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_training_assignmentsUpdateManyWithWhereWithoutUsersInput | user_training_assignmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_training_assignmentsScalarWhereInput | user_training_assignmentsScalarWhereInput[]
  }

  export type user_training_progressUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_training_progressCreateWithoutUsersInput, user_training_progressUncheckedCreateWithoutUsersInput> | user_training_progressCreateWithoutUsersInput[] | user_training_progressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutUsersInput | user_training_progressCreateOrConnectWithoutUsersInput[]
    upsert?: user_training_progressUpsertWithWhereUniqueWithoutUsersInput | user_training_progressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_training_progressCreateManyUsersInputEnvelope
    set?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    disconnect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    delete?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    update?: user_training_progressUpdateWithWhereUniqueWithoutUsersInput | user_training_progressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_training_progressUpdateManyWithWhereWithoutUsersInput | user_training_progressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_training_progressScalarWhereInput | user_training_progressScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput = {
    create?: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput> | admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput[] | admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    connectOrCreate?: admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    upsert?: admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    createMany?: admin_permission_logsCreateManyUsers_admin_permission_logs_modified_byTousersInputEnvelope
    set?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    disconnect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    delete?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    connect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    update?: admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    updateMany?: admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_modified_byTousersInput[]
    deleteMany?: admin_permission_logsScalarWhereInput | admin_permission_logsScalarWhereInput[]
  }

  export type admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput = {
    create?: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput> | admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput[] | admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput[]
    connectOrCreate?: admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput[]
    upsert?: admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput[]
    createMany?: admin_permission_logsCreateManyUsers_admin_permission_logs_user_idTousersInputEnvelope
    set?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    disconnect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    delete?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    connect?: admin_permission_logsWhereUniqueInput | admin_permission_logsWhereUniqueInput[]
    update?: admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput[]
    updateMany?: admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_user_idTousersInput[]
    deleteMany?: admin_permission_logsScalarWhereInput | admin_permission_logsScalarWhereInput[]
  }

  export type admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput = {
    create?: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput> | admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput[] | admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput[]
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput[]
    upsert?: admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput[]
    createMany?: admin_permissionsCreateManyUsers_admin_permissions_granted_byTousersInputEnvelope
    set?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    disconnect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    delete?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    connect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    update?: admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput[]
    updateMany?: admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_granted_byTousersInput | admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_granted_byTousersInput[]
    deleteMany?: admin_permissionsScalarWhereInput | admin_permissionsScalarWhereInput[]
  }

  export type admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput = {
    create?: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput> | admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput[] | admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput[]
    connectOrCreate?: admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput[]
    upsert?: admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput[]
    createMany?: admin_permissionsCreateManyUsers_admin_permissions_user_idTousersInputEnvelope
    set?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    disconnect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    delete?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    connect?: admin_permissionsWhereUniqueInput | admin_permissionsWhereUniqueInput[]
    update?: admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput[]
    updateMany?: admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_user_idTousersInput | admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_user_idTousersInput[]
    deleteMany?: admin_permissionsScalarWhereInput | admin_permissionsScalarWhereInput[]
  }

  export type AdminUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput> | AdminCreateWithoutUserInput[] | AdminUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput | AdminCreateOrConnectWithoutUserInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutUserInput | AdminUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdminCreateManyUserInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutUserInput | AdminUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutUserInput | AdminUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<bootcamp_progressCreateWithoutUsersInput, bootcamp_progressUncheckedCreateWithoutUsersInput> | bootcamp_progressCreateWithoutUsersInput[] | bootcamp_progressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: bootcamp_progressCreateOrConnectWithoutUsersInput | bootcamp_progressCreateOrConnectWithoutUsersInput[]
    upsert?: bootcamp_progressUpsertWithWhereUniqueWithoutUsersInput | bootcamp_progressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: bootcamp_progressCreateManyUsersInputEnvelope
    set?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    disconnect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    delete?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    connect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    update?: bootcamp_progressUpdateWithWhereUniqueWithoutUsersInput | bootcamp_progressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: bootcamp_progressUpdateManyWithWhereWithoutUsersInput | bootcamp_progressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: bootcamp_progressScalarWhereInput | bootcamp_progressScalarWhereInput[]
  }

  export type conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<conference_attendeesCreateWithoutUsersInput, conference_attendeesUncheckedCreateWithoutUsersInput> | conference_attendeesCreateWithoutUsersInput[] | conference_attendeesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: conference_attendeesCreateOrConnectWithoutUsersInput | conference_attendeesCreateOrConnectWithoutUsersInput[]
    upsert?: conference_attendeesUpsertWithWhereUniqueWithoutUsersInput | conference_attendeesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: conference_attendeesCreateManyUsersInputEnvelope
    set?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    disconnect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    delete?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    connect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    update?: conference_attendeesUpdateWithWhereUniqueWithoutUsersInput | conference_attendeesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: conference_attendeesUpdateManyWithWhereWithoutUsersInput | conference_attendeesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: conference_attendeesScalarWhereInput | conference_attendeesScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutUserInput | EmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutUserInput | EmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutUserInput | EmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type enrollmentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput> | enrollmentsCreateWithoutUsersInput[] | enrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutUsersInput | enrollmentsCreateOrConnectWithoutUsersInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutUsersInput | enrollmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: enrollmentsCreateManyUsersInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutUsersInput | enrollmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutUsersInput | enrollmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type LogUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<LogCreateWithoutUsersInput, LogUncheckedCreateWithoutUsersInput> | LogCreateWithoutUsersInput[] | LogUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: LogCreateOrConnectWithoutUsersInput | LogCreateOrConnectWithoutUsersInput[]
    upsert?: LogUpsertWithWhereUniqueWithoutUsersInput | LogUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: LogCreateManyUsersInputEnvelope
    set?: LogWhereUniqueInput | LogWhereUniqueInput[]
    disconnect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    delete?: LogWhereUniqueInput | LogWhereUniqueInput[]
    connect?: LogWhereUniqueInput | LogWhereUniqueInput[]
    update?: LogUpdateWithWhereUniqueWithoutUsersInput | LogUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: LogUpdateManyWithWhereWithoutUsersInput | LogUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: LogScalarWhereInput | LogScalarWhereInput[]
  }

  export type user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_bootcamp_assignmentsCreateWithoutUsersInput, user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput> | user_bootcamp_assignmentsCreateWithoutUsersInput[] | user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput | user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput[]
    upsert?: user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutUsersInput | user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_bootcamp_assignmentsCreateManyUsersInputEnvelope
    set?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    disconnect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    delete?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    connect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    update?: user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutUsersInput | user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_bootcamp_assignmentsUpdateManyWithWhereWithoutUsersInput | user_bootcamp_assignmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_bootcamp_assignmentsScalarWhereInput | user_bootcamp_assignmentsScalarWhereInput[]
  }

  export type user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_training_assignmentsCreateWithoutUsersInput, user_training_assignmentsUncheckedCreateWithoutUsersInput> | user_training_assignmentsCreateWithoutUsersInput[] | user_training_assignmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_training_assignmentsCreateOrConnectWithoutUsersInput | user_training_assignmentsCreateOrConnectWithoutUsersInput[]
    upsert?: user_training_assignmentsUpsertWithWhereUniqueWithoutUsersInput | user_training_assignmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_training_assignmentsCreateManyUsersInputEnvelope
    set?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    disconnect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    delete?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    connect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    update?: user_training_assignmentsUpdateWithWhereUniqueWithoutUsersInput | user_training_assignmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_training_assignmentsUpdateManyWithWhereWithoutUsersInput | user_training_assignmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_training_assignmentsScalarWhereInput | user_training_assignmentsScalarWhereInput[]
  }

  export type user_training_progressUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_training_progressCreateWithoutUsersInput, user_training_progressUncheckedCreateWithoutUsersInput> | user_training_progressCreateWithoutUsersInput[] | user_training_progressUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutUsersInput | user_training_progressCreateOrConnectWithoutUsersInput[]
    upsert?: user_training_progressUpsertWithWhereUniqueWithoutUsersInput | user_training_progressUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_training_progressCreateManyUsersInputEnvelope
    set?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    disconnect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    delete?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    update?: user_training_progressUpdateWithWhereUniqueWithoutUsersInput | user_training_progressUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_training_progressUpdateManyWithWhereWithoutUsersInput | user_training_progressUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_training_progressScalarWhereInput | user_training_progressScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: DepartmentUpsertWithoutEmployeesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEmployeesInput, DepartmentUpdateWithoutEmployeesInput>, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLogsInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLogsInput
    upsert?: UserUpsertWithoutLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLogsInput, UserUpdateWithoutLogsInput>, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserCreateNestedOneWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput = {
    create?: XOR<UserCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput, UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput = {
    create?: XOR<UserCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput, UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersNestedInput = {
    create?: XOR<UserCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput, UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput
    upsert?: UserUpsertWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput, UserUpdateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput>, UserUncheckedUpdateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput>
  }

  export type UserUpdateOneRequiredWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersNestedInput = {
    create?: XOR<UserCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput, UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput
    upsert?: UserUpsertWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput, UserUpdateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput>, UserUncheckedUpdateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput>
  }

  export type UserCreateNestedOneWithoutAdmin_permissions_admin_permissions_granted_byTousersInput = {
    create?: XOR<UserCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput, UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_permissions_admin_permissions_granted_byTousersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAdmin_permissions_admin_permissions_user_idTousersInput = {
    create?: XOR<UserCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput, UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_permissions_admin_permissions_user_idTousersInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutAdmin_permissions_admin_permissions_granted_byTousersNestedInput = {
    create?: XOR<UserCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput, UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_permissions_admin_permissions_granted_byTousersInput
    upsert?: UserUpsertWithoutAdmin_permissions_admin_permissions_granted_byTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdmin_permissions_admin_permissions_granted_byTousersInput, UserUpdateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput>, UserUncheckedUpdateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput>
  }

  export type UserUpdateOneRequiredWithoutAdmin_permissions_admin_permissions_user_idTousersNestedInput = {
    create?: XOR<UserCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput, UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdmin_permissions_admin_permissions_user_idTousersInput
    upsert?: UserUpsertWithoutAdmin_permissions_admin_permissions_user_idTousersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdmin_permissions_admin_permissions_user_idTousersInput, UserUpdateWithoutAdmin_permissions_admin_permissions_user_idTousersInput>, UserUncheckedUpdateWithoutAdmin_permissions_admin_permissions_user_idTousersInput>
  }

  export type bootcampsCreateNestedOneWithoutBootcamp_progressInput = {
    create?: XOR<bootcampsCreateWithoutBootcamp_progressInput, bootcampsUncheckedCreateWithoutBootcamp_progressInput>
    connectOrCreate?: bootcampsCreateOrConnectWithoutBootcamp_progressInput
    connect?: bootcampsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBootcamp_progressInput = {
    create?: XOR<UserCreateWithoutBootcamp_progressInput, UserUncheckedCreateWithoutBootcamp_progressInput>
    connectOrCreate?: UserCreateOrConnectWithoutBootcamp_progressInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type bootcampsUpdateOneRequiredWithoutBootcamp_progressNestedInput = {
    create?: XOR<bootcampsCreateWithoutBootcamp_progressInput, bootcampsUncheckedCreateWithoutBootcamp_progressInput>
    connectOrCreate?: bootcampsCreateOrConnectWithoutBootcamp_progressInput
    upsert?: bootcampsUpsertWithoutBootcamp_progressInput
    connect?: bootcampsWhereUniqueInput
    update?: XOR<XOR<bootcampsUpdateToOneWithWhereWithoutBootcamp_progressInput, bootcampsUpdateWithoutBootcamp_progressInput>, bootcampsUncheckedUpdateWithoutBootcamp_progressInput>
  }

  export type UserUpdateOneRequiredWithoutBootcamp_progressNestedInput = {
    create?: XOR<UserCreateWithoutBootcamp_progressInput, UserUncheckedCreateWithoutBootcamp_progressInput>
    connectOrCreate?: UserCreateOrConnectWithoutBootcamp_progressInput
    upsert?: UserUpsertWithoutBootcamp_progressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBootcamp_progressInput, UserUpdateWithoutBootcamp_progressInput>, UserUncheckedUpdateWithoutBootcamp_progressInput>
  }

  export type bootcampsCreateNestedOneWithoutBootcamp_trainingsInput = {
    create?: XOR<bootcampsCreateWithoutBootcamp_trainingsInput, bootcampsUncheckedCreateWithoutBootcamp_trainingsInput>
    connectOrCreate?: bootcampsCreateOrConnectWithoutBootcamp_trainingsInput
    connect?: bootcampsWhereUniqueInput
  }

  export type trainingsCreateNestedOneWithoutBootcamp_trainingsInput = {
    create?: XOR<trainingsCreateWithoutBootcamp_trainingsInput, trainingsUncheckedCreateWithoutBootcamp_trainingsInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutBootcamp_trainingsInput
    connect?: trainingsWhereUniqueInput
  }

  export type bootcampsUpdateOneRequiredWithoutBootcamp_trainingsNestedInput = {
    create?: XOR<bootcampsCreateWithoutBootcamp_trainingsInput, bootcampsUncheckedCreateWithoutBootcamp_trainingsInput>
    connectOrCreate?: bootcampsCreateOrConnectWithoutBootcamp_trainingsInput
    upsert?: bootcampsUpsertWithoutBootcamp_trainingsInput
    connect?: bootcampsWhereUniqueInput
    update?: XOR<XOR<bootcampsUpdateToOneWithWhereWithoutBootcamp_trainingsInput, bootcampsUpdateWithoutBootcamp_trainingsInput>, bootcampsUncheckedUpdateWithoutBootcamp_trainingsInput>
  }

  export type trainingsUpdateOneRequiredWithoutBootcamp_trainingsNestedInput = {
    create?: XOR<trainingsCreateWithoutBootcamp_trainingsInput, trainingsUncheckedCreateWithoutBootcamp_trainingsInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutBootcamp_trainingsInput
    upsert?: trainingsUpsertWithoutBootcamp_trainingsInput
    connect?: trainingsWhereUniqueInput
    update?: XOR<XOR<trainingsUpdateToOneWithWhereWithoutBootcamp_trainingsInput, trainingsUpdateWithoutBootcamp_trainingsInput>, trainingsUncheckedUpdateWithoutBootcamp_trainingsInput>
  }

  export type bootcamp_progressCreateNestedManyWithoutBootcampsInput = {
    create?: XOR<bootcamp_progressCreateWithoutBootcampsInput, bootcamp_progressUncheckedCreateWithoutBootcampsInput> | bootcamp_progressCreateWithoutBootcampsInput[] | bootcamp_progressUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: bootcamp_progressCreateOrConnectWithoutBootcampsInput | bootcamp_progressCreateOrConnectWithoutBootcampsInput[]
    createMany?: bootcamp_progressCreateManyBootcampsInputEnvelope
    connect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
  }

  export type bootcamp_trainingsCreateNestedManyWithoutBootcampsInput = {
    create?: XOR<bootcamp_trainingsCreateWithoutBootcampsInput, bootcamp_trainingsUncheckedCreateWithoutBootcampsInput> | bootcamp_trainingsCreateWithoutBootcampsInput[] | bootcamp_trainingsUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: bootcamp_trainingsCreateOrConnectWithoutBootcampsInput | bootcamp_trainingsCreateOrConnectWithoutBootcampsInput[]
    createMany?: bootcamp_trainingsCreateManyBootcampsInputEnvelope
    connect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
  }

  export type user_bootcamp_assignmentsCreateNestedManyWithoutBootcampsInput = {
    create?: XOR<user_bootcamp_assignmentsCreateWithoutBootcampsInput, user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput> | user_bootcamp_assignmentsCreateWithoutBootcampsInput[] | user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput | user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput[]
    createMany?: user_bootcamp_assignmentsCreateManyBootcampsInputEnvelope
    connect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
  }

  export type user_training_progressCreateNestedManyWithoutBootcampsInput = {
    create?: XOR<user_training_progressCreateWithoutBootcampsInput, user_training_progressUncheckedCreateWithoutBootcampsInput> | user_training_progressCreateWithoutBootcampsInput[] | user_training_progressUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutBootcampsInput | user_training_progressCreateOrConnectWithoutBootcampsInput[]
    createMany?: user_training_progressCreateManyBootcampsInputEnvelope
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
  }

  export type bootcamp_progressUncheckedCreateNestedManyWithoutBootcampsInput = {
    create?: XOR<bootcamp_progressCreateWithoutBootcampsInput, bootcamp_progressUncheckedCreateWithoutBootcampsInput> | bootcamp_progressCreateWithoutBootcampsInput[] | bootcamp_progressUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: bootcamp_progressCreateOrConnectWithoutBootcampsInput | bootcamp_progressCreateOrConnectWithoutBootcampsInput[]
    createMany?: bootcamp_progressCreateManyBootcampsInputEnvelope
    connect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
  }

  export type bootcamp_trainingsUncheckedCreateNestedManyWithoutBootcampsInput = {
    create?: XOR<bootcamp_trainingsCreateWithoutBootcampsInput, bootcamp_trainingsUncheckedCreateWithoutBootcampsInput> | bootcamp_trainingsCreateWithoutBootcampsInput[] | bootcamp_trainingsUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: bootcamp_trainingsCreateOrConnectWithoutBootcampsInput | bootcamp_trainingsCreateOrConnectWithoutBootcampsInput[]
    createMany?: bootcamp_trainingsCreateManyBootcampsInputEnvelope
    connect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
  }

  export type user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutBootcampsInput = {
    create?: XOR<user_bootcamp_assignmentsCreateWithoutBootcampsInput, user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput> | user_bootcamp_assignmentsCreateWithoutBootcampsInput[] | user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput | user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput[]
    createMany?: user_bootcamp_assignmentsCreateManyBootcampsInputEnvelope
    connect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
  }

  export type user_training_progressUncheckedCreateNestedManyWithoutBootcampsInput = {
    create?: XOR<user_training_progressCreateWithoutBootcampsInput, user_training_progressUncheckedCreateWithoutBootcampsInput> | user_training_progressCreateWithoutBootcampsInput[] | user_training_progressUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutBootcampsInput | user_training_progressCreateOrConnectWithoutBootcampsInput[]
    createMany?: user_training_progressCreateManyBootcampsInputEnvelope
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
  }

  export type bootcamp_progressUpdateManyWithoutBootcampsNestedInput = {
    create?: XOR<bootcamp_progressCreateWithoutBootcampsInput, bootcamp_progressUncheckedCreateWithoutBootcampsInput> | bootcamp_progressCreateWithoutBootcampsInput[] | bootcamp_progressUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: bootcamp_progressCreateOrConnectWithoutBootcampsInput | bootcamp_progressCreateOrConnectWithoutBootcampsInput[]
    upsert?: bootcamp_progressUpsertWithWhereUniqueWithoutBootcampsInput | bootcamp_progressUpsertWithWhereUniqueWithoutBootcampsInput[]
    createMany?: bootcamp_progressCreateManyBootcampsInputEnvelope
    set?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    disconnect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    delete?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    connect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    update?: bootcamp_progressUpdateWithWhereUniqueWithoutBootcampsInput | bootcamp_progressUpdateWithWhereUniqueWithoutBootcampsInput[]
    updateMany?: bootcamp_progressUpdateManyWithWhereWithoutBootcampsInput | bootcamp_progressUpdateManyWithWhereWithoutBootcampsInput[]
    deleteMany?: bootcamp_progressScalarWhereInput | bootcamp_progressScalarWhereInput[]
  }

  export type bootcamp_trainingsUpdateManyWithoutBootcampsNestedInput = {
    create?: XOR<bootcamp_trainingsCreateWithoutBootcampsInput, bootcamp_trainingsUncheckedCreateWithoutBootcampsInput> | bootcamp_trainingsCreateWithoutBootcampsInput[] | bootcamp_trainingsUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: bootcamp_trainingsCreateOrConnectWithoutBootcampsInput | bootcamp_trainingsCreateOrConnectWithoutBootcampsInput[]
    upsert?: bootcamp_trainingsUpsertWithWhereUniqueWithoutBootcampsInput | bootcamp_trainingsUpsertWithWhereUniqueWithoutBootcampsInput[]
    createMany?: bootcamp_trainingsCreateManyBootcampsInputEnvelope
    set?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    disconnect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    delete?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    connect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    update?: bootcamp_trainingsUpdateWithWhereUniqueWithoutBootcampsInput | bootcamp_trainingsUpdateWithWhereUniqueWithoutBootcampsInput[]
    updateMany?: bootcamp_trainingsUpdateManyWithWhereWithoutBootcampsInput | bootcamp_trainingsUpdateManyWithWhereWithoutBootcampsInput[]
    deleteMany?: bootcamp_trainingsScalarWhereInput | bootcamp_trainingsScalarWhereInput[]
  }

  export type user_bootcamp_assignmentsUpdateManyWithoutBootcampsNestedInput = {
    create?: XOR<user_bootcamp_assignmentsCreateWithoutBootcampsInput, user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput> | user_bootcamp_assignmentsCreateWithoutBootcampsInput[] | user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput | user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput[]
    upsert?: user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutBootcampsInput | user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutBootcampsInput[]
    createMany?: user_bootcamp_assignmentsCreateManyBootcampsInputEnvelope
    set?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    disconnect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    delete?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    connect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    update?: user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutBootcampsInput | user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutBootcampsInput[]
    updateMany?: user_bootcamp_assignmentsUpdateManyWithWhereWithoutBootcampsInput | user_bootcamp_assignmentsUpdateManyWithWhereWithoutBootcampsInput[]
    deleteMany?: user_bootcamp_assignmentsScalarWhereInput | user_bootcamp_assignmentsScalarWhereInput[]
  }

  export type user_training_progressUpdateManyWithoutBootcampsNestedInput = {
    create?: XOR<user_training_progressCreateWithoutBootcampsInput, user_training_progressUncheckedCreateWithoutBootcampsInput> | user_training_progressCreateWithoutBootcampsInput[] | user_training_progressUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutBootcampsInput | user_training_progressCreateOrConnectWithoutBootcampsInput[]
    upsert?: user_training_progressUpsertWithWhereUniqueWithoutBootcampsInput | user_training_progressUpsertWithWhereUniqueWithoutBootcampsInput[]
    createMany?: user_training_progressCreateManyBootcampsInputEnvelope
    set?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    disconnect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    delete?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    update?: user_training_progressUpdateWithWhereUniqueWithoutBootcampsInput | user_training_progressUpdateWithWhereUniqueWithoutBootcampsInput[]
    updateMany?: user_training_progressUpdateManyWithWhereWithoutBootcampsInput | user_training_progressUpdateManyWithWhereWithoutBootcampsInput[]
    deleteMany?: user_training_progressScalarWhereInput | user_training_progressScalarWhereInput[]
  }

  export type bootcamp_progressUncheckedUpdateManyWithoutBootcampsNestedInput = {
    create?: XOR<bootcamp_progressCreateWithoutBootcampsInput, bootcamp_progressUncheckedCreateWithoutBootcampsInput> | bootcamp_progressCreateWithoutBootcampsInput[] | bootcamp_progressUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: bootcamp_progressCreateOrConnectWithoutBootcampsInput | bootcamp_progressCreateOrConnectWithoutBootcampsInput[]
    upsert?: bootcamp_progressUpsertWithWhereUniqueWithoutBootcampsInput | bootcamp_progressUpsertWithWhereUniqueWithoutBootcampsInput[]
    createMany?: bootcamp_progressCreateManyBootcampsInputEnvelope
    set?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    disconnect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    delete?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    connect?: bootcamp_progressWhereUniqueInput | bootcamp_progressWhereUniqueInput[]
    update?: bootcamp_progressUpdateWithWhereUniqueWithoutBootcampsInput | bootcamp_progressUpdateWithWhereUniqueWithoutBootcampsInput[]
    updateMany?: bootcamp_progressUpdateManyWithWhereWithoutBootcampsInput | bootcamp_progressUpdateManyWithWhereWithoutBootcampsInput[]
    deleteMany?: bootcamp_progressScalarWhereInput | bootcamp_progressScalarWhereInput[]
  }

  export type bootcamp_trainingsUncheckedUpdateManyWithoutBootcampsNestedInput = {
    create?: XOR<bootcamp_trainingsCreateWithoutBootcampsInput, bootcamp_trainingsUncheckedCreateWithoutBootcampsInput> | bootcamp_trainingsCreateWithoutBootcampsInput[] | bootcamp_trainingsUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: bootcamp_trainingsCreateOrConnectWithoutBootcampsInput | bootcamp_trainingsCreateOrConnectWithoutBootcampsInput[]
    upsert?: bootcamp_trainingsUpsertWithWhereUniqueWithoutBootcampsInput | bootcamp_trainingsUpsertWithWhereUniqueWithoutBootcampsInput[]
    createMany?: bootcamp_trainingsCreateManyBootcampsInputEnvelope
    set?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    disconnect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    delete?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    connect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    update?: bootcamp_trainingsUpdateWithWhereUniqueWithoutBootcampsInput | bootcamp_trainingsUpdateWithWhereUniqueWithoutBootcampsInput[]
    updateMany?: bootcamp_trainingsUpdateManyWithWhereWithoutBootcampsInput | bootcamp_trainingsUpdateManyWithWhereWithoutBootcampsInput[]
    deleteMany?: bootcamp_trainingsScalarWhereInput | bootcamp_trainingsScalarWhereInput[]
  }

  export type user_bootcamp_assignmentsUncheckedUpdateManyWithoutBootcampsNestedInput = {
    create?: XOR<user_bootcamp_assignmentsCreateWithoutBootcampsInput, user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput> | user_bootcamp_assignmentsCreateWithoutBootcampsInput[] | user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput | user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput[]
    upsert?: user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutBootcampsInput | user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutBootcampsInput[]
    createMany?: user_bootcamp_assignmentsCreateManyBootcampsInputEnvelope
    set?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    disconnect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    delete?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    connect?: user_bootcamp_assignmentsWhereUniqueInput | user_bootcamp_assignmentsWhereUniqueInput[]
    update?: user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutBootcampsInput | user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutBootcampsInput[]
    updateMany?: user_bootcamp_assignmentsUpdateManyWithWhereWithoutBootcampsInput | user_bootcamp_assignmentsUpdateManyWithWhereWithoutBootcampsInput[]
    deleteMany?: user_bootcamp_assignmentsScalarWhereInput | user_bootcamp_assignmentsScalarWhereInput[]
  }

  export type user_training_progressUncheckedUpdateManyWithoutBootcampsNestedInput = {
    create?: XOR<user_training_progressCreateWithoutBootcampsInput, user_training_progressUncheckedCreateWithoutBootcampsInput> | user_training_progressCreateWithoutBootcampsInput[] | user_training_progressUncheckedCreateWithoutBootcampsInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutBootcampsInput | user_training_progressCreateOrConnectWithoutBootcampsInput[]
    upsert?: user_training_progressUpsertWithWhereUniqueWithoutBootcampsInput | user_training_progressUpsertWithWhereUniqueWithoutBootcampsInput[]
    createMany?: user_training_progressCreateManyBootcampsInputEnvelope
    set?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    disconnect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    delete?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    update?: user_training_progressUpdateWithWhereUniqueWithoutBootcampsInput | user_training_progressUpdateWithWhereUniqueWithoutBootcampsInput[]
    updateMany?: user_training_progressUpdateManyWithWhereWithoutBootcampsInput | user_training_progressUpdateManyWithWhereWithoutBootcampsInput[]
    deleteMany?: user_training_progressScalarWhereInput | user_training_progressScalarWhereInput[]
  }

  export type conference_trainingsCreateNestedOneWithoutConference_attendeesInput = {
    create?: XOR<conference_trainingsCreateWithoutConference_attendeesInput, conference_trainingsUncheckedCreateWithoutConference_attendeesInput>
    connectOrCreate?: conference_trainingsCreateOrConnectWithoutConference_attendeesInput
    connect?: conference_trainingsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConference_attendeesInput = {
    create?: XOR<UserCreateWithoutConference_attendeesInput, UserUncheckedCreateWithoutConference_attendeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConference_attendeesInput
    connect?: UserWhereUniqueInput
  }

  export type conference_trainingsUpdateOneRequiredWithoutConference_attendeesNestedInput = {
    create?: XOR<conference_trainingsCreateWithoutConference_attendeesInput, conference_trainingsUncheckedCreateWithoutConference_attendeesInput>
    connectOrCreate?: conference_trainingsCreateOrConnectWithoutConference_attendeesInput
    upsert?: conference_trainingsUpsertWithoutConference_attendeesInput
    connect?: conference_trainingsWhereUniqueInput
    update?: XOR<XOR<conference_trainingsUpdateToOneWithWhereWithoutConference_attendeesInput, conference_trainingsUpdateWithoutConference_attendeesInput>, conference_trainingsUncheckedUpdateWithoutConference_attendeesInput>
  }

  export type UserUpdateOneRequiredWithoutConference_attendeesNestedInput = {
    create?: XOR<UserCreateWithoutConference_attendeesInput, UserUncheckedCreateWithoutConference_attendeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConference_attendeesInput
    upsert?: UserUpsertWithoutConference_attendeesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConference_attendeesInput, UserUpdateWithoutConference_attendeesInput>, UserUncheckedUpdateWithoutConference_attendeesInput>
  }

  export type conference_trainingsCreateNestedOneWithoutConference_materialsInput = {
    create?: XOR<conference_trainingsCreateWithoutConference_materialsInput, conference_trainingsUncheckedCreateWithoutConference_materialsInput>
    connectOrCreate?: conference_trainingsCreateOrConnectWithoutConference_materialsInput
    connect?: conference_trainingsWhereUniqueInput
  }

  export type conference_trainingsUpdateOneRequiredWithoutConference_materialsNestedInput = {
    create?: XOR<conference_trainingsCreateWithoutConference_materialsInput, conference_trainingsUncheckedCreateWithoutConference_materialsInput>
    connectOrCreate?: conference_trainingsCreateOrConnectWithoutConference_materialsInput
    upsert?: conference_trainingsUpsertWithoutConference_materialsInput
    connect?: conference_trainingsWhereUniqueInput
    update?: XOR<XOR<conference_trainingsUpdateToOneWithWhereWithoutConference_materialsInput, conference_trainingsUpdateWithoutConference_materialsInput>, conference_trainingsUncheckedUpdateWithoutConference_materialsInput>
  }

  export type conference_attendeesCreateNestedManyWithoutConference_trainingsInput = {
    create?: XOR<conference_attendeesCreateWithoutConference_trainingsInput, conference_attendeesUncheckedCreateWithoutConference_trainingsInput> | conference_attendeesCreateWithoutConference_trainingsInput[] | conference_attendeesUncheckedCreateWithoutConference_trainingsInput[]
    connectOrCreate?: conference_attendeesCreateOrConnectWithoutConference_trainingsInput | conference_attendeesCreateOrConnectWithoutConference_trainingsInput[]
    createMany?: conference_attendeesCreateManyConference_trainingsInputEnvelope
    connect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
  }

  export type conference_materialsCreateNestedManyWithoutConference_trainingsInput = {
    create?: XOR<conference_materialsCreateWithoutConference_trainingsInput, conference_materialsUncheckedCreateWithoutConference_trainingsInput> | conference_materialsCreateWithoutConference_trainingsInput[] | conference_materialsUncheckedCreateWithoutConference_trainingsInput[]
    connectOrCreate?: conference_materialsCreateOrConnectWithoutConference_trainingsInput | conference_materialsCreateOrConnectWithoutConference_trainingsInput[]
    createMany?: conference_materialsCreateManyConference_trainingsInputEnvelope
    connect?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
  }

  export type conference_attendeesUncheckedCreateNestedManyWithoutConference_trainingsInput = {
    create?: XOR<conference_attendeesCreateWithoutConference_trainingsInput, conference_attendeesUncheckedCreateWithoutConference_trainingsInput> | conference_attendeesCreateWithoutConference_trainingsInput[] | conference_attendeesUncheckedCreateWithoutConference_trainingsInput[]
    connectOrCreate?: conference_attendeesCreateOrConnectWithoutConference_trainingsInput | conference_attendeesCreateOrConnectWithoutConference_trainingsInput[]
    createMany?: conference_attendeesCreateManyConference_trainingsInputEnvelope
    connect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
  }

  export type conference_materialsUncheckedCreateNestedManyWithoutConference_trainingsInput = {
    create?: XOR<conference_materialsCreateWithoutConference_trainingsInput, conference_materialsUncheckedCreateWithoutConference_trainingsInput> | conference_materialsCreateWithoutConference_trainingsInput[] | conference_materialsUncheckedCreateWithoutConference_trainingsInput[]
    connectOrCreate?: conference_materialsCreateOrConnectWithoutConference_trainingsInput | conference_materialsCreateOrConnectWithoutConference_trainingsInput[]
    createMany?: conference_materialsCreateManyConference_trainingsInputEnvelope
    connect?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
  }

  export type conference_attendeesUpdateManyWithoutConference_trainingsNestedInput = {
    create?: XOR<conference_attendeesCreateWithoutConference_trainingsInput, conference_attendeesUncheckedCreateWithoutConference_trainingsInput> | conference_attendeesCreateWithoutConference_trainingsInput[] | conference_attendeesUncheckedCreateWithoutConference_trainingsInput[]
    connectOrCreate?: conference_attendeesCreateOrConnectWithoutConference_trainingsInput | conference_attendeesCreateOrConnectWithoutConference_trainingsInput[]
    upsert?: conference_attendeesUpsertWithWhereUniqueWithoutConference_trainingsInput | conference_attendeesUpsertWithWhereUniqueWithoutConference_trainingsInput[]
    createMany?: conference_attendeesCreateManyConference_trainingsInputEnvelope
    set?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    disconnect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    delete?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    connect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    update?: conference_attendeesUpdateWithWhereUniqueWithoutConference_trainingsInput | conference_attendeesUpdateWithWhereUniqueWithoutConference_trainingsInput[]
    updateMany?: conference_attendeesUpdateManyWithWhereWithoutConference_trainingsInput | conference_attendeesUpdateManyWithWhereWithoutConference_trainingsInput[]
    deleteMany?: conference_attendeesScalarWhereInput | conference_attendeesScalarWhereInput[]
  }

  export type conference_materialsUpdateManyWithoutConference_trainingsNestedInput = {
    create?: XOR<conference_materialsCreateWithoutConference_trainingsInput, conference_materialsUncheckedCreateWithoutConference_trainingsInput> | conference_materialsCreateWithoutConference_trainingsInput[] | conference_materialsUncheckedCreateWithoutConference_trainingsInput[]
    connectOrCreate?: conference_materialsCreateOrConnectWithoutConference_trainingsInput | conference_materialsCreateOrConnectWithoutConference_trainingsInput[]
    upsert?: conference_materialsUpsertWithWhereUniqueWithoutConference_trainingsInput | conference_materialsUpsertWithWhereUniqueWithoutConference_trainingsInput[]
    createMany?: conference_materialsCreateManyConference_trainingsInputEnvelope
    set?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
    disconnect?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
    delete?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
    connect?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
    update?: conference_materialsUpdateWithWhereUniqueWithoutConference_trainingsInput | conference_materialsUpdateWithWhereUniqueWithoutConference_trainingsInput[]
    updateMany?: conference_materialsUpdateManyWithWhereWithoutConference_trainingsInput | conference_materialsUpdateManyWithWhereWithoutConference_trainingsInput[]
    deleteMany?: conference_materialsScalarWhereInput | conference_materialsScalarWhereInput[]
  }

  export type conference_attendeesUncheckedUpdateManyWithoutConference_trainingsNestedInput = {
    create?: XOR<conference_attendeesCreateWithoutConference_trainingsInput, conference_attendeesUncheckedCreateWithoutConference_trainingsInput> | conference_attendeesCreateWithoutConference_trainingsInput[] | conference_attendeesUncheckedCreateWithoutConference_trainingsInput[]
    connectOrCreate?: conference_attendeesCreateOrConnectWithoutConference_trainingsInput | conference_attendeesCreateOrConnectWithoutConference_trainingsInput[]
    upsert?: conference_attendeesUpsertWithWhereUniqueWithoutConference_trainingsInput | conference_attendeesUpsertWithWhereUniqueWithoutConference_trainingsInput[]
    createMany?: conference_attendeesCreateManyConference_trainingsInputEnvelope
    set?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    disconnect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    delete?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    connect?: conference_attendeesWhereUniqueInput | conference_attendeesWhereUniqueInput[]
    update?: conference_attendeesUpdateWithWhereUniqueWithoutConference_trainingsInput | conference_attendeesUpdateWithWhereUniqueWithoutConference_trainingsInput[]
    updateMany?: conference_attendeesUpdateManyWithWhereWithoutConference_trainingsInput | conference_attendeesUpdateManyWithWhereWithoutConference_trainingsInput[]
    deleteMany?: conference_attendeesScalarWhereInput | conference_attendeesScalarWhereInput[]
  }

  export type conference_materialsUncheckedUpdateManyWithoutConference_trainingsNestedInput = {
    create?: XOR<conference_materialsCreateWithoutConference_trainingsInput, conference_materialsUncheckedCreateWithoutConference_trainingsInput> | conference_materialsCreateWithoutConference_trainingsInput[] | conference_materialsUncheckedCreateWithoutConference_trainingsInput[]
    connectOrCreate?: conference_materialsCreateOrConnectWithoutConference_trainingsInput | conference_materialsCreateOrConnectWithoutConference_trainingsInput[]
    upsert?: conference_materialsUpsertWithWhereUniqueWithoutConference_trainingsInput | conference_materialsUpsertWithWhereUniqueWithoutConference_trainingsInput[]
    createMany?: conference_materialsCreateManyConference_trainingsInputEnvelope
    set?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
    disconnect?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
    delete?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
    connect?: conference_materialsWhereUniqueInput | conference_materialsWhereUniqueInput[]
    update?: conference_materialsUpdateWithWhereUniqueWithoutConference_trainingsInput | conference_materialsUpdateWithWhereUniqueWithoutConference_trainingsInput[]
    updateMany?: conference_materialsUpdateManyWithWhereWithoutConference_trainingsInput | conference_materialsUpdateManyWithWhereWithoutConference_trainingsInput[]
    deleteMany?: conference_materialsScalarWhereInput | conference_materialsScalarWhereInput[]
  }

  export type trainingsCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<trainingsCreateWithoutEnrollmentsInput, trainingsUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutEnrollmentsInput
    connect?: trainingsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
  }

  export type trainingsUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<trainingsCreateWithoutEnrollmentsInput, trainingsUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutEnrollmentsInput
    upsert?: trainingsUpsertWithoutEnrollmentsInput
    connect?: trainingsWhereUniqueInput
    update?: XOR<XOR<trainingsUpdateToOneWithWhereWithoutEnrollmentsInput, trainingsUpdateWithoutEnrollmentsInput>, trainingsUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEnrollmentsInput
    upsert?: UserUpsertWithoutEnrollmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEnrollmentsInput, UserUpdateWithoutEnrollmentsInput>, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type quizzesCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<quizzesCreateWithoutQuestionsInput, quizzesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: quizzesCreateOrConnectWithoutQuestionsInput
    connect?: quizzesWhereUniqueInput
  }

  export type quizzesUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<quizzesCreateWithoutQuestionsInput, quizzesUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: quizzesCreateOrConnectWithoutQuestionsInput
    upsert?: quizzesUpsertWithoutQuestionsInput
    connect?: quizzesWhereUniqueInput
    update?: XOR<XOR<quizzesUpdateToOneWithWhereWithoutQuestionsInput, quizzesUpdateWithoutQuestionsInput>, quizzesUncheckedUpdateWithoutQuestionsInput>
  }

  export type questionsCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<questionsCreateWithoutQuizzesInput, questionsUncheckedCreateWithoutQuizzesInput> | questionsCreateWithoutQuizzesInput[] | questionsUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuizzesInput | questionsCreateOrConnectWithoutQuizzesInput[]
    createMany?: questionsCreateManyQuizzesInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type trainingsCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<trainingsCreateWithoutQuizzesInput, trainingsUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutQuizzesInput
    connect?: trainingsWhereUniqueInput
  }

  export type questionsUncheckedCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<questionsCreateWithoutQuizzesInput, questionsUncheckedCreateWithoutQuizzesInput> | questionsCreateWithoutQuizzesInput[] | questionsUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuizzesInput | questionsCreateOrConnectWithoutQuizzesInput[]
    createMany?: questionsCreateManyQuizzesInputEnvelope
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
  }

  export type questionsUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<questionsCreateWithoutQuizzesInput, questionsUncheckedCreateWithoutQuizzesInput> | questionsCreateWithoutQuizzesInput[] | questionsUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuizzesInput | questionsCreateOrConnectWithoutQuizzesInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuizzesInput | questionsUpsertWithWhereUniqueWithoutQuizzesInput[]
    createMany?: questionsCreateManyQuizzesInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuizzesInput | questionsUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuizzesInput | questionsUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type trainingsUpdateOneWithoutQuizzesNestedInput = {
    create?: XOR<trainingsCreateWithoutQuizzesInput, trainingsUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutQuizzesInput
    upsert?: trainingsUpsertWithoutQuizzesInput
    disconnect?: trainingsWhereInput | boolean
    delete?: trainingsWhereInput | boolean
    connect?: trainingsWhereUniqueInput
    update?: XOR<XOR<trainingsUpdateToOneWithWhereWithoutQuizzesInput, trainingsUpdateWithoutQuizzesInput>, trainingsUncheckedUpdateWithoutQuizzesInput>
  }

  export type questionsUncheckedUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<questionsCreateWithoutQuizzesInput, questionsUncheckedCreateWithoutQuizzesInput> | questionsCreateWithoutQuizzesInput[] | questionsUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: questionsCreateOrConnectWithoutQuizzesInput | questionsCreateOrConnectWithoutQuizzesInput[]
    upsert?: questionsUpsertWithWhereUniqueWithoutQuizzesInput | questionsUpsertWithWhereUniqueWithoutQuizzesInput[]
    createMany?: questionsCreateManyQuizzesInputEnvelope
    set?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    disconnect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    delete?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    connect?: questionsWhereUniqueInput | questionsWhereUniqueInput[]
    update?: questionsUpdateWithWhereUniqueWithoutQuizzesInput | questionsUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: questionsUpdateManyWithWhereWithoutQuizzesInput | questionsUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: questionsScalarWhereInput | questionsScalarWhereInput[]
  }

  export type trainingsCreateNestedOneWithoutTraining_contentInput = {
    create?: XOR<trainingsCreateWithoutTraining_contentInput, trainingsUncheckedCreateWithoutTraining_contentInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutTraining_contentInput
    connect?: trainingsWhereUniqueInput
  }

  export type trainingsUpdateOneRequiredWithoutTraining_contentNestedInput = {
    create?: XOR<trainingsCreateWithoutTraining_contentInput, trainingsUncheckedCreateWithoutTraining_contentInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutTraining_contentInput
    upsert?: trainingsUpsertWithoutTraining_contentInput
    connect?: trainingsWhereUniqueInput
    update?: XOR<XOR<trainingsUpdateToOneWithWhereWithoutTraining_contentInput, trainingsUpdateWithoutTraining_contentInput>, trainingsUncheckedUpdateWithoutTraining_contentInput>
  }

  export type trainingsCreatetagsInput = {
    set: string[]
  }

  export type trainingsCreatelearning_outcomesInput = {
    set: string[]
  }

  export type bootcamp_trainingsCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<bootcamp_trainingsCreateWithoutTrainingsInput, bootcamp_trainingsUncheckedCreateWithoutTrainingsInput> | bootcamp_trainingsCreateWithoutTrainingsInput[] | bootcamp_trainingsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: bootcamp_trainingsCreateOrConnectWithoutTrainingsInput | bootcamp_trainingsCreateOrConnectWithoutTrainingsInput[]
    createMany?: bootcamp_trainingsCreateManyTrainingsInputEnvelope
    connect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
  }

  export type enrollmentsCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<enrollmentsCreateWithoutTrainingsInput, enrollmentsUncheckedCreateWithoutTrainingsInput> | enrollmentsCreateWithoutTrainingsInput[] | enrollmentsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutTrainingsInput | enrollmentsCreateOrConnectWithoutTrainingsInput[]
    createMany?: enrollmentsCreateManyTrainingsInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type quizzesCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<quizzesCreateWithoutTrainingsInput, quizzesUncheckedCreateWithoutTrainingsInput> | quizzesCreateWithoutTrainingsInput[] | quizzesUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: quizzesCreateOrConnectWithoutTrainingsInput | quizzesCreateOrConnectWithoutTrainingsInput[]
    createMany?: quizzesCreateManyTrainingsInputEnvelope
    connect?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
  }

  export type training_contentCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<training_contentCreateWithoutTrainingsInput, training_contentUncheckedCreateWithoutTrainingsInput> | training_contentCreateWithoutTrainingsInput[] | training_contentUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: training_contentCreateOrConnectWithoutTrainingsInput | training_contentCreateOrConnectWithoutTrainingsInput[]
    createMany?: training_contentCreateManyTrainingsInputEnvelope
    connect?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
  }

  export type user_training_assignmentsCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<user_training_assignmentsCreateWithoutTrainingsInput, user_training_assignmentsUncheckedCreateWithoutTrainingsInput> | user_training_assignmentsCreateWithoutTrainingsInput[] | user_training_assignmentsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: user_training_assignmentsCreateOrConnectWithoutTrainingsInput | user_training_assignmentsCreateOrConnectWithoutTrainingsInput[]
    createMany?: user_training_assignmentsCreateManyTrainingsInputEnvelope
    connect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
  }

  export type user_training_progressCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<user_training_progressCreateWithoutTrainingsInput, user_training_progressUncheckedCreateWithoutTrainingsInput> | user_training_progressCreateWithoutTrainingsInput[] | user_training_progressUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutTrainingsInput | user_training_progressCreateOrConnectWithoutTrainingsInput[]
    createMany?: user_training_progressCreateManyTrainingsInputEnvelope
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
  }

  export type bootcamp_trainingsUncheckedCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<bootcamp_trainingsCreateWithoutTrainingsInput, bootcamp_trainingsUncheckedCreateWithoutTrainingsInput> | bootcamp_trainingsCreateWithoutTrainingsInput[] | bootcamp_trainingsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: bootcamp_trainingsCreateOrConnectWithoutTrainingsInput | bootcamp_trainingsCreateOrConnectWithoutTrainingsInput[]
    createMany?: bootcamp_trainingsCreateManyTrainingsInputEnvelope
    connect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
  }

  export type enrollmentsUncheckedCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<enrollmentsCreateWithoutTrainingsInput, enrollmentsUncheckedCreateWithoutTrainingsInput> | enrollmentsCreateWithoutTrainingsInput[] | enrollmentsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutTrainingsInput | enrollmentsCreateOrConnectWithoutTrainingsInput[]
    createMany?: enrollmentsCreateManyTrainingsInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type quizzesUncheckedCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<quizzesCreateWithoutTrainingsInput, quizzesUncheckedCreateWithoutTrainingsInput> | quizzesCreateWithoutTrainingsInput[] | quizzesUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: quizzesCreateOrConnectWithoutTrainingsInput | quizzesCreateOrConnectWithoutTrainingsInput[]
    createMany?: quizzesCreateManyTrainingsInputEnvelope
    connect?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
  }

  export type training_contentUncheckedCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<training_contentCreateWithoutTrainingsInput, training_contentUncheckedCreateWithoutTrainingsInput> | training_contentCreateWithoutTrainingsInput[] | training_contentUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: training_contentCreateOrConnectWithoutTrainingsInput | training_contentCreateOrConnectWithoutTrainingsInput[]
    createMany?: training_contentCreateManyTrainingsInputEnvelope
    connect?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
  }

  export type user_training_assignmentsUncheckedCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<user_training_assignmentsCreateWithoutTrainingsInput, user_training_assignmentsUncheckedCreateWithoutTrainingsInput> | user_training_assignmentsCreateWithoutTrainingsInput[] | user_training_assignmentsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: user_training_assignmentsCreateOrConnectWithoutTrainingsInput | user_training_assignmentsCreateOrConnectWithoutTrainingsInput[]
    createMany?: user_training_assignmentsCreateManyTrainingsInputEnvelope
    connect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
  }

  export type user_training_progressUncheckedCreateNestedManyWithoutTrainingsInput = {
    create?: XOR<user_training_progressCreateWithoutTrainingsInput, user_training_progressUncheckedCreateWithoutTrainingsInput> | user_training_progressCreateWithoutTrainingsInput[] | user_training_progressUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutTrainingsInput | user_training_progressCreateOrConnectWithoutTrainingsInput[]
    createMany?: user_training_progressCreateManyTrainingsInputEnvelope
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
  }

  export type trainingsUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type trainingsUpdatelearning_outcomesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type bootcamp_trainingsUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<bootcamp_trainingsCreateWithoutTrainingsInput, bootcamp_trainingsUncheckedCreateWithoutTrainingsInput> | bootcamp_trainingsCreateWithoutTrainingsInput[] | bootcamp_trainingsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: bootcamp_trainingsCreateOrConnectWithoutTrainingsInput | bootcamp_trainingsCreateOrConnectWithoutTrainingsInput[]
    upsert?: bootcamp_trainingsUpsertWithWhereUniqueWithoutTrainingsInput | bootcamp_trainingsUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: bootcamp_trainingsCreateManyTrainingsInputEnvelope
    set?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    disconnect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    delete?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    connect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    update?: bootcamp_trainingsUpdateWithWhereUniqueWithoutTrainingsInput | bootcamp_trainingsUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: bootcamp_trainingsUpdateManyWithWhereWithoutTrainingsInput | bootcamp_trainingsUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: bootcamp_trainingsScalarWhereInput | bootcamp_trainingsScalarWhereInput[]
  }

  export type enrollmentsUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<enrollmentsCreateWithoutTrainingsInput, enrollmentsUncheckedCreateWithoutTrainingsInput> | enrollmentsCreateWithoutTrainingsInput[] | enrollmentsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutTrainingsInput | enrollmentsCreateOrConnectWithoutTrainingsInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutTrainingsInput | enrollmentsUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: enrollmentsCreateManyTrainingsInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutTrainingsInput | enrollmentsUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutTrainingsInput | enrollmentsUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type quizzesUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<quizzesCreateWithoutTrainingsInput, quizzesUncheckedCreateWithoutTrainingsInput> | quizzesCreateWithoutTrainingsInput[] | quizzesUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: quizzesCreateOrConnectWithoutTrainingsInput | quizzesCreateOrConnectWithoutTrainingsInput[]
    upsert?: quizzesUpsertWithWhereUniqueWithoutTrainingsInput | quizzesUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: quizzesCreateManyTrainingsInputEnvelope
    set?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
    disconnect?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
    delete?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
    connect?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
    update?: quizzesUpdateWithWhereUniqueWithoutTrainingsInput | quizzesUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: quizzesUpdateManyWithWhereWithoutTrainingsInput | quizzesUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: quizzesScalarWhereInput | quizzesScalarWhereInput[]
  }

  export type training_contentUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<training_contentCreateWithoutTrainingsInput, training_contentUncheckedCreateWithoutTrainingsInput> | training_contentCreateWithoutTrainingsInput[] | training_contentUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: training_contentCreateOrConnectWithoutTrainingsInput | training_contentCreateOrConnectWithoutTrainingsInput[]
    upsert?: training_contentUpsertWithWhereUniqueWithoutTrainingsInput | training_contentUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: training_contentCreateManyTrainingsInputEnvelope
    set?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
    disconnect?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
    delete?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
    connect?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
    update?: training_contentUpdateWithWhereUniqueWithoutTrainingsInput | training_contentUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: training_contentUpdateManyWithWhereWithoutTrainingsInput | training_contentUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: training_contentScalarWhereInput | training_contentScalarWhereInput[]
  }

  export type user_training_assignmentsUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<user_training_assignmentsCreateWithoutTrainingsInput, user_training_assignmentsUncheckedCreateWithoutTrainingsInput> | user_training_assignmentsCreateWithoutTrainingsInput[] | user_training_assignmentsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: user_training_assignmentsCreateOrConnectWithoutTrainingsInput | user_training_assignmentsCreateOrConnectWithoutTrainingsInput[]
    upsert?: user_training_assignmentsUpsertWithWhereUniqueWithoutTrainingsInput | user_training_assignmentsUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: user_training_assignmentsCreateManyTrainingsInputEnvelope
    set?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    disconnect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    delete?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    connect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    update?: user_training_assignmentsUpdateWithWhereUniqueWithoutTrainingsInput | user_training_assignmentsUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: user_training_assignmentsUpdateManyWithWhereWithoutTrainingsInput | user_training_assignmentsUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: user_training_assignmentsScalarWhereInput | user_training_assignmentsScalarWhereInput[]
  }

  export type user_training_progressUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<user_training_progressCreateWithoutTrainingsInput, user_training_progressUncheckedCreateWithoutTrainingsInput> | user_training_progressCreateWithoutTrainingsInput[] | user_training_progressUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutTrainingsInput | user_training_progressCreateOrConnectWithoutTrainingsInput[]
    upsert?: user_training_progressUpsertWithWhereUniqueWithoutTrainingsInput | user_training_progressUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: user_training_progressCreateManyTrainingsInputEnvelope
    set?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    disconnect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    delete?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    update?: user_training_progressUpdateWithWhereUniqueWithoutTrainingsInput | user_training_progressUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: user_training_progressUpdateManyWithWhereWithoutTrainingsInput | user_training_progressUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: user_training_progressScalarWhereInput | user_training_progressScalarWhereInput[]
  }

  export type bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<bootcamp_trainingsCreateWithoutTrainingsInput, bootcamp_trainingsUncheckedCreateWithoutTrainingsInput> | bootcamp_trainingsCreateWithoutTrainingsInput[] | bootcamp_trainingsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: bootcamp_trainingsCreateOrConnectWithoutTrainingsInput | bootcamp_trainingsCreateOrConnectWithoutTrainingsInput[]
    upsert?: bootcamp_trainingsUpsertWithWhereUniqueWithoutTrainingsInput | bootcamp_trainingsUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: bootcamp_trainingsCreateManyTrainingsInputEnvelope
    set?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    disconnect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    delete?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    connect?: bootcamp_trainingsWhereUniqueInput | bootcamp_trainingsWhereUniqueInput[]
    update?: bootcamp_trainingsUpdateWithWhereUniqueWithoutTrainingsInput | bootcamp_trainingsUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: bootcamp_trainingsUpdateManyWithWhereWithoutTrainingsInput | bootcamp_trainingsUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: bootcamp_trainingsScalarWhereInput | bootcamp_trainingsScalarWhereInput[]
  }

  export type enrollmentsUncheckedUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<enrollmentsCreateWithoutTrainingsInput, enrollmentsUncheckedCreateWithoutTrainingsInput> | enrollmentsCreateWithoutTrainingsInput[] | enrollmentsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutTrainingsInput | enrollmentsCreateOrConnectWithoutTrainingsInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutTrainingsInput | enrollmentsUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: enrollmentsCreateManyTrainingsInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutTrainingsInput | enrollmentsUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutTrainingsInput | enrollmentsUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type quizzesUncheckedUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<quizzesCreateWithoutTrainingsInput, quizzesUncheckedCreateWithoutTrainingsInput> | quizzesCreateWithoutTrainingsInput[] | quizzesUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: quizzesCreateOrConnectWithoutTrainingsInput | quizzesCreateOrConnectWithoutTrainingsInput[]
    upsert?: quizzesUpsertWithWhereUniqueWithoutTrainingsInput | quizzesUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: quizzesCreateManyTrainingsInputEnvelope
    set?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
    disconnect?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
    delete?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
    connect?: quizzesWhereUniqueInput | quizzesWhereUniqueInput[]
    update?: quizzesUpdateWithWhereUniqueWithoutTrainingsInput | quizzesUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: quizzesUpdateManyWithWhereWithoutTrainingsInput | quizzesUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: quizzesScalarWhereInput | quizzesScalarWhereInput[]
  }

  export type training_contentUncheckedUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<training_contentCreateWithoutTrainingsInput, training_contentUncheckedCreateWithoutTrainingsInput> | training_contentCreateWithoutTrainingsInput[] | training_contentUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: training_contentCreateOrConnectWithoutTrainingsInput | training_contentCreateOrConnectWithoutTrainingsInput[]
    upsert?: training_contentUpsertWithWhereUniqueWithoutTrainingsInput | training_contentUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: training_contentCreateManyTrainingsInputEnvelope
    set?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
    disconnect?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
    delete?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
    connect?: training_contentWhereUniqueInput | training_contentWhereUniqueInput[]
    update?: training_contentUpdateWithWhereUniqueWithoutTrainingsInput | training_contentUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: training_contentUpdateManyWithWhereWithoutTrainingsInput | training_contentUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: training_contentScalarWhereInput | training_contentScalarWhereInput[]
  }

  export type user_training_assignmentsUncheckedUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<user_training_assignmentsCreateWithoutTrainingsInput, user_training_assignmentsUncheckedCreateWithoutTrainingsInput> | user_training_assignmentsCreateWithoutTrainingsInput[] | user_training_assignmentsUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: user_training_assignmentsCreateOrConnectWithoutTrainingsInput | user_training_assignmentsCreateOrConnectWithoutTrainingsInput[]
    upsert?: user_training_assignmentsUpsertWithWhereUniqueWithoutTrainingsInput | user_training_assignmentsUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: user_training_assignmentsCreateManyTrainingsInputEnvelope
    set?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    disconnect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    delete?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    connect?: user_training_assignmentsWhereUniqueInput | user_training_assignmentsWhereUniqueInput[]
    update?: user_training_assignmentsUpdateWithWhereUniqueWithoutTrainingsInput | user_training_assignmentsUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: user_training_assignmentsUpdateManyWithWhereWithoutTrainingsInput | user_training_assignmentsUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: user_training_assignmentsScalarWhereInput | user_training_assignmentsScalarWhereInput[]
  }

  export type user_training_progressUncheckedUpdateManyWithoutTrainingsNestedInput = {
    create?: XOR<user_training_progressCreateWithoutTrainingsInput, user_training_progressUncheckedCreateWithoutTrainingsInput> | user_training_progressCreateWithoutTrainingsInput[] | user_training_progressUncheckedCreateWithoutTrainingsInput[]
    connectOrCreate?: user_training_progressCreateOrConnectWithoutTrainingsInput | user_training_progressCreateOrConnectWithoutTrainingsInput[]
    upsert?: user_training_progressUpsertWithWhereUniqueWithoutTrainingsInput | user_training_progressUpsertWithWhereUniqueWithoutTrainingsInput[]
    createMany?: user_training_progressCreateManyTrainingsInputEnvelope
    set?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    disconnect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    delete?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    connect?: user_training_progressWhereUniqueInput | user_training_progressWhereUniqueInput[]
    update?: user_training_progressUpdateWithWhereUniqueWithoutTrainingsInput | user_training_progressUpdateWithWhereUniqueWithoutTrainingsInput[]
    updateMany?: user_training_progressUpdateManyWithWhereWithoutTrainingsInput | user_training_progressUpdateManyWithWhereWithoutTrainingsInput[]
    deleteMany?: user_training_progressScalarWhereInput | user_training_progressScalarWhereInput[]
  }

  export type bootcampsCreateNestedOneWithoutUser_bootcamp_assignmentsInput = {
    create?: XOR<bootcampsCreateWithoutUser_bootcamp_assignmentsInput, bootcampsUncheckedCreateWithoutUser_bootcamp_assignmentsInput>
    connectOrCreate?: bootcampsCreateOrConnectWithoutUser_bootcamp_assignmentsInput
    connect?: bootcampsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_bootcamp_assignmentsInput = {
    create?: XOR<UserCreateWithoutUser_bootcamp_assignmentsInput, UserUncheckedCreateWithoutUser_bootcamp_assignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_bootcamp_assignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type bootcampsUpdateOneRequiredWithoutUser_bootcamp_assignmentsNestedInput = {
    create?: XOR<bootcampsCreateWithoutUser_bootcamp_assignmentsInput, bootcampsUncheckedCreateWithoutUser_bootcamp_assignmentsInput>
    connectOrCreate?: bootcampsCreateOrConnectWithoutUser_bootcamp_assignmentsInput
    upsert?: bootcampsUpsertWithoutUser_bootcamp_assignmentsInput
    connect?: bootcampsWhereUniqueInput
    update?: XOR<XOR<bootcampsUpdateToOneWithWhereWithoutUser_bootcamp_assignmentsInput, bootcampsUpdateWithoutUser_bootcamp_assignmentsInput>, bootcampsUncheckedUpdateWithoutUser_bootcamp_assignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutUser_bootcamp_assignmentsNestedInput = {
    create?: XOR<UserCreateWithoutUser_bootcamp_assignmentsInput, UserUncheckedCreateWithoutUser_bootcamp_assignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_bootcamp_assignmentsInput
    upsert?: UserUpsertWithoutUser_bootcamp_assignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_bootcamp_assignmentsInput, UserUpdateWithoutUser_bootcamp_assignmentsInput>, UserUncheckedUpdateWithoutUser_bootcamp_assignmentsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type trainingsCreateNestedOneWithoutUser_training_assignmentsInput = {
    create?: XOR<trainingsCreateWithoutUser_training_assignmentsInput, trainingsUncheckedCreateWithoutUser_training_assignmentsInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutUser_training_assignmentsInput
    connect?: trainingsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_training_assignmentsInput = {
    create?: XOR<UserCreateWithoutUser_training_assignmentsInput, UserUncheckedCreateWithoutUser_training_assignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_training_assignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type trainingsUpdateOneRequiredWithoutUser_training_assignmentsNestedInput = {
    create?: XOR<trainingsCreateWithoutUser_training_assignmentsInput, trainingsUncheckedCreateWithoutUser_training_assignmentsInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutUser_training_assignmentsInput
    upsert?: trainingsUpsertWithoutUser_training_assignmentsInput
    connect?: trainingsWhereUniqueInput
    update?: XOR<XOR<trainingsUpdateToOneWithWhereWithoutUser_training_assignmentsInput, trainingsUpdateWithoutUser_training_assignmentsInput>, trainingsUncheckedUpdateWithoutUser_training_assignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutUser_training_assignmentsNestedInput = {
    create?: XOR<UserCreateWithoutUser_training_assignmentsInput, UserUncheckedCreateWithoutUser_training_assignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_training_assignmentsInput
    upsert?: UserUpsertWithoutUser_training_assignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_training_assignmentsInput, UserUpdateWithoutUser_training_assignmentsInput>, UserUncheckedUpdateWithoutUser_training_assignmentsInput>
  }

  export type bootcampsCreateNestedOneWithoutUser_training_progressInput = {
    create?: XOR<bootcampsCreateWithoutUser_training_progressInput, bootcampsUncheckedCreateWithoutUser_training_progressInput>
    connectOrCreate?: bootcampsCreateOrConnectWithoutUser_training_progressInput
    connect?: bootcampsWhereUniqueInput
  }

  export type trainingsCreateNestedOneWithoutUser_training_progressInput = {
    create?: XOR<trainingsCreateWithoutUser_training_progressInput, trainingsUncheckedCreateWithoutUser_training_progressInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutUser_training_progressInput
    connect?: trainingsWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_training_progressInput = {
    create?: XOR<UserCreateWithoutUser_training_progressInput, UserUncheckedCreateWithoutUser_training_progressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_training_progressInput
    connect?: UserWhereUniqueInput
  }

  export type bootcampsUpdateOneWithoutUser_training_progressNestedInput = {
    create?: XOR<bootcampsCreateWithoutUser_training_progressInput, bootcampsUncheckedCreateWithoutUser_training_progressInput>
    connectOrCreate?: bootcampsCreateOrConnectWithoutUser_training_progressInput
    upsert?: bootcampsUpsertWithoutUser_training_progressInput
    disconnect?: bootcampsWhereInput | boolean
    delete?: bootcampsWhereInput | boolean
    connect?: bootcampsWhereUniqueInput
    update?: XOR<XOR<bootcampsUpdateToOneWithWhereWithoutUser_training_progressInput, bootcampsUpdateWithoutUser_training_progressInput>, bootcampsUncheckedUpdateWithoutUser_training_progressInput>
  }

  export type trainingsUpdateOneRequiredWithoutUser_training_progressNestedInput = {
    create?: XOR<trainingsCreateWithoutUser_training_progressInput, trainingsUncheckedCreateWithoutUser_training_progressInput>
    connectOrCreate?: trainingsCreateOrConnectWithoutUser_training_progressInput
    upsert?: trainingsUpsertWithoutUser_training_progressInput
    connect?: trainingsWhereUniqueInput
    update?: XOR<XOR<trainingsUpdateToOneWithWhereWithoutUser_training_progressInput, trainingsUpdateWithoutUser_training_progressInput>, trainingsUncheckedUpdateWithoutUser_training_progressInput>
  }

  export type UserUpdateOneRequiredWithoutUser_training_progressNestedInput = {
    create?: XOR<UserCreateWithoutUser_training_progressInput, UserUncheckedCreateWithoutUser_training_progressInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_training_progressInput
    upsert?: UserUpsertWithoutUser_training_progressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_training_progressInput, UserUpdateWithoutUser_training_progressInput>, UserUncheckedUpdateWithoutUser_training_progressInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumuser_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleFilter<$PrismaModel> | $Enums.user_role
  }

  export type NestedEnumlogin_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.login_type | Enumlogin_typeFieldRefInput<$PrismaModel>
    in?: $Enums.login_type[] | ListEnumlogin_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.login_type[] | ListEnumlogin_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumlogin_typeFilter<$PrismaModel> | $Enums.login_type
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumuser_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel>
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel>
    not?: NestedEnumuser_roleWithAggregatesFilter<$PrismaModel> | $Enums.user_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuser_roleFilter<$PrismaModel>
    _max?: NestedEnumuser_roleFilter<$PrismaModel>
  }

  export type NestedEnumlogin_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.login_type | Enumlogin_typeFieldRefInput<$PrismaModel>
    in?: $Enums.login_type[] | ListEnumlogin_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.login_type[] | ListEnumlogin_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumlogin_typeWithAggregatesFilter<$PrismaModel> | $Enums.login_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumlogin_typeFilter<$PrismaModel>
    _max?: NestedEnumlogin_typeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
    users_admin_permission_logs_user_idTousers: UserCreateNestedOneWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput
  }

  export type admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    id?: number
    user_id: number
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
  }

  export type admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    where: admin_permission_logsWhereUniqueInput
    create: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput>
  }

  export type admin_permission_logsCreateManyUsers_admin_permission_logs_modified_byTousersInputEnvelope = {
    data: admin_permission_logsCreateManyUsers_admin_permission_logs_modified_byTousersInput | admin_permission_logsCreateManyUsers_admin_permission_logs_modified_byTousersInput[]
    skipDuplicates?: boolean
  }

  export type admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput = {
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
    users_admin_permission_logs_modified_byTousers: UserCreateNestedOneWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput
  }

  export type admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput = {
    id?: number
    modified_by: number
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
  }

  export type admin_permission_logsCreateOrConnectWithoutUsers_admin_permission_logs_user_idTousersInput = {
    where: admin_permission_logsWhereUniqueInput
    create: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput>
  }

  export type admin_permission_logsCreateManyUsers_admin_permission_logs_user_idTousersInputEnvelope = {
    data: admin_permission_logsCreateManyUsers_admin_permission_logs_user_idTousersInput | admin_permission_logsCreateManyUsers_admin_permission_logs_user_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput = {
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
    users_admin_permissions_user_idTousers: UserCreateNestedOneWithoutAdmin_permissions_admin_permissions_user_idTousersInput
  }

  export type admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput = {
    id?: number
    user_id: number
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
  }

  export type admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_granted_byTousersInput = {
    where: admin_permissionsWhereUniqueInput
    create: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput>
  }

  export type admin_permissionsCreateManyUsers_admin_permissions_granted_byTousersInputEnvelope = {
    data: admin_permissionsCreateManyUsers_admin_permissions_granted_byTousersInput | admin_permissionsCreateManyUsers_admin_permissions_granted_byTousersInput[]
    skipDuplicates?: boolean
  }

  export type admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput = {
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
    users_admin_permissions_granted_byTousers: UserCreateNestedOneWithoutAdmin_permissions_admin_permissions_granted_byTousersInput
  }

  export type admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput = {
    id?: number
    granted_by: number
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
  }

  export type admin_permissionsCreateOrConnectWithoutUsers_admin_permissions_user_idTousersInput = {
    where: admin_permissionsWhereUniqueInput
    create: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput>
  }

  export type admin_permissionsCreateManyUsers_admin_permissions_user_idTousersInputEnvelope = {
    data: admin_permissionsCreateManyUsers_admin_permissions_user_idTousersInput | admin_permissionsCreateManyUsers_admin_permissions_user_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type AdminCreateWithoutUserInput = {
    adminLevel: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: number
    adminLevel: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateManyUserInputEnvelope = {
    data: AdminCreateManyUserInput | AdminCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type bootcamp_progressCreateWithoutUsersInput = {
    id?: string
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
    bootcamps: bootcampsCreateNestedOneWithoutBootcamp_progressInput
  }

  export type bootcamp_progressUncheckedCreateWithoutUsersInput = {
    id?: string
    bootcamp_id: string
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
  }

  export type bootcamp_progressCreateOrConnectWithoutUsersInput = {
    where: bootcamp_progressWhereUniqueInput
    create: XOR<bootcamp_progressCreateWithoutUsersInput, bootcamp_progressUncheckedCreateWithoutUsersInput>
  }

  export type bootcamp_progressCreateManyUsersInputEnvelope = {
    data: bootcamp_progressCreateManyUsersInput | bootcamp_progressCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type conference_attendeesCreateWithoutUsersInput = {
    id?: string
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
    conference_trainings: conference_trainingsCreateNestedOneWithoutConference_attendeesInput
  }

  export type conference_attendeesUncheckedCreateWithoutUsersInput = {
    id?: string
    conference_id: string
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
  }

  export type conference_attendeesCreateOrConnectWithoutUsersInput = {
    where: conference_attendeesWhereUniqueInput
    create: XOR<conference_attendeesCreateWithoutUsersInput, conference_attendeesUncheckedCreateWithoutUsersInput>
  }

  export type conference_attendeesCreateManyUsersInputEnvelope = {
    data: conference_attendeesCreateManyUsersInput | conference_attendeesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutUserInput = {
    telesetCardNo?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: number
    telesetCardNo?: string | null
    departmentId?: number | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeCreateManyUserInputEnvelope = {
    data: EmployeeCreateManyUserInput | EmployeeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type enrollmentsCreateWithoutUsersInput = {
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    trainings: trainingsCreateNestedOneWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateWithoutUsersInput = {
    id?: number
    training_id: string
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type enrollmentsCreateOrConnectWithoutUsersInput = {
    where: enrollmentsWhereUniqueInput
    create: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput>
  }

  export type enrollmentsCreateManyUsersInputEnvelope = {
    data: enrollmentsCreateManyUsersInput | enrollmentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type LogCreateWithoutUsersInput = {
    action_type: string
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: boolean | null
  }

  export type LogUncheckedCreateWithoutUsersInput = {
    id?: number
    action_type: string
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: boolean | null
  }

  export type LogCreateOrConnectWithoutUsersInput = {
    where: LogWhereUniqueInput
    create: XOR<LogCreateWithoutUsersInput, LogUncheckedCreateWithoutUsersInput>
  }

  export type LogCreateManyUsersInputEnvelope = {
    data: LogCreateManyUsersInput | LogCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_bootcamp_assignmentsCreateWithoutUsersInput = {
    id?: string
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
    bootcamps: bootcampsCreateNestedOneWithoutUser_bootcamp_assignmentsInput
  }

  export type user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput = {
    id?: string
    bootcamp_id: string
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
  }

  export type user_bootcamp_assignmentsCreateOrConnectWithoutUsersInput = {
    where: user_bootcamp_assignmentsWhereUniqueInput
    create: XOR<user_bootcamp_assignmentsCreateWithoutUsersInput, user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput>
  }

  export type user_bootcamp_assignmentsCreateManyUsersInputEnvelope = {
    data: user_bootcamp_assignmentsCreateManyUsersInput | user_bootcamp_assignmentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_training_assignmentsCreateWithoutUsersInput = {
    assigned_at?: Date | string | null
    trainings: trainingsCreateNestedOneWithoutUser_training_assignmentsInput
  }

  export type user_training_assignmentsUncheckedCreateWithoutUsersInput = {
    assignment_id?: number
    training_id: string
    assigned_at?: Date | string | null
  }

  export type user_training_assignmentsCreateOrConnectWithoutUsersInput = {
    where: user_training_assignmentsWhereUniqueInput
    create: XOR<user_training_assignmentsCreateWithoutUsersInput, user_training_assignmentsUncheckedCreateWithoutUsersInput>
  }

  export type user_training_assignmentsCreateManyUsersInputEnvelope = {
    data: user_training_assignmentsCreateManyUsersInput | user_training_assignmentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_training_progressCreateWithoutUsersInput = {
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
    bootcamps?: bootcampsCreateNestedOneWithoutUser_training_progressInput
    trainings: trainingsCreateNestedOneWithoutUser_training_progressInput
  }

  export type user_training_progressUncheckedCreateWithoutUsersInput = {
    bootcamp_id?: string | null
    training_id: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
  }

  export type user_training_progressCreateOrConnectWithoutUsersInput = {
    where: user_training_progressWhereUniqueInput
    create: XOR<user_training_progressCreateWithoutUsersInput, user_training_progressUncheckedCreateWithoutUsersInput>
  }

  export type user_training_progressCreateManyUsersInputEnvelope = {
    data: user_training_progressCreateManyUsersInput | user_training_progressCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    where: admin_permission_logsWhereUniqueInput
    update: XOR<admin_permission_logsUpdateWithoutUsers_admin_permission_logs_modified_byTousersInput, admin_permission_logsUncheckedUpdateWithoutUsers_admin_permission_logs_modified_byTousersInput>
    create: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_modified_byTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_modified_byTousersInput>
  }

  export type admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    where: admin_permission_logsWhereUniqueInput
    data: XOR<admin_permission_logsUpdateWithoutUsers_admin_permission_logs_modified_byTousersInput, admin_permission_logsUncheckedUpdateWithoutUsers_admin_permission_logs_modified_byTousersInput>
  }

  export type admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    where: admin_permission_logsScalarWhereInput
    data: XOR<admin_permission_logsUpdateManyMutationInput, admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersInput>
  }

  export type admin_permission_logsScalarWhereInput = {
    AND?: admin_permission_logsScalarWhereInput | admin_permission_logsScalarWhereInput[]
    OR?: admin_permission_logsScalarWhereInput[]
    NOT?: admin_permission_logsScalarWhereInput | admin_permission_logsScalarWhereInput[]
    id?: IntFilter<"admin_permission_logs"> | number
    user_id?: IntFilter<"admin_permission_logs"> | number
    modified_by?: IntFilter<"admin_permission_logs"> | number
    action?: StringFilter<"admin_permission_logs"> | string
    previous_role?: StringNullableFilter<"admin_permission_logs"> | string | null
    new_role?: StringNullableFilter<"admin_permission_logs"> | string | null
    action_date?: DateTimeFilter<"admin_permission_logs"> | Date | string
    notes?: StringNullableFilter<"admin_permission_logs"> | string | null
  }

  export type admin_permission_logsUpsertWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput = {
    where: admin_permission_logsWhereUniqueInput
    update: XOR<admin_permission_logsUpdateWithoutUsers_admin_permission_logs_user_idTousersInput, admin_permission_logsUncheckedUpdateWithoutUsers_admin_permission_logs_user_idTousersInput>
    create: XOR<admin_permission_logsCreateWithoutUsers_admin_permission_logs_user_idTousersInput, admin_permission_logsUncheckedCreateWithoutUsers_admin_permission_logs_user_idTousersInput>
  }

  export type admin_permission_logsUpdateWithWhereUniqueWithoutUsers_admin_permission_logs_user_idTousersInput = {
    where: admin_permission_logsWhereUniqueInput
    data: XOR<admin_permission_logsUpdateWithoutUsers_admin_permission_logs_user_idTousersInput, admin_permission_logsUncheckedUpdateWithoutUsers_admin_permission_logs_user_idTousersInput>
  }

  export type admin_permission_logsUpdateManyWithWhereWithoutUsers_admin_permission_logs_user_idTousersInput = {
    where: admin_permission_logsScalarWhereInput
    data: XOR<admin_permission_logsUpdateManyMutationInput, admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersInput>
  }

  export type admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput = {
    where: admin_permissionsWhereUniqueInput
    update: XOR<admin_permissionsUpdateWithoutUsers_admin_permissions_granted_byTousersInput, admin_permissionsUncheckedUpdateWithoutUsers_admin_permissions_granted_byTousersInput>
    create: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_granted_byTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_granted_byTousersInput>
  }

  export type admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_granted_byTousersInput = {
    where: admin_permissionsWhereUniqueInput
    data: XOR<admin_permissionsUpdateWithoutUsers_admin_permissions_granted_byTousersInput, admin_permissionsUncheckedUpdateWithoutUsers_admin_permissions_granted_byTousersInput>
  }

  export type admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_granted_byTousersInput = {
    where: admin_permissionsScalarWhereInput
    data: XOR<admin_permissionsUpdateManyMutationInput, admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersInput>
  }

  export type admin_permissionsScalarWhereInput = {
    AND?: admin_permissionsScalarWhereInput | admin_permissionsScalarWhereInput[]
    OR?: admin_permissionsScalarWhereInput[]
    NOT?: admin_permissionsScalarWhereInput | admin_permissionsScalarWhereInput[]
    id?: IntFilter<"admin_permissions"> | number
    user_id?: IntFilter<"admin_permissions"> | number
    granted_by?: IntFilter<"admin_permissions"> | number
    permission_level?: StringFilter<"admin_permissions"> | string
    granted_at?: DateTimeFilter<"admin_permissions"> | Date | string
    revoked_at?: DateTimeNullableFilter<"admin_permissions"> | Date | string | null
    is_active?: BoolFilter<"admin_permissions"> | boolean
  }

  export type admin_permissionsUpsertWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput = {
    where: admin_permissionsWhereUniqueInput
    update: XOR<admin_permissionsUpdateWithoutUsers_admin_permissions_user_idTousersInput, admin_permissionsUncheckedUpdateWithoutUsers_admin_permissions_user_idTousersInput>
    create: XOR<admin_permissionsCreateWithoutUsers_admin_permissions_user_idTousersInput, admin_permissionsUncheckedCreateWithoutUsers_admin_permissions_user_idTousersInput>
  }

  export type admin_permissionsUpdateWithWhereUniqueWithoutUsers_admin_permissions_user_idTousersInput = {
    where: admin_permissionsWhereUniqueInput
    data: XOR<admin_permissionsUpdateWithoutUsers_admin_permissions_user_idTousersInput, admin_permissionsUncheckedUpdateWithoutUsers_admin_permissions_user_idTousersInput>
  }

  export type admin_permissionsUpdateManyWithWhereWithoutUsers_admin_permissions_user_idTousersInput = {
    where: admin_permissionsScalarWhereInput
    data: XOR<admin_permissionsUpdateManyMutationInput, admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersInput>
  }

  export type AdminUpsertWithWhereUniqueWithoutUserInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutUserInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateManyWithWhereWithoutUserInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutUserInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: IntFilter<"Admin"> | number
    adminLevel?: StringFilter<"Admin"> | string
    userId?: IntFilter<"Admin"> | number
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type bootcamp_progressUpsertWithWhereUniqueWithoutUsersInput = {
    where: bootcamp_progressWhereUniqueInput
    update: XOR<bootcamp_progressUpdateWithoutUsersInput, bootcamp_progressUncheckedUpdateWithoutUsersInput>
    create: XOR<bootcamp_progressCreateWithoutUsersInput, bootcamp_progressUncheckedCreateWithoutUsersInput>
  }

  export type bootcamp_progressUpdateWithWhereUniqueWithoutUsersInput = {
    where: bootcamp_progressWhereUniqueInput
    data: XOR<bootcamp_progressUpdateWithoutUsersInput, bootcamp_progressUncheckedUpdateWithoutUsersInput>
  }

  export type bootcamp_progressUpdateManyWithWhereWithoutUsersInput = {
    where: bootcamp_progressScalarWhereInput
    data: XOR<bootcamp_progressUpdateManyMutationInput, bootcamp_progressUncheckedUpdateManyWithoutUsersInput>
  }

  export type bootcamp_progressScalarWhereInput = {
    AND?: bootcamp_progressScalarWhereInput | bootcamp_progressScalarWhereInput[]
    OR?: bootcamp_progressScalarWhereInput[]
    NOT?: bootcamp_progressScalarWhereInput | bootcamp_progressScalarWhereInput[]
    id?: UuidFilter<"bootcamp_progress"> | string
    user_id?: IntFilter<"bootcamp_progress"> | number
    bootcamp_id?: UuidFilter<"bootcamp_progress"> | string
    current_training_index?: IntNullableFilter<"bootcamp_progress"> | number | null
    progress_percentage?: DecimalNullableFilter<"bootcamp_progress"> | Decimal | DecimalJsLike | number | string | null
    last_activity?: DateTimeNullableFilter<"bootcamp_progress"> | Date | string | null
  }

  export type conference_attendeesUpsertWithWhereUniqueWithoutUsersInput = {
    where: conference_attendeesWhereUniqueInput
    update: XOR<conference_attendeesUpdateWithoutUsersInput, conference_attendeesUncheckedUpdateWithoutUsersInput>
    create: XOR<conference_attendeesCreateWithoutUsersInput, conference_attendeesUncheckedCreateWithoutUsersInput>
  }

  export type conference_attendeesUpdateWithWhereUniqueWithoutUsersInput = {
    where: conference_attendeesWhereUniqueInput
    data: XOR<conference_attendeesUpdateWithoutUsersInput, conference_attendeesUncheckedUpdateWithoutUsersInput>
  }

  export type conference_attendeesUpdateManyWithWhereWithoutUsersInput = {
    where: conference_attendeesScalarWhereInput
    data: XOR<conference_attendeesUpdateManyMutationInput, conference_attendeesUncheckedUpdateManyWithoutUsersInput>
  }

  export type conference_attendeesScalarWhereInput = {
    AND?: conference_attendeesScalarWhereInput | conference_attendeesScalarWhereInput[]
    OR?: conference_attendeesScalarWhereInput[]
    NOT?: conference_attendeesScalarWhereInput | conference_attendeesScalarWhereInput[]
    id?: UuidFilter<"conference_attendees"> | string
    conference_id?: UuidFilter<"conference_attendees"> | string
    user_id?: IntFilter<"conference_attendees"> | number
    registered_at?: DateTimeNullableFilter<"conference_attendees"> | Date | string | null
    attended?: BoolNullableFilter<"conference_attendees"> | boolean | null
    attendance_time?: DateTimeNullableFilter<"conference_attendees"> | Date | string | null
    notes?: StringNullableFilter<"conference_attendees"> | string | null
  }

  export type EmployeeUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutUserInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: IntFilter<"Employee"> | number
    telesetCardNo?: StringNullableFilter<"Employee"> | string | null
    userId?: IntFilter<"Employee"> | number
    departmentId?: IntNullableFilter<"Employee"> | number | null
    position?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type enrollmentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: enrollmentsWhereUniqueInput
    update: XOR<enrollmentsUpdateWithoutUsersInput, enrollmentsUncheckedUpdateWithoutUsersInput>
    create: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput>
  }

  export type enrollmentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: enrollmentsWhereUniqueInput
    data: XOR<enrollmentsUpdateWithoutUsersInput, enrollmentsUncheckedUpdateWithoutUsersInput>
  }

  export type enrollmentsUpdateManyWithWhereWithoutUsersInput = {
    where: enrollmentsScalarWhereInput
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type enrollmentsScalarWhereInput = {
    AND?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
    OR?: enrollmentsScalarWhereInput[]
    NOT?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
    id?: IntFilter<"enrollments"> | number
    user_id?: IntFilter<"enrollments"> | number
    training_id?: UuidFilter<"enrollments"> | string
    status?: StringFilter<"enrollments"> | string
    progress?: IntFilter<"enrollments"> | number
    completed_items?: JsonNullableFilter<"enrollments">
    score?: DecimalNullableFilter<"enrollments"> | Decimal | DecimalJsLike | number | string | null
    start_date?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    last_accessed_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    created_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
  }

  export type LogUpsertWithWhereUniqueWithoutUsersInput = {
    where: LogWhereUniqueInput
    update: XOR<LogUpdateWithoutUsersInput, LogUncheckedUpdateWithoutUsersInput>
    create: XOR<LogCreateWithoutUsersInput, LogUncheckedCreateWithoutUsersInput>
  }

  export type LogUpdateWithWhereUniqueWithoutUsersInput = {
    where: LogWhereUniqueInput
    data: XOR<LogUpdateWithoutUsersInput, LogUncheckedUpdateWithoutUsersInput>
  }

  export type LogUpdateManyWithWhereWithoutUsersInput = {
    where: LogScalarWhereInput
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyWithoutUsersInput>
  }

  export type LogScalarWhereInput = {
    AND?: LogScalarWhereInput | LogScalarWhereInput[]
    OR?: LogScalarWhereInput[]
    NOT?: LogScalarWhereInput | LogScalarWhereInput[]
    id?: IntFilter<"Log"> | number
    action_type?: StringFilter<"Log"> | string
    user_id?: IntNullableFilter<"Log"> | number | null
    ip_address?: StringNullableFilter<"Log"> | string | null
    user_agent?: StringNullableFilter<"Log"> | string | null
    created_at?: DateTimeFilter<"Log"> | Date | string
    details?: JsonNullableFilter<"Log">
    is_suspicious?: BoolNullableFilter<"Log"> | boolean | null
  }

  export type user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_bootcamp_assignmentsWhereUniqueInput
    update: XOR<user_bootcamp_assignmentsUpdateWithoutUsersInput, user_bootcamp_assignmentsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_bootcamp_assignmentsCreateWithoutUsersInput, user_bootcamp_assignmentsUncheckedCreateWithoutUsersInput>
  }

  export type user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_bootcamp_assignmentsWhereUniqueInput
    data: XOR<user_bootcamp_assignmentsUpdateWithoutUsersInput, user_bootcamp_assignmentsUncheckedUpdateWithoutUsersInput>
  }

  export type user_bootcamp_assignmentsUpdateManyWithWhereWithoutUsersInput = {
    where: user_bootcamp_assignmentsScalarWhereInput
    data: XOR<user_bootcamp_assignmentsUpdateManyMutationInput, user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_bootcamp_assignmentsScalarWhereInput = {
    AND?: user_bootcamp_assignmentsScalarWhereInput | user_bootcamp_assignmentsScalarWhereInput[]
    OR?: user_bootcamp_assignmentsScalarWhereInput[]
    NOT?: user_bootcamp_assignmentsScalarWhereInput | user_bootcamp_assignmentsScalarWhereInput[]
    id?: UuidFilter<"user_bootcamp_assignments"> | string
    user_id?: IntFilter<"user_bootcamp_assignments"> | number
    bootcamp_id?: UuidFilter<"user_bootcamp_assignments"> | string
    assigned_at?: DateTimeNullableFilter<"user_bootcamp_assignments"> | Date | string | null
    completed?: BoolNullableFilter<"user_bootcamp_assignments"> | boolean | null
    completion_date?: DateTimeNullableFilter<"user_bootcamp_assignments"> | Date | string | null
  }

  export type user_training_assignmentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_training_assignmentsWhereUniqueInput
    update: XOR<user_training_assignmentsUpdateWithoutUsersInput, user_training_assignmentsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_training_assignmentsCreateWithoutUsersInput, user_training_assignmentsUncheckedCreateWithoutUsersInput>
  }

  export type user_training_assignmentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_training_assignmentsWhereUniqueInput
    data: XOR<user_training_assignmentsUpdateWithoutUsersInput, user_training_assignmentsUncheckedUpdateWithoutUsersInput>
  }

  export type user_training_assignmentsUpdateManyWithWhereWithoutUsersInput = {
    where: user_training_assignmentsScalarWhereInput
    data: XOR<user_training_assignmentsUpdateManyMutationInput, user_training_assignmentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_training_assignmentsScalarWhereInput = {
    AND?: user_training_assignmentsScalarWhereInput | user_training_assignmentsScalarWhereInput[]
    OR?: user_training_assignmentsScalarWhereInput[]
    NOT?: user_training_assignmentsScalarWhereInput | user_training_assignmentsScalarWhereInput[]
    assignment_id?: IntFilter<"user_training_assignments"> | number
    user_id?: IntFilter<"user_training_assignments"> | number
    training_id?: UuidFilter<"user_training_assignments"> | string
    assigned_at?: DateTimeNullableFilter<"user_training_assignments"> | Date | string | null
  }

  export type user_training_progressUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_training_progressWhereUniqueInput
    update: XOR<user_training_progressUpdateWithoutUsersInput, user_training_progressUncheckedUpdateWithoutUsersInput>
    create: XOR<user_training_progressCreateWithoutUsersInput, user_training_progressUncheckedCreateWithoutUsersInput>
  }

  export type user_training_progressUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_training_progressWhereUniqueInput
    data: XOR<user_training_progressUpdateWithoutUsersInput, user_training_progressUncheckedUpdateWithoutUsersInput>
  }

  export type user_training_progressUpdateManyWithWhereWithoutUsersInput = {
    where: user_training_progressScalarWhereInput
    data: XOR<user_training_progressUpdateManyMutationInput, user_training_progressUncheckedUpdateManyWithoutUsersInput>
  }

  export type user_training_progressScalarWhereInput = {
    AND?: user_training_progressScalarWhereInput | user_training_progressScalarWhereInput[]
    OR?: user_training_progressScalarWhereInput[]
    NOT?: user_training_progressScalarWhereInput | user_training_progressScalarWhereInput[]
    user_id?: IntFilter<"user_training_progress"> | number
    bootcamp_id?: UuidNullableFilter<"user_training_progress"> | string | null
    training_id?: UuidFilter<"user_training_progress"> | string
    status?: StringFilter<"user_training_progress"> | string
    started_at?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
    progress_percentage?: DecimalFilter<"user_training_progress"> | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonFilter<"user_training_progress">
    completion_duration_seconds?: IntNullableFilter<"user_training_progress"> | number | null
    updatedAt?: DateTimeNullableFilter<"user_training_progress"> | Date | string | null
  }

  export type DepartmentCreateWithoutEmployeesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUncheckedCreateWithoutEmployeesInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateOrConnectWithoutEmployeesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutEmployeeInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type DepartmentUpsertWithoutEmployeesInput = {
    update: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutAdminInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    telesetCardNo?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: number
    telesetCardNo?: string | null
    userId: number
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: EmployeeCreateManyDepartmentInput | EmployeeCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type UserCreateWithoutLogsInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutLogsInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
  }

  export type UserUpsertWithoutLogsInput = {
    update: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
    create: XOR<UserCreateWithoutLogsInput, UserUncheckedCreateWithoutLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLogsInput, UserUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateWithoutLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput, UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput>
  }

  export type UserCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput, UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput>
  }

  export type UserUpsertWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput = {
    update: XOR<UserUpdateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput, UserUncheckedUpdateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput>
    create: XOR<UserCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput, UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput, UserUncheckedUpdateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput>
  }

  export type UserUpdateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUpsertWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput = {
    update: XOR<UserUpdateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput, UserUncheckedUpdateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput>
    create: XOR<UserCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput, UserUncheckedCreateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput, UserUncheckedUpdateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput>
  }

  export type UserUpdateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutAdmin_permissions_admin_permissions_granted_byTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput, UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput>
  }

  export type UserCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutAdmin_permissions_admin_permissions_user_idTousersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput, UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput>
  }

  export type UserUpsertWithoutAdmin_permissions_admin_permissions_granted_byTousersInput = {
    update: XOR<UserUpdateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput, UserUncheckedUpdateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput>
    create: XOR<UserCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput, UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdmin_permissions_admin_permissions_granted_byTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput, UserUncheckedUpdateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput>
  }

  export type UserUpdateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdmin_permissions_admin_permissions_granted_byTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUpsertWithoutAdmin_permissions_admin_permissions_user_idTousersInput = {
    update: XOR<UserUpdateWithoutAdmin_permissions_admin_permissions_user_idTousersInput, UserUncheckedUpdateWithoutAdmin_permissions_admin_permissions_user_idTousersInput>
    create: XOR<UserCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput, UserUncheckedCreateWithoutAdmin_permissions_admin_permissions_user_idTousersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdmin_permissions_admin_permissions_user_idTousersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdmin_permissions_admin_permissions_user_idTousersInput, UserUncheckedUpdateWithoutAdmin_permissions_admin_permissions_user_idTousersInput>
  }

  export type UserUpdateWithoutAdmin_permissions_admin_permissions_user_idTousersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAdmin_permissions_admin_permissions_user_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bootcampsCreateWithoutBootcamp_progressInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutBootcampsInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutBootcampsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsUncheckedCreateWithoutBootcamp_progressInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutBootcampsInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutBootcampsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsCreateOrConnectWithoutBootcamp_progressInput = {
    where: bootcampsWhereUniqueInput
    create: XOR<bootcampsCreateWithoutBootcamp_progressInput, bootcampsUncheckedCreateWithoutBootcamp_progressInput>
  }

  export type UserCreateWithoutBootcamp_progressInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutBootcamp_progressInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutBootcamp_progressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBootcamp_progressInput, UserUncheckedCreateWithoutBootcamp_progressInput>
  }

  export type bootcampsUpsertWithoutBootcamp_progressInput = {
    update: XOR<bootcampsUpdateWithoutBootcamp_progressInput, bootcampsUncheckedUpdateWithoutBootcamp_progressInput>
    create: XOR<bootcampsCreateWithoutBootcamp_progressInput, bootcampsUncheckedCreateWithoutBootcamp_progressInput>
    where?: bootcampsWhereInput
  }

  export type bootcampsUpdateToOneWithWhereWithoutBootcamp_progressInput = {
    where?: bootcampsWhereInput
    data: XOR<bootcampsUpdateWithoutBootcamp_progressInput, bootcampsUncheckedUpdateWithoutBootcamp_progressInput>
  }

  export type bootcampsUpdateWithoutBootcamp_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutBootcampsNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutBootcampsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutBootcampsNestedInput
  }

  export type bootcampsUncheckedUpdateWithoutBootcamp_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutBootcampsNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutBootcampsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutBootcampsNestedInput
  }

  export type UserUpsertWithoutBootcamp_progressInput = {
    update: XOR<UserUpdateWithoutBootcamp_progressInput, UserUncheckedUpdateWithoutBootcamp_progressInput>
    create: XOR<UserCreateWithoutBootcamp_progressInput, UserUncheckedCreateWithoutBootcamp_progressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBootcamp_progressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBootcamp_progressInput, UserUncheckedUpdateWithoutBootcamp_progressInput>
  }

  export type UserUpdateWithoutBootcamp_progressInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutBootcamp_progressInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bootcampsCreateWithoutBootcamp_trainingsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutBootcampsInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutBootcampsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsUncheckedCreateWithoutBootcamp_trainingsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutBootcampsInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutBootcampsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsCreateOrConnectWithoutBootcamp_trainingsInput = {
    where: bootcampsWhereUniqueInput
    create: XOR<bootcampsCreateWithoutBootcamp_trainingsInput, bootcampsUncheckedCreateWithoutBootcamp_trainingsInput>
  }

  export type trainingsCreateWithoutBootcamp_trainingsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    enrollments?: enrollmentsCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsUncheckedCreateWithoutBootcamp_trainingsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesUncheckedCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsCreateOrConnectWithoutBootcamp_trainingsInput = {
    where: trainingsWhereUniqueInput
    create: XOR<trainingsCreateWithoutBootcamp_trainingsInput, trainingsUncheckedCreateWithoutBootcamp_trainingsInput>
  }

  export type bootcampsUpsertWithoutBootcamp_trainingsInput = {
    update: XOR<bootcampsUpdateWithoutBootcamp_trainingsInput, bootcampsUncheckedUpdateWithoutBootcamp_trainingsInput>
    create: XOR<bootcampsCreateWithoutBootcamp_trainingsInput, bootcampsUncheckedCreateWithoutBootcamp_trainingsInput>
    where?: bootcampsWhereInput
  }

  export type bootcampsUpdateToOneWithWhereWithoutBootcamp_trainingsInput = {
    where?: bootcampsWhereInput
    data: XOR<bootcampsUpdateWithoutBootcamp_trainingsInput, bootcampsUncheckedUpdateWithoutBootcamp_trainingsInput>
  }

  export type bootcampsUpdateWithoutBootcamp_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutBootcampsNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutBootcampsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutBootcampsNestedInput
  }

  export type bootcampsUncheckedUpdateWithoutBootcamp_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutBootcampsNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutBootcampsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutBootcampsNestedInput
  }

  export type trainingsUpsertWithoutBootcamp_trainingsInput = {
    update: XOR<trainingsUpdateWithoutBootcamp_trainingsInput, trainingsUncheckedUpdateWithoutBootcamp_trainingsInput>
    create: XOR<trainingsCreateWithoutBootcamp_trainingsInput, trainingsUncheckedCreateWithoutBootcamp_trainingsInput>
    where?: trainingsWhereInput
  }

  export type trainingsUpdateToOneWithWhereWithoutBootcamp_trainingsInput = {
    where?: trainingsWhereInput
    data: XOR<trainingsUpdateWithoutBootcamp_trainingsInput, trainingsUncheckedUpdateWithoutBootcamp_trainingsInput>
  }

  export type trainingsUpdateWithoutBootcamp_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enrollments?: enrollmentsUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsUncheckedUpdateWithoutBootcamp_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    enrollments?: enrollmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUncheckedUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutTrainingsNestedInput
  }

  export type bootcamp_progressCreateWithoutBootcampsInput = {
    id?: string
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
    users: UserCreateNestedOneWithoutBootcamp_progressInput
  }

  export type bootcamp_progressUncheckedCreateWithoutBootcampsInput = {
    id?: string
    user_id: number
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
  }

  export type bootcamp_progressCreateOrConnectWithoutBootcampsInput = {
    where: bootcamp_progressWhereUniqueInput
    create: XOR<bootcamp_progressCreateWithoutBootcampsInput, bootcamp_progressUncheckedCreateWithoutBootcampsInput>
  }

  export type bootcamp_progressCreateManyBootcampsInputEnvelope = {
    data: bootcamp_progressCreateManyBootcampsInput | bootcamp_progressCreateManyBootcampsInput[]
    skipDuplicates?: boolean
  }

  export type bootcamp_trainingsCreateWithoutBootcampsInput = {
    id?: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
    trainings: trainingsCreateNestedOneWithoutBootcamp_trainingsInput
  }

  export type bootcamp_trainingsUncheckedCreateWithoutBootcampsInput = {
    id?: string
    training_id: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
  }

  export type bootcamp_trainingsCreateOrConnectWithoutBootcampsInput = {
    where: bootcamp_trainingsWhereUniqueInput
    create: XOR<bootcamp_trainingsCreateWithoutBootcampsInput, bootcamp_trainingsUncheckedCreateWithoutBootcampsInput>
  }

  export type bootcamp_trainingsCreateManyBootcampsInputEnvelope = {
    data: bootcamp_trainingsCreateManyBootcampsInput | bootcamp_trainingsCreateManyBootcampsInput[]
    skipDuplicates?: boolean
  }

  export type user_bootcamp_assignmentsCreateWithoutBootcampsInput = {
    id?: string
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
    users: UserCreateNestedOneWithoutUser_bootcamp_assignmentsInput
  }

  export type user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput = {
    id?: string
    user_id: number
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
  }

  export type user_bootcamp_assignmentsCreateOrConnectWithoutBootcampsInput = {
    where: user_bootcamp_assignmentsWhereUniqueInput
    create: XOR<user_bootcamp_assignmentsCreateWithoutBootcampsInput, user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput>
  }

  export type user_bootcamp_assignmentsCreateManyBootcampsInputEnvelope = {
    data: user_bootcamp_assignmentsCreateManyBootcampsInput | user_bootcamp_assignmentsCreateManyBootcampsInput[]
    skipDuplicates?: boolean
  }

  export type user_training_progressCreateWithoutBootcampsInput = {
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
    trainings: trainingsCreateNestedOneWithoutUser_training_progressInput
    users: UserCreateNestedOneWithoutUser_training_progressInput
  }

  export type user_training_progressUncheckedCreateWithoutBootcampsInput = {
    user_id: number
    training_id: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
  }

  export type user_training_progressCreateOrConnectWithoutBootcampsInput = {
    where: user_training_progressWhereUniqueInput
    create: XOR<user_training_progressCreateWithoutBootcampsInput, user_training_progressUncheckedCreateWithoutBootcampsInput>
  }

  export type user_training_progressCreateManyBootcampsInputEnvelope = {
    data: user_training_progressCreateManyBootcampsInput | user_training_progressCreateManyBootcampsInput[]
    skipDuplicates?: boolean
  }

  export type bootcamp_progressUpsertWithWhereUniqueWithoutBootcampsInput = {
    where: bootcamp_progressWhereUniqueInput
    update: XOR<bootcamp_progressUpdateWithoutBootcampsInput, bootcamp_progressUncheckedUpdateWithoutBootcampsInput>
    create: XOR<bootcamp_progressCreateWithoutBootcampsInput, bootcamp_progressUncheckedCreateWithoutBootcampsInput>
  }

  export type bootcamp_progressUpdateWithWhereUniqueWithoutBootcampsInput = {
    where: bootcamp_progressWhereUniqueInput
    data: XOR<bootcamp_progressUpdateWithoutBootcampsInput, bootcamp_progressUncheckedUpdateWithoutBootcampsInput>
  }

  export type bootcamp_progressUpdateManyWithWhereWithoutBootcampsInput = {
    where: bootcamp_progressScalarWhereInput
    data: XOR<bootcamp_progressUpdateManyMutationInput, bootcamp_progressUncheckedUpdateManyWithoutBootcampsInput>
  }

  export type bootcamp_trainingsUpsertWithWhereUniqueWithoutBootcampsInput = {
    where: bootcamp_trainingsWhereUniqueInput
    update: XOR<bootcamp_trainingsUpdateWithoutBootcampsInput, bootcamp_trainingsUncheckedUpdateWithoutBootcampsInput>
    create: XOR<bootcamp_trainingsCreateWithoutBootcampsInput, bootcamp_trainingsUncheckedCreateWithoutBootcampsInput>
  }

  export type bootcamp_trainingsUpdateWithWhereUniqueWithoutBootcampsInput = {
    where: bootcamp_trainingsWhereUniqueInput
    data: XOR<bootcamp_trainingsUpdateWithoutBootcampsInput, bootcamp_trainingsUncheckedUpdateWithoutBootcampsInput>
  }

  export type bootcamp_trainingsUpdateManyWithWhereWithoutBootcampsInput = {
    where: bootcamp_trainingsScalarWhereInput
    data: XOR<bootcamp_trainingsUpdateManyMutationInput, bootcamp_trainingsUncheckedUpdateManyWithoutBootcampsInput>
  }

  export type bootcamp_trainingsScalarWhereInput = {
    AND?: bootcamp_trainingsScalarWhereInput | bootcamp_trainingsScalarWhereInput[]
    OR?: bootcamp_trainingsScalarWhereInput[]
    NOT?: bootcamp_trainingsScalarWhereInput | bootcamp_trainingsScalarWhereInput[]
    id?: UuidFilter<"bootcamp_trainings"> | string
    bootcamp_id?: UuidFilter<"bootcamp_trainings"> | string
    training_id?: UuidFilter<"bootcamp_trainings"> | string
    order_index?: IntFilter<"bootcamp_trainings"> | number
    required?: BoolNullableFilter<"bootcamp_trainings"> | boolean | null
    created_at?: DateTimeNullableFilter<"bootcamp_trainings"> | Date | string | null
  }

  export type user_bootcamp_assignmentsUpsertWithWhereUniqueWithoutBootcampsInput = {
    where: user_bootcamp_assignmentsWhereUniqueInput
    update: XOR<user_bootcamp_assignmentsUpdateWithoutBootcampsInput, user_bootcamp_assignmentsUncheckedUpdateWithoutBootcampsInput>
    create: XOR<user_bootcamp_assignmentsCreateWithoutBootcampsInput, user_bootcamp_assignmentsUncheckedCreateWithoutBootcampsInput>
  }

  export type user_bootcamp_assignmentsUpdateWithWhereUniqueWithoutBootcampsInput = {
    where: user_bootcamp_assignmentsWhereUniqueInput
    data: XOR<user_bootcamp_assignmentsUpdateWithoutBootcampsInput, user_bootcamp_assignmentsUncheckedUpdateWithoutBootcampsInput>
  }

  export type user_bootcamp_assignmentsUpdateManyWithWhereWithoutBootcampsInput = {
    where: user_bootcamp_assignmentsScalarWhereInput
    data: XOR<user_bootcamp_assignmentsUpdateManyMutationInput, user_bootcamp_assignmentsUncheckedUpdateManyWithoutBootcampsInput>
  }

  export type user_training_progressUpsertWithWhereUniqueWithoutBootcampsInput = {
    where: user_training_progressWhereUniqueInput
    update: XOR<user_training_progressUpdateWithoutBootcampsInput, user_training_progressUncheckedUpdateWithoutBootcampsInput>
    create: XOR<user_training_progressCreateWithoutBootcampsInput, user_training_progressUncheckedCreateWithoutBootcampsInput>
  }

  export type user_training_progressUpdateWithWhereUniqueWithoutBootcampsInput = {
    where: user_training_progressWhereUniqueInput
    data: XOR<user_training_progressUpdateWithoutBootcampsInput, user_training_progressUncheckedUpdateWithoutBootcampsInput>
  }

  export type user_training_progressUpdateManyWithWhereWithoutBootcampsInput = {
    where: user_training_progressScalarWhereInput
    data: XOR<user_training_progressUpdateManyMutationInput, user_training_progressUncheckedUpdateManyWithoutBootcampsInput>
  }

  export type conference_trainingsCreateWithoutConference_attendeesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    location: string
    start_date: Date | string
    end_date: Date | string
    capacity?: number | null
    author?: string | null
    published?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    conference_materials?: conference_materialsCreateNestedManyWithoutConference_trainingsInput
  }

  export type conference_trainingsUncheckedCreateWithoutConference_attendeesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    location: string
    start_date: Date | string
    end_date: Date | string
    capacity?: number | null
    author?: string | null
    published?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    conference_materials?: conference_materialsUncheckedCreateNestedManyWithoutConference_trainingsInput
  }

  export type conference_trainingsCreateOrConnectWithoutConference_attendeesInput = {
    where: conference_trainingsWhereUniqueInput
    create: XOR<conference_trainingsCreateWithoutConference_attendeesInput, conference_trainingsUncheckedCreateWithoutConference_attendeesInput>
  }

  export type UserCreateWithoutConference_attendeesInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutConference_attendeesInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutConference_attendeesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConference_attendeesInput, UserUncheckedCreateWithoutConference_attendeesInput>
  }

  export type conference_trainingsUpsertWithoutConference_attendeesInput = {
    update: XOR<conference_trainingsUpdateWithoutConference_attendeesInput, conference_trainingsUncheckedUpdateWithoutConference_attendeesInput>
    create: XOR<conference_trainingsCreateWithoutConference_attendeesInput, conference_trainingsUncheckedCreateWithoutConference_attendeesInput>
    where?: conference_trainingsWhereInput
  }

  export type conference_trainingsUpdateToOneWithWhereWithoutConference_attendeesInput = {
    where?: conference_trainingsWhereInput
    data: XOR<conference_trainingsUpdateWithoutConference_attendeesInput, conference_trainingsUncheckedUpdateWithoutConference_attendeesInput>
  }

  export type conference_trainingsUpdateWithoutConference_attendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conference_materials?: conference_materialsUpdateManyWithoutConference_trainingsNestedInput
  }

  export type conference_trainingsUncheckedUpdateWithoutConference_attendeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conference_materials?: conference_materialsUncheckedUpdateManyWithoutConference_trainingsNestedInput
  }

  export type UserUpsertWithoutConference_attendeesInput = {
    update: XOR<UserUpdateWithoutConference_attendeesInput, UserUncheckedUpdateWithoutConference_attendeesInput>
    create: XOR<UserCreateWithoutConference_attendeesInput, UserUncheckedCreateWithoutConference_attendeesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConference_attendeesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConference_attendeesInput, UserUncheckedUpdateWithoutConference_attendeesInput>
  }

  export type UserUpdateWithoutConference_attendeesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutConference_attendeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type conference_trainingsCreateWithoutConference_materialsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    location: string
    start_date: Date | string
    end_date: Date | string
    capacity?: number | null
    author?: string | null
    published?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    conference_attendees?: conference_attendeesCreateNestedManyWithoutConference_trainingsInput
  }

  export type conference_trainingsUncheckedCreateWithoutConference_materialsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    location: string
    start_date: Date | string
    end_date: Date | string
    capacity?: number | null
    author?: string | null
    published?: boolean | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutConference_trainingsInput
  }

  export type conference_trainingsCreateOrConnectWithoutConference_materialsInput = {
    where: conference_trainingsWhereUniqueInput
    create: XOR<conference_trainingsCreateWithoutConference_materialsInput, conference_trainingsUncheckedCreateWithoutConference_materialsInput>
  }

  export type conference_trainingsUpsertWithoutConference_materialsInput = {
    update: XOR<conference_trainingsUpdateWithoutConference_materialsInput, conference_trainingsUncheckedUpdateWithoutConference_materialsInput>
    create: XOR<conference_trainingsCreateWithoutConference_materialsInput, conference_trainingsUncheckedCreateWithoutConference_materialsInput>
    where?: conference_trainingsWhereInput
  }

  export type conference_trainingsUpdateToOneWithWhereWithoutConference_materialsInput = {
    where?: conference_trainingsWhereInput
    data: XOR<conference_trainingsUpdateWithoutConference_materialsInput, conference_trainingsUncheckedUpdateWithoutConference_materialsInput>
  }

  export type conference_trainingsUpdateWithoutConference_materialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conference_attendees?: conference_attendeesUpdateManyWithoutConference_trainingsNestedInput
  }

  export type conference_trainingsUncheckedUpdateWithoutConference_materialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutConference_trainingsNestedInput
  }

  export type conference_attendeesCreateWithoutConference_trainingsInput = {
    id?: string
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
    users: UserCreateNestedOneWithoutConference_attendeesInput
  }

  export type conference_attendeesUncheckedCreateWithoutConference_trainingsInput = {
    id?: string
    user_id: number
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
  }

  export type conference_attendeesCreateOrConnectWithoutConference_trainingsInput = {
    where: conference_attendeesWhereUniqueInput
    create: XOR<conference_attendeesCreateWithoutConference_trainingsInput, conference_attendeesUncheckedCreateWithoutConference_trainingsInput>
  }

  export type conference_attendeesCreateManyConference_trainingsInputEnvelope = {
    data: conference_attendeesCreateManyConference_trainingsInput | conference_attendeesCreateManyConference_trainingsInput[]
    skipDuplicates?: boolean
  }

  export type conference_materialsCreateWithoutConference_trainingsInput = {
    id?: string
    title: string
    description?: string | null
    file_path?: string | null
    link?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type conference_materialsUncheckedCreateWithoutConference_trainingsInput = {
    id?: string
    title: string
    description?: string | null
    file_path?: string | null
    link?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type conference_materialsCreateOrConnectWithoutConference_trainingsInput = {
    where: conference_materialsWhereUniqueInput
    create: XOR<conference_materialsCreateWithoutConference_trainingsInput, conference_materialsUncheckedCreateWithoutConference_trainingsInput>
  }

  export type conference_materialsCreateManyConference_trainingsInputEnvelope = {
    data: conference_materialsCreateManyConference_trainingsInput | conference_materialsCreateManyConference_trainingsInput[]
    skipDuplicates?: boolean
  }

  export type conference_attendeesUpsertWithWhereUniqueWithoutConference_trainingsInput = {
    where: conference_attendeesWhereUniqueInput
    update: XOR<conference_attendeesUpdateWithoutConference_trainingsInput, conference_attendeesUncheckedUpdateWithoutConference_trainingsInput>
    create: XOR<conference_attendeesCreateWithoutConference_trainingsInput, conference_attendeesUncheckedCreateWithoutConference_trainingsInput>
  }

  export type conference_attendeesUpdateWithWhereUniqueWithoutConference_trainingsInput = {
    where: conference_attendeesWhereUniqueInput
    data: XOR<conference_attendeesUpdateWithoutConference_trainingsInput, conference_attendeesUncheckedUpdateWithoutConference_trainingsInput>
  }

  export type conference_attendeesUpdateManyWithWhereWithoutConference_trainingsInput = {
    where: conference_attendeesScalarWhereInput
    data: XOR<conference_attendeesUpdateManyMutationInput, conference_attendeesUncheckedUpdateManyWithoutConference_trainingsInput>
  }

  export type conference_materialsUpsertWithWhereUniqueWithoutConference_trainingsInput = {
    where: conference_materialsWhereUniqueInput
    update: XOR<conference_materialsUpdateWithoutConference_trainingsInput, conference_materialsUncheckedUpdateWithoutConference_trainingsInput>
    create: XOR<conference_materialsCreateWithoutConference_trainingsInput, conference_materialsUncheckedCreateWithoutConference_trainingsInput>
  }

  export type conference_materialsUpdateWithWhereUniqueWithoutConference_trainingsInput = {
    where: conference_materialsWhereUniqueInput
    data: XOR<conference_materialsUpdateWithoutConference_trainingsInput, conference_materialsUncheckedUpdateWithoutConference_trainingsInput>
  }

  export type conference_materialsUpdateManyWithWhereWithoutConference_trainingsInput = {
    where: conference_materialsScalarWhereInput
    data: XOR<conference_materialsUpdateManyMutationInput, conference_materialsUncheckedUpdateManyWithoutConference_trainingsInput>
  }

  export type conference_materialsScalarWhereInput = {
    AND?: conference_materialsScalarWhereInput | conference_materialsScalarWhereInput[]
    OR?: conference_materialsScalarWhereInput[]
    NOT?: conference_materialsScalarWhereInput | conference_materialsScalarWhereInput[]
    id?: UuidFilter<"conference_materials"> | string
    conference_id?: UuidFilter<"conference_materials"> | string
    title?: StringFilter<"conference_materials"> | string
    description?: StringNullableFilter<"conference_materials"> | string | null
    file_path?: StringNullableFilter<"conference_materials"> | string | null
    link?: StringNullableFilter<"conference_materials"> | string | null
    created_at?: DateTimeNullableFilter<"conference_materials"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"conference_materials"> | Date | string | null
  }

  export type trainingsCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesUncheckedCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsCreateOrConnectWithoutEnrollmentsInput = {
    where: trainingsWhereUniqueInput
    create: XOR<trainingsCreateWithoutEnrollmentsInput, trainingsUncheckedCreateWithoutEnrollmentsInput>
  }

  export type UserCreateWithoutEnrollmentsInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutEnrollmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
  }

  export type trainingsUpsertWithoutEnrollmentsInput = {
    update: XOR<trainingsUpdateWithoutEnrollmentsInput, trainingsUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<trainingsCreateWithoutEnrollmentsInput, trainingsUncheckedCreateWithoutEnrollmentsInput>
    where?: trainingsWhereInput
  }

  export type trainingsUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: trainingsWhereInput
    data: XOR<trainingsUpdateWithoutEnrollmentsInput, trainingsUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type trainingsUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUncheckedUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutTrainingsNestedInput
  }

  export type UserUpsertWithoutEnrollmentsInput = {
    update: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<UserCreateWithoutEnrollmentsInput, UserUncheckedCreateWithoutEnrollmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEnrollmentsInput, UserUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type UserUpdateWithoutEnrollmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type quizzesCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    pass_threshold?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    trainings?: trainingsCreateNestedOneWithoutQuizzesInput
  }

  export type quizzesUncheckedCreateWithoutQuestionsInput = {
    id?: string
    training_id?: string | null
    title: string
    description?: string | null
    pass_threshold?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type quizzesCreateOrConnectWithoutQuestionsInput = {
    where: quizzesWhereUniqueInput
    create: XOR<quizzesCreateWithoutQuestionsInput, quizzesUncheckedCreateWithoutQuestionsInput>
  }

  export type quizzesUpsertWithoutQuestionsInput = {
    update: XOR<quizzesUpdateWithoutQuestionsInput, quizzesUncheckedUpdateWithoutQuestionsInput>
    create: XOR<quizzesCreateWithoutQuestionsInput, quizzesUncheckedCreateWithoutQuestionsInput>
    where?: quizzesWhereInput
  }

  export type quizzesUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: quizzesWhereInput
    data: XOR<quizzesUpdateWithoutQuestionsInput, quizzesUncheckedUpdateWithoutQuestionsInput>
  }

  export type quizzesUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainings?: trainingsUpdateOneWithoutQuizzesNestedInput
  }

  export type quizzesUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_id?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsCreateWithoutQuizzesInput = {
    id?: string
    question_text: string
    question_type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    points?: number | null
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type questionsUncheckedCreateWithoutQuizzesInput = {
    id?: string
    question_text: string
    question_type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    points?: number | null
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type questionsCreateOrConnectWithoutQuizzesInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutQuizzesInput, questionsUncheckedCreateWithoutQuizzesInput>
  }

  export type questionsCreateManyQuizzesInputEnvelope = {
    data: questionsCreateManyQuizzesInput | questionsCreateManyQuizzesInput[]
    skipDuplicates?: boolean
  }

  export type trainingsCreateWithoutQuizzesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsUncheckedCreateWithoutQuizzesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsCreateOrConnectWithoutQuizzesInput = {
    where: trainingsWhereUniqueInput
    create: XOR<trainingsCreateWithoutQuizzesInput, trainingsUncheckedCreateWithoutQuizzesInput>
  }

  export type questionsUpsertWithWhereUniqueWithoutQuizzesInput = {
    where: questionsWhereUniqueInput
    update: XOR<questionsUpdateWithoutQuizzesInput, questionsUncheckedUpdateWithoutQuizzesInput>
    create: XOR<questionsCreateWithoutQuizzesInput, questionsUncheckedCreateWithoutQuizzesInput>
  }

  export type questionsUpdateWithWhereUniqueWithoutQuizzesInput = {
    where: questionsWhereUniqueInput
    data: XOR<questionsUpdateWithoutQuizzesInput, questionsUncheckedUpdateWithoutQuizzesInput>
  }

  export type questionsUpdateManyWithWhereWithoutQuizzesInput = {
    where: questionsScalarWhereInput
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type questionsScalarWhereInput = {
    AND?: questionsScalarWhereInput | questionsScalarWhereInput[]
    OR?: questionsScalarWhereInput[]
    NOT?: questionsScalarWhereInput | questionsScalarWhereInput[]
    id?: UuidFilter<"questions"> | string
    quiz_id?: UuidFilter<"questions"> | string
    question_text?: StringFilter<"questions"> | string
    question_type?: StringFilter<"questions"> | string
    options?: JsonNullableFilter<"questions">
    correct_answer?: JsonFilter<"questions">
    points?: IntNullableFilter<"questions"> | number | null
    order_index?: IntFilter<"questions"> | number
    createdAt?: DateTimeNullableFilter<"questions"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"questions"> | Date | string | null
  }

  export type trainingsUpsertWithoutQuizzesInput = {
    update: XOR<trainingsUpdateWithoutQuizzesInput, trainingsUncheckedUpdateWithoutQuizzesInput>
    create: XOR<trainingsCreateWithoutQuizzesInput, trainingsUncheckedCreateWithoutQuizzesInput>
    where?: trainingsWhereInput
  }

  export type trainingsUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: trainingsWhereInput
    data: XOR<trainingsUpdateWithoutQuizzesInput, trainingsUncheckedUpdateWithoutQuizzesInput>
  }

  export type trainingsUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsCreateWithoutTraining_contentInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsUncheckedCreateWithoutTraining_contentInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsCreateOrConnectWithoutTraining_contentInput = {
    where: trainingsWhereUniqueInput
    create: XOR<trainingsCreateWithoutTraining_contentInput, trainingsUncheckedCreateWithoutTraining_contentInput>
  }

  export type trainingsUpsertWithoutTraining_contentInput = {
    update: XOR<trainingsUpdateWithoutTraining_contentInput, trainingsUncheckedUpdateWithoutTraining_contentInput>
    create: XOR<trainingsCreateWithoutTraining_contentInput, trainingsUncheckedCreateWithoutTraining_contentInput>
    where?: trainingsWhereInput
  }

  export type trainingsUpdateToOneWithWhereWithoutTraining_contentInput = {
    where?: trainingsWhereInput
    data: XOR<trainingsUpdateWithoutTraining_contentInput, trainingsUncheckedUpdateWithoutTraining_contentInput>
  }

  export type trainingsUpdateWithoutTraining_contentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsUncheckedUpdateWithoutTraining_contentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutTrainingsNestedInput
  }

  export type bootcamp_trainingsCreateWithoutTrainingsInput = {
    id?: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
    bootcamps: bootcampsCreateNestedOneWithoutBootcamp_trainingsInput
  }

  export type bootcamp_trainingsUncheckedCreateWithoutTrainingsInput = {
    id?: string
    bootcamp_id: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
  }

  export type bootcamp_trainingsCreateOrConnectWithoutTrainingsInput = {
    where: bootcamp_trainingsWhereUniqueInput
    create: XOR<bootcamp_trainingsCreateWithoutTrainingsInput, bootcamp_trainingsUncheckedCreateWithoutTrainingsInput>
  }

  export type bootcamp_trainingsCreateManyTrainingsInputEnvelope = {
    data: bootcamp_trainingsCreateManyTrainingsInput | bootcamp_trainingsCreateManyTrainingsInput[]
    skipDuplicates?: boolean
  }

  export type enrollmentsCreateWithoutTrainingsInput = {
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    users: UserCreateNestedOneWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateWithoutTrainingsInput = {
    id?: number
    user_id: number
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type enrollmentsCreateOrConnectWithoutTrainingsInput = {
    where: enrollmentsWhereUniqueInput
    create: XOR<enrollmentsCreateWithoutTrainingsInput, enrollmentsUncheckedCreateWithoutTrainingsInput>
  }

  export type enrollmentsCreateManyTrainingsInputEnvelope = {
    data: enrollmentsCreateManyTrainingsInput | enrollmentsCreateManyTrainingsInput[]
    skipDuplicates?: boolean
  }

  export type quizzesCreateWithoutTrainingsInput = {
    id?: string
    title: string
    description?: string | null
    pass_threshold?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    questions?: questionsCreateNestedManyWithoutQuizzesInput
  }

  export type quizzesUncheckedCreateWithoutTrainingsInput = {
    id?: string
    title: string
    description?: string | null
    pass_threshold?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    questions?: questionsUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type quizzesCreateOrConnectWithoutTrainingsInput = {
    where: quizzesWhereUniqueInput
    create: XOR<quizzesCreateWithoutTrainingsInput, quizzesUncheckedCreateWithoutTrainingsInput>
  }

  export type quizzesCreateManyTrainingsInputEnvelope = {
    data: quizzesCreateManyTrainingsInput | quizzesCreateManyTrainingsInput[]
    skipDuplicates?: boolean
  }

  export type training_contentCreateWithoutTrainingsInput = {
    id?: string
    title: string
    content_type: string
    content_value: string
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type training_contentUncheckedCreateWithoutTrainingsInput = {
    id?: string
    title: string
    content_type: string
    content_value: string
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type training_contentCreateOrConnectWithoutTrainingsInput = {
    where: training_contentWhereUniqueInput
    create: XOR<training_contentCreateWithoutTrainingsInput, training_contentUncheckedCreateWithoutTrainingsInput>
  }

  export type training_contentCreateManyTrainingsInputEnvelope = {
    data: training_contentCreateManyTrainingsInput | training_contentCreateManyTrainingsInput[]
    skipDuplicates?: boolean
  }

  export type user_training_assignmentsCreateWithoutTrainingsInput = {
    assigned_at?: Date | string | null
    users: UserCreateNestedOneWithoutUser_training_assignmentsInput
  }

  export type user_training_assignmentsUncheckedCreateWithoutTrainingsInput = {
    assignment_id?: number
    user_id: number
    assigned_at?: Date | string | null
  }

  export type user_training_assignmentsCreateOrConnectWithoutTrainingsInput = {
    where: user_training_assignmentsWhereUniqueInput
    create: XOR<user_training_assignmentsCreateWithoutTrainingsInput, user_training_assignmentsUncheckedCreateWithoutTrainingsInput>
  }

  export type user_training_assignmentsCreateManyTrainingsInputEnvelope = {
    data: user_training_assignmentsCreateManyTrainingsInput | user_training_assignmentsCreateManyTrainingsInput[]
    skipDuplicates?: boolean
  }

  export type user_training_progressCreateWithoutTrainingsInput = {
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
    bootcamps?: bootcampsCreateNestedOneWithoutUser_training_progressInput
    users: UserCreateNestedOneWithoutUser_training_progressInput
  }

  export type user_training_progressUncheckedCreateWithoutTrainingsInput = {
    user_id: number
    bootcamp_id?: string | null
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
  }

  export type user_training_progressCreateOrConnectWithoutTrainingsInput = {
    where: user_training_progressWhereUniqueInput
    create: XOR<user_training_progressCreateWithoutTrainingsInput, user_training_progressUncheckedCreateWithoutTrainingsInput>
  }

  export type user_training_progressCreateManyTrainingsInputEnvelope = {
    data: user_training_progressCreateManyTrainingsInput | user_training_progressCreateManyTrainingsInput[]
    skipDuplicates?: boolean
  }

  export type bootcamp_trainingsUpsertWithWhereUniqueWithoutTrainingsInput = {
    where: bootcamp_trainingsWhereUniqueInput
    update: XOR<bootcamp_trainingsUpdateWithoutTrainingsInput, bootcamp_trainingsUncheckedUpdateWithoutTrainingsInput>
    create: XOR<bootcamp_trainingsCreateWithoutTrainingsInput, bootcamp_trainingsUncheckedCreateWithoutTrainingsInput>
  }

  export type bootcamp_trainingsUpdateWithWhereUniqueWithoutTrainingsInput = {
    where: bootcamp_trainingsWhereUniqueInput
    data: XOR<bootcamp_trainingsUpdateWithoutTrainingsInput, bootcamp_trainingsUncheckedUpdateWithoutTrainingsInput>
  }

  export type bootcamp_trainingsUpdateManyWithWhereWithoutTrainingsInput = {
    where: bootcamp_trainingsScalarWhereInput
    data: XOR<bootcamp_trainingsUpdateManyMutationInput, bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsInput>
  }

  export type enrollmentsUpsertWithWhereUniqueWithoutTrainingsInput = {
    where: enrollmentsWhereUniqueInput
    update: XOR<enrollmentsUpdateWithoutTrainingsInput, enrollmentsUncheckedUpdateWithoutTrainingsInput>
    create: XOR<enrollmentsCreateWithoutTrainingsInput, enrollmentsUncheckedCreateWithoutTrainingsInput>
  }

  export type enrollmentsUpdateWithWhereUniqueWithoutTrainingsInput = {
    where: enrollmentsWhereUniqueInput
    data: XOR<enrollmentsUpdateWithoutTrainingsInput, enrollmentsUncheckedUpdateWithoutTrainingsInput>
  }

  export type enrollmentsUpdateManyWithWhereWithoutTrainingsInput = {
    where: enrollmentsScalarWhereInput
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyWithoutTrainingsInput>
  }

  export type quizzesUpsertWithWhereUniqueWithoutTrainingsInput = {
    where: quizzesWhereUniqueInput
    update: XOR<quizzesUpdateWithoutTrainingsInput, quizzesUncheckedUpdateWithoutTrainingsInput>
    create: XOR<quizzesCreateWithoutTrainingsInput, quizzesUncheckedCreateWithoutTrainingsInput>
  }

  export type quizzesUpdateWithWhereUniqueWithoutTrainingsInput = {
    where: quizzesWhereUniqueInput
    data: XOR<quizzesUpdateWithoutTrainingsInput, quizzesUncheckedUpdateWithoutTrainingsInput>
  }

  export type quizzesUpdateManyWithWhereWithoutTrainingsInput = {
    where: quizzesScalarWhereInput
    data: XOR<quizzesUpdateManyMutationInput, quizzesUncheckedUpdateManyWithoutTrainingsInput>
  }

  export type quizzesScalarWhereInput = {
    AND?: quizzesScalarWhereInput | quizzesScalarWhereInput[]
    OR?: quizzesScalarWhereInput[]
    NOT?: quizzesScalarWhereInput | quizzesScalarWhereInput[]
    id?: UuidFilter<"quizzes"> | string
    training_id?: UuidNullableFilter<"quizzes"> | string | null
    title?: StringFilter<"quizzes"> | string
    description?: StringNullableFilter<"quizzes"> | string | null
    pass_threshold?: DecimalNullableFilter<"quizzes"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeNullableFilter<"quizzes"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"quizzes"> | Date | string | null
  }

  export type training_contentUpsertWithWhereUniqueWithoutTrainingsInput = {
    where: training_contentWhereUniqueInput
    update: XOR<training_contentUpdateWithoutTrainingsInput, training_contentUncheckedUpdateWithoutTrainingsInput>
    create: XOR<training_contentCreateWithoutTrainingsInput, training_contentUncheckedCreateWithoutTrainingsInput>
  }

  export type training_contentUpdateWithWhereUniqueWithoutTrainingsInput = {
    where: training_contentWhereUniqueInput
    data: XOR<training_contentUpdateWithoutTrainingsInput, training_contentUncheckedUpdateWithoutTrainingsInput>
  }

  export type training_contentUpdateManyWithWhereWithoutTrainingsInput = {
    where: training_contentScalarWhereInput
    data: XOR<training_contentUpdateManyMutationInput, training_contentUncheckedUpdateManyWithoutTrainingsInput>
  }

  export type training_contentScalarWhereInput = {
    AND?: training_contentScalarWhereInput | training_contentScalarWhereInput[]
    OR?: training_contentScalarWhereInput[]
    NOT?: training_contentScalarWhereInput | training_contentScalarWhereInput[]
    id?: UuidFilter<"training_content"> | string
    training_id?: UuidFilter<"training_content"> | string
    title?: StringFilter<"training_content"> | string
    content_type?: StringFilter<"training_content"> | string
    content_value?: StringFilter<"training_content"> | string
    order_index?: IntFilter<"training_content"> | number
    createdAt?: DateTimeNullableFilter<"training_content"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"training_content"> | Date | string | null
  }

  export type user_training_assignmentsUpsertWithWhereUniqueWithoutTrainingsInput = {
    where: user_training_assignmentsWhereUniqueInput
    update: XOR<user_training_assignmentsUpdateWithoutTrainingsInput, user_training_assignmentsUncheckedUpdateWithoutTrainingsInput>
    create: XOR<user_training_assignmentsCreateWithoutTrainingsInput, user_training_assignmentsUncheckedCreateWithoutTrainingsInput>
  }

  export type user_training_assignmentsUpdateWithWhereUniqueWithoutTrainingsInput = {
    where: user_training_assignmentsWhereUniqueInput
    data: XOR<user_training_assignmentsUpdateWithoutTrainingsInput, user_training_assignmentsUncheckedUpdateWithoutTrainingsInput>
  }

  export type user_training_assignmentsUpdateManyWithWhereWithoutTrainingsInput = {
    where: user_training_assignmentsScalarWhereInput
    data: XOR<user_training_assignmentsUpdateManyMutationInput, user_training_assignmentsUncheckedUpdateManyWithoutTrainingsInput>
  }

  export type user_training_progressUpsertWithWhereUniqueWithoutTrainingsInput = {
    where: user_training_progressWhereUniqueInput
    update: XOR<user_training_progressUpdateWithoutTrainingsInput, user_training_progressUncheckedUpdateWithoutTrainingsInput>
    create: XOR<user_training_progressCreateWithoutTrainingsInput, user_training_progressUncheckedCreateWithoutTrainingsInput>
  }

  export type user_training_progressUpdateWithWhereUniqueWithoutTrainingsInput = {
    where: user_training_progressWhereUniqueInput
    data: XOR<user_training_progressUpdateWithoutTrainingsInput, user_training_progressUncheckedUpdateWithoutTrainingsInput>
  }

  export type user_training_progressUpdateManyWithWhereWithoutTrainingsInput = {
    where: user_training_progressScalarWhereInput
    data: XOR<user_training_progressUpdateManyMutationInput, user_training_progressUncheckedUpdateManyWithoutTrainingsInput>
  }

  export type bootcampsCreateWithoutUser_bootcamp_assignmentsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutBootcampsInput
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutBootcampsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsUncheckedCreateWithoutUser_bootcamp_assignmentsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutBootcampsInput
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutBootcampsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsCreateOrConnectWithoutUser_bootcamp_assignmentsInput = {
    where: bootcampsWhereUniqueInput
    create: XOR<bootcampsCreateWithoutUser_bootcamp_assignmentsInput, bootcampsUncheckedCreateWithoutUser_bootcamp_assignmentsInput>
  }

  export type UserCreateWithoutUser_bootcamp_assignmentsInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUser_bootcamp_assignmentsInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutUser_bootcamp_assignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_bootcamp_assignmentsInput, UserUncheckedCreateWithoutUser_bootcamp_assignmentsInput>
  }

  export type bootcampsUpsertWithoutUser_bootcamp_assignmentsInput = {
    update: XOR<bootcampsUpdateWithoutUser_bootcamp_assignmentsInput, bootcampsUncheckedUpdateWithoutUser_bootcamp_assignmentsInput>
    create: XOR<bootcampsCreateWithoutUser_bootcamp_assignmentsInput, bootcampsUncheckedCreateWithoutUser_bootcamp_assignmentsInput>
    where?: bootcampsWhereInput
  }

  export type bootcampsUpdateToOneWithWhereWithoutUser_bootcamp_assignmentsInput = {
    where?: bootcampsWhereInput
    data: XOR<bootcampsUpdateWithoutUser_bootcamp_assignmentsInput, bootcampsUncheckedUpdateWithoutUser_bootcamp_assignmentsInput>
  }

  export type bootcampsUpdateWithoutUser_bootcamp_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutBootcampsNestedInput
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutBootcampsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutBootcampsNestedInput
  }

  export type bootcampsUncheckedUpdateWithoutUser_bootcamp_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutBootcampsNestedInput
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutBootcampsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutBootcampsNestedInput
  }

  export type UserUpsertWithoutUser_bootcamp_assignmentsInput = {
    update: XOR<UserUpdateWithoutUser_bootcamp_assignmentsInput, UserUncheckedUpdateWithoutUser_bootcamp_assignmentsInput>
    create: XOR<UserCreateWithoutUser_bootcamp_assignmentsInput, UserUncheckedCreateWithoutUser_bootcamp_assignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_bootcamp_assignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_bootcamp_assignmentsInput, UserUncheckedUpdateWithoutUser_bootcamp_assignmentsInput>
  }

  export type UserUpdateWithoutUser_bootcamp_assignmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_bootcamp_assignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type trainingsCreateWithoutUser_training_assignmentsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsUncheckedCreateWithoutUser_training_assignmentsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesUncheckedCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsCreateOrConnectWithoutUser_training_assignmentsInput = {
    where: trainingsWhereUniqueInput
    create: XOR<trainingsCreateWithoutUser_training_assignmentsInput, trainingsUncheckedCreateWithoutUser_training_assignmentsInput>
  }

  export type UserCreateWithoutUser_training_assignmentsInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUser_training_assignmentsInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_progress?: user_training_progressUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutUser_training_assignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_training_assignmentsInput, UserUncheckedCreateWithoutUser_training_assignmentsInput>
  }

  export type trainingsUpsertWithoutUser_training_assignmentsInput = {
    update: XOR<trainingsUpdateWithoutUser_training_assignmentsInput, trainingsUncheckedUpdateWithoutUser_training_assignmentsInput>
    create: XOR<trainingsCreateWithoutUser_training_assignmentsInput, trainingsUncheckedCreateWithoutUser_training_assignmentsInput>
    where?: trainingsWhereInput
  }

  export type trainingsUpdateToOneWithWhereWithoutUser_training_assignmentsInput = {
    where?: trainingsWhereInput
    data: XOR<trainingsUpdateWithoutUser_training_assignmentsInput, trainingsUncheckedUpdateWithoutUser_training_assignmentsInput>
  }

  export type trainingsUpdateWithoutUser_training_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsUncheckedUpdateWithoutUser_training_assignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUncheckedUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutTrainingsNestedInput
  }

  export type UserUpsertWithoutUser_training_assignmentsInput = {
    update: XOR<UserUpdateWithoutUser_training_assignmentsInput, UserUncheckedUpdateWithoutUser_training_assignmentsInput>
    create: XOR<UserCreateWithoutUser_training_assignmentsInput, UserUncheckedCreateWithoutUser_training_assignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_training_assignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_training_assignmentsInput, UserUncheckedUpdateWithoutUser_training_assignmentsInput>
  }

  export type UserUpdateWithoutUser_training_assignmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_training_assignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_progress?: user_training_progressUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bootcampsCreateWithoutUser_training_progressInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutBootcampsInput
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutBootcampsInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsUncheckedCreateWithoutUser_training_progressInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    author?: string | null
    published?: boolean | null
    duration?: number | null
    deadline?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutBootcampsInput
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutBootcampsInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutBootcampsInput
  }

  export type bootcampsCreateOrConnectWithoutUser_training_progressInput = {
    where: bootcampsWhereUniqueInput
    create: XOR<bootcampsCreateWithoutUser_training_progressInput, bootcampsUncheckedCreateWithoutUser_training_progressInput>
  }

  export type trainingsCreateWithoutUser_training_progressInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsUncheckedCreateWithoutUser_training_progressInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    duration?: number | null
    author?: string | null
    published?: boolean | null
    tags?: trainingsCreatetagsInput | string[]
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    certificateTemplate?: string | null
    learning_outcomes?: trainingsCreatelearning_outcomesInput | string[]
    deadline?: Date | string | null
    is_mandatory?: boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedCreateNestedManyWithoutTrainingsInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutTrainingsInput
    quizzes?: quizzesUncheckedCreateNestedManyWithoutTrainingsInput
    training_content?: training_contentUncheckedCreateNestedManyWithoutTrainingsInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutTrainingsInput
  }

  export type trainingsCreateOrConnectWithoutUser_training_progressInput = {
    where: trainingsWhereUniqueInput
    create: XOR<trainingsCreateWithoutUser_training_progressInput, trainingsUncheckedCreateWithoutUser_training_progressInput>
  }

  export type UserCreateWithoutUser_training_progressInput = {
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesCreateNestedManyWithoutUsersInput
    employee?: EmployeeCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    logs?: LogCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUser_training_progressInput = {
    id?: number
    email: string
    password?: string | null
    username?: string | null
    firstName: string
    lastName: string
    role: $Enums.user_role
    loginType: $Enums.login_type
    microsoftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_modified_byTousersInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedCreateNestedManyWithoutUsers_admin_permission_logs_user_idTousersInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_granted_byTousersInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedCreateNestedManyWithoutUsers_admin_permissions_user_idTousersInput
    admin?: AdminUncheckedCreateNestedManyWithoutUserInput
    bootcamp_progress?: bootcamp_progressUncheckedCreateNestedManyWithoutUsersInput
    conference_attendees?: conference_attendeesUncheckedCreateNestedManyWithoutUsersInput
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    logs?: LogUncheckedCreateNestedManyWithoutUsersInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedCreateNestedManyWithoutUsersInput
    user_training_assignments?: user_training_assignmentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutUser_training_progressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_training_progressInput, UserUncheckedCreateWithoutUser_training_progressInput>
  }

  export type bootcampsUpsertWithoutUser_training_progressInput = {
    update: XOR<bootcampsUpdateWithoutUser_training_progressInput, bootcampsUncheckedUpdateWithoutUser_training_progressInput>
    create: XOR<bootcampsCreateWithoutUser_training_progressInput, bootcampsUncheckedCreateWithoutUser_training_progressInput>
    where?: bootcampsWhereInput
  }

  export type bootcampsUpdateToOneWithWhereWithoutUser_training_progressInput = {
    where?: bootcampsWhereInput
    data: XOR<bootcampsUpdateWithoutUser_training_progressInput, bootcampsUncheckedUpdateWithoutUser_training_progressInput>
  }

  export type bootcampsUpdateWithoutUser_training_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutBootcampsNestedInput
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutBootcampsNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutBootcampsNestedInput
  }

  export type bootcampsUncheckedUpdateWithoutUser_training_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutBootcampsNestedInput
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutBootcampsNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutBootcampsNestedInput
  }

  export type trainingsUpsertWithoutUser_training_progressInput = {
    update: XOR<trainingsUpdateWithoutUser_training_progressInput, trainingsUncheckedUpdateWithoutUser_training_progressInput>
    create: XOR<trainingsCreateWithoutUser_training_progressInput, trainingsUncheckedCreateWithoutUser_training_progressInput>
    where?: trainingsWhereInput
  }

  export type trainingsUpdateToOneWithWhereWithoutUser_training_progressInput = {
    where?: trainingsWhereInput
    data: XOR<trainingsUpdateWithoutUser_training_progressInput, trainingsUncheckedUpdateWithoutUser_training_progressInput>
  }

  export type trainingsUpdateWithoutUser_training_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutTrainingsNestedInput
  }

  export type trainingsUncheckedUpdateWithoutUser_training_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    published?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tags?: trainingsUpdatetagsInput | string[]
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    learning_outcomes?: trainingsUpdatelearning_outcomesInput | string[]
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_mandatory?: NullableBoolFieldUpdateOperationsInput | boolean | null
    bootcamp_trainings?: bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutTrainingsNestedInput
    quizzes?: quizzesUncheckedUpdateManyWithoutTrainingsNestedInput
    training_content?: training_contentUncheckedUpdateManyWithoutTrainingsNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutTrainingsNestedInput
  }

  export type UserUpsertWithoutUser_training_progressInput = {
    update: XOR<UserUpdateWithoutUser_training_progressInput, UserUncheckedUpdateWithoutUser_training_progressInput>
    create: XOR<UserCreateWithoutUser_training_progressInput, UserUncheckedCreateWithoutUser_training_progressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_training_progressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_training_progressInput, UserUncheckedUpdateWithoutUser_training_progressInput>
  }

  export type UserUpdateWithoutUser_training_progressInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    logs?: LogUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_training_progressInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: Enumuser_roleFieldUpdateOperationsInput | $Enums.user_role
    loginType?: Enumlogin_typeFieldUpdateOperationsInput | $Enums.login_type
    microsoftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin_permission_logs_admin_permission_logs_modified_byTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersNestedInput
    admin_permission_logs_admin_permission_logs_user_idTousers?: admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersNestedInput
    admin_permissions_admin_permissions_granted_byTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersNestedInput
    admin_permissions_admin_permissions_user_idTousers?: admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersNestedInput
    admin?: AdminUncheckedUpdateManyWithoutUserNestedInput
    bootcamp_progress?: bootcamp_progressUncheckedUpdateManyWithoutUsersNestedInput
    conference_attendees?: conference_attendeesUncheckedUpdateManyWithoutUsersNestedInput
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    logs?: LogUncheckedUpdateManyWithoutUsersNestedInput
    user_bootcamp_assignments?: user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
    user_training_assignments?: user_training_assignmentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type admin_permission_logsCreateManyUsers_admin_permission_logs_modified_byTousersInput = {
    id?: number
    user_id: number
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
  }

  export type admin_permission_logsCreateManyUsers_admin_permission_logs_user_idTousersInput = {
    id?: number
    modified_by: number
    action: string
    previous_role?: string | null
    new_role?: string | null
    action_date?: Date | string
    notes?: string | null
  }

  export type admin_permissionsCreateManyUsers_admin_permissions_granted_byTousersInput = {
    id?: number
    user_id: number
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
  }

  export type admin_permissionsCreateManyUsers_admin_permissions_user_idTousersInput = {
    id?: number
    granted_by: number
    permission_level?: string
    granted_at?: Date | string
    revoked_at?: Date | string | null
    is_active?: boolean
  }

  export type AdminCreateManyUserInput = {
    id?: number
    adminLevel: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bootcamp_progressCreateManyUsersInput = {
    id?: string
    bootcamp_id: string
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
  }

  export type conference_attendeesCreateManyUsersInput = {
    id?: string
    conference_id: string
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
  }

  export type EmployeeCreateManyUserInput = {
    id?: number
    telesetCardNo?: string | null
    departmentId?: number | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type enrollmentsCreateManyUsersInput = {
    id?: number
    training_id: string
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type LogCreateManyUsersInput = {
    id?: number
    action_type: string
    ip_address?: string | null
    user_agent?: string | null
    created_at?: Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: boolean | null
  }

  export type user_bootcamp_assignmentsCreateManyUsersInput = {
    id?: string
    bootcamp_id: string
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
  }

  export type user_training_assignmentsCreateManyUsersInput = {
    assignment_id?: number
    training_id: string
    assigned_at?: Date | string | null
  }

  export type user_training_progressCreateManyUsersInput = {
    bootcamp_id?: string | null
    training_id: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
  }

  export type admin_permission_logsUpdateWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    users_admin_permission_logs_user_idTousers?: UserUpdateOneRequiredWithoutAdmin_permission_logs_admin_permission_logs_user_idTousersNestedInput
  }

  export type admin_permission_logsUncheckedUpdateWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_modified_byTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permission_logsUpdateWithoutUsers_admin_permission_logs_user_idTousersInput = {
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    users_admin_permission_logs_modified_byTousers?: UserUpdateOneRequiredWithoutAdmin_permission_logs_admin_permission_logs_modified_byTousersNestedInput
  }

  export type admin_permission_logsUncheckedUpdateWithoutUsers_admin_permission_logs_user_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    modified_by?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permission_logsUncheckedUpdateManyWithoutUsers_admin_permission_logs_user_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    modified_by?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    previous_role?: NullableStringFieldUpdateOperationsInput | string | null
    new_role?: NullableStringFieldUpdateOperationsInput | string | null
    action_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type admin_permissionsUpdateWithoutUsers_admin_permissions_granted_byTousersInput = {
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    users_admin_permissions_user_idTousers?: UserUpdateOneRequiredWithoutAdmin_permissions_admin_permissions_user_idTousersNestedInput
  }

  export type admin_permissionsUncheckedUpdateWithoutUsers_admin_permissions_granted_byTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_granted_byTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_permissionsUpdateWithoutUsers_admin_permissions_user_idTousersInput = {
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    users_admin_permissions_granted_byTousers?: UserUpdateOneRequiredWithoutAdmin_permissions_admin_permissions_granted_byTousersNestedInput
  }

  export type admin_permissionsUncheckedUpdateWithoutUsers_admin_permissions_user_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    granted_by?: IntFieldUpdateOperationsInput | number
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type admin_permissionsUncheckedUpdateManyWithoutUsers_admin_permissions_user_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    granted_by?: IntFieldUpdateOperationsInput | number
    permission_level?: StringFieldUpdateOperationsInput | string
    granted_at?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminUpdateWithoutUserInput = {
    adminLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    adminLevel?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bootcamp_progressUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneRequiredWithoutBootcamp_progressNestedInput
  }

  export type bootcamp_progressUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_progressUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_attendeesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    conference_trainings?: conference_trainingsUpdateOneRequiredWithoutConference_attendeesNestedInput
  }

  export type conference_attendeesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conference_id?: StringFieldUpdateOperationsInput | string
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conference_attendeesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    conference_id?: StringFieldUpdateOperationsInput | string
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeUpdateWithoutUserInput = {
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type enrollmentsUpdateWithoutUsersInput = {
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainings?: trainingsUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogUpdateWithoutUsersInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LogUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type LogUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: NullableJsonNullValueInput | InputJsonValue
    is_suspicious?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type user_bootcamp_assignmentsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneRequiredWithoutUser_bootcamp_assignmentsNestedInput
  }

  export type user_bootcamp_assignmentsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_bootcamp_assignmentsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_assignmentsUpdateWithoutUsersInput = {
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainings?: trainingsUpdateOneRequiredWithoutUser_training_assignmentsNestedInput
  }

  export type user_training_assignmentsUncheckedUpdateWithoutUsersInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_assignmentsUncheckedUpdateManyWithoutUsersInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressUpdateWithoutUsersInput = {
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneWithoutUser_training_progressNestedInput
    trainings?: trainingsUpdateOneRequiredWithoutUser_training_progressNestedInput
  }

  export type user_training_progressUncheckedUpdateWithoutUsersInput = {
    bootcamp_id?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressUncheckedUpdateManyWithoutUsersInput = {
    bootcamp_id?: NullableStringFieldUpdateOperationsInput | string | null
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: number
    telesetCardNo?: string | null
    userId: number
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    telesetCardNo?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bootcamp_progressCreateManyBootcampsInput = {
    id?: string
    user_id: number
    current_training_index?: number | null
    progress_percentage?: Decimal | DecimalJsLike | number | string | null
    last_activity?: Date | string | null
  }

  export type bootcamp_trainingsCreateManyBootcampsInput = {
    id?: string
    training_id: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
  }

  export type user_bootcamp_assignmentsCreateManyBootcampsInput = {
    id?: string
    user_id: number
    assigned_at?: Date | string | null
    completed?: boolean | null
    completion_date?: Date | string | null
  }

  export type user_training_progressCreateManyBootcampsInput = {
    user_id: number
    training_id: string
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
  }

  export type bootcamp_progressUpdateWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneRequiredWithoutBootcamp_progressNestedInput
  }

  export type bootcamp_progressUncheckedUpdateWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_progressUncheckedUpdateManyWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    current_training_index?: NullableIntFieldUpdateOperationsInput | number | null
    progress_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    last_activity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_trainingsUpdateWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainings?: trainingsUpdateOneRequiredWithoutBootcamp_trainingsNestedInput
  }

  export type bootcamp_trainingsUncheckedUpdateWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_trainingsUncheckedUpdateManyWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    training_id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_bootcamp_assignmentsUpdateWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneRequiredWithoutUser_bootcamp_assignmentsNestedInput
  }

  export type user_bootcamp_assignmentsUncheckedUpdateWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_bootcamp_assignmentsUncheckedUpdateManyWithoutBootcampsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    completion_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressUpdateWithoutBootcampsInput = {
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trainings?: trainingsUpdateOneRequiredWithoutUser_training_progressNestedInput
    users?: UserUpdateOneRequiredWithoutUser_training_progressNestedInput
  }

  export type user_training_progressUncheckedUpdateWithoutBootcampsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressUncheckedUpdateManyWithoutBootcampsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    training_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_attendeesCreateManyConference_trainingsInput = {
    id?: string
    user_id: number
    registered_at?: Date | string | null
    attended?: boolean | null
    attendance_time?: Date | string | null
    notes?: string | null
  }

  export type conference_materialsCreateManyConference_trainingsInput = {
    id?: string
    title: string
    description?: string | null
    file_path?: string | null
    link?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type conference_attendeesUpdateWithoutConference_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    users?: UserUpdateOneRequiredWithoutConference_attendeesNestedInput
  }

  export type conference_attendeesUncheckedUpdateWithoutConference_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conference_attendeesUncheckedUpdateManyWithoutConference_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    registered_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attended?: NullableBoolFieldUpdateOperationsInput | boolean | null
    attendance_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conference_materialsUpdateWithoutConference_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_materialsUncheckedUpdateWithoutConference_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conference_materialsUncheckedUpdateManyWithoutConference_trainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsCreateManyQuizzesInput = {
    id?: string
    question_text: string
    question_type: string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: JsonNullValueInput | InputJsonValue
    points?: number | null
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type questionsUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    points?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    points?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type questionsUncheckedUpdateManyWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: StringFieldUpdateOperationsInput | string
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: JsonNullValueInput | InputJsonValue
    points?: NullableIntFieldUpdateOperationsInput | number | null
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_trainingsCreateManyTrainingsInput = {
    id?: string
    bootcamp_id: string
    order_index: number
    required?: boolean | null
    created_at?: Date | string | null
  }

  export type enrollmentsCreateManyTrainingsInput = {
    id?: number
    user_id: number
    status?: string
    progress?: number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: Decimal | DecimalJsLike | number | string | null
    start_date?: Date | string | null
    completed_at?: Date | string | null
    last_accessed_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type quizzesCreateManyTrainingsInput = {
    id?: string
    title: string
    description?: string | null
    pass_threshold?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type training_contentCreateManyTrainingsInput = {
    id?: string
    title: string
    content_type: string
    content_value: string
    order_index: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type user_training_assignmentsCreateManyTrainingsInput = {
    assignment_id?: number
    user_id: number
    assigned_at?: Date | string | null
  }

  export type user_training_progressCreateManyTrainingsInput = {
    user_id: number
    bootcamp_id?: string | null
    status?: string
    started_at?: Date | string | null
    completed_at?: Date | string | null
    progress_percentage?: Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: number | null
    updatedAt?: Date | string | null
  }

  export type bootcamp_trainingsUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneRequiredWithoutBootcamp_trainingsNestedInput
  }

  export type bootcamp_trainingsUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bootcamp_trainingsUncheckedUpdateManyWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bootcamp_id?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    required?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUpdateWithoutTrainingsInput = {
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateWithoutTrainingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUncheckedUpdateManyWithoutTrainingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completed_items?: NullableJsonNullValueInput | InputJsonValue
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    last_accessed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type quizzesUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: questionsUpdateManyWithoutQuizzesNestedInput
  }

  export type quizzesUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: questionsUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type quizzesUncheckedUpdateManyWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pass_threshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type training_contentUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content_type?: StringFieldUpdateOperationsInput | string
    content_value?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type training_contentUncheckedUpdateWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content_type?: StringFieldUpdateOperationsInput | string
    content_value?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type training_contentUncheckedUpdateManyWithoutTrainingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content_type?: StringFieldUpdateOperationsInput | string
    content_value?: StringFieldUpdateOperationsInput | string
    order_index?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_assignmentsUpdateWithoutTrainingsInput = {
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateOneRequiredWithoutUser_training_assignmentsNestedInput
  }

  export type user_training_assignmentsUncheckedUpdateWithoutTrainingsInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_assignmentsUncheckedUpdateManyWithoutTrainingsInput = {
    assignment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    assigned_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressUpdateWithoutTrainingsInput = {
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bootcamps?: bootcampsUpdateOneWithoutUser_training_progressNestedInput
    users?: UserUpdateOneRequiredWithoutUser_training_progressNestedInput
  }

  export type user_training_progressUncheckedUpdateWithoutTrainingsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    bootcamp_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type user_training_progressUncheckedUpdateManyWithoutTrainingsInput = {
    user_id?: IntFieldUpdateOperationsInput | number
    bootcamp_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress_percentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    completed_content_items?: JsonNullValueInput | InputJsonValue
    completion_duration_seconds?: NullableIntFieldUpdateOperationsInput | number | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}